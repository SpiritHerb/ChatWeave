<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChatWeave v1.6.2 - 统一会话工作台</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* 默认主题：海湾蓝（深色） */
            --md-sys-color-primary: #8BD0EF;
            --md-sys-color-on-primary: #003546;
            --md-sys-color-primary-container: #004D64;
            --md-sys-color-on-primary-container: #BDE9FF;
            
            --md-sys-color-secondary: #B4CAD6;
            --md-sys-color-on-secondary: #1F333C;
            --md-sys-color-secondary-container: #354A53;
            --md-sys-color-on-secondary-container: #D0E6F2;
            
            --md-sys-color-tertiary: #C6C2EA;
            --md-sys-color-on-tertiary: #2E2D4D;
            --md-sys-color-tertiary-container: #454364;
            --md-sys-color-on-tertiary-container: #E3DFFF;
            
            --md-sys-color-error: #FFB4AB;
            --md-sys-color-on-error: #690005;
            --md-sys-color-error-container: #93000A;
            --md-sys-color-on-error-container: #FFDAD6;
            
            --md-sys-color-background: #0F1417;
            --md-sys-color-on-background: #DFE3E7;
            --md-sys-color-surface: #0F1417;
            --md-sys-color-on-surface: #DFE3E7;
            --md-sys-color-surface-variant: #40484C;
            --md-sys-color-on-surface-variant: #C0C8CD;
            
            --md-sys-color-outline: #8A9297;
            --md-sys-color-outline-variant: #40484C;
            
            --md-sys-color-surface-container: #1B2023;
            --md-sys-color-surface-container-high: #262B2D;
            --md-sys-color-surface-container-highest: #303538;
            
            --md-sys-shape-corner-small: 8px;
            --md-sys-shape-corner-medium: 12px;
            --md-sys-shape-corner-large: 16px;
            --md-sys-shape-corner-xl: 28px;
            --md-sys-shape-corner-full: 9999px;
            
            --md-sys-spacing-xs: 4px;
            --md-sys-spacing-sm: 8px;
            --md-sys-spacing-md: 12px;
            --md-sys-spacing-lg: 16px;
            --md-sys-spacing-xl: 24px;
            --md-sys-spacing-2xl: 32px;
            
            --md-sys-font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --md-sys-color-primary: #8BD0EF;
                --md-sys-color-on-primary: #003546;
                --md-sys-color-primary-container: #004D64;
                --md-sys-color-on-primary-container: #BDE9FF;
                
                --md-sys-color-secondary: #B4CAD6;
                --md-sys-color-on-secondary: #1F333C;
                --md-sys-color-secondary-container: #354A53;
                --md-sys-color-on-secondary-container: #D0E6F2;
                
                --md-sys-color-tertiary: #C6C2EA;
                --md-sys-color-on-tertiary: #2E2D4D;
                --md-sys-color-tertiary-container: #454364;
                --md-sys-color-on-tertiary-container: #E3DFFF;
                
                --md-sys-color-error: #FFB4AB;
                --md-sys-color-on-error: #690005;
                --md-sys-color-error-container: #93000A;
                --md-sys-color-on-error-container: #FFDAD6;
                
                --md-sys-color-background: #0F1417;
                --md-sys-color-on-background: #DFE3E7;
                --md-sys-color-surface: #0F1417;
                --md-sys-color-on-surface: #DFE3E7;
                --md-sys-color-surface-variant: #40484C;
                --md-sys-color-on-surface-variant: #C0C8CD;
                
                --md-sys-color-outline: #8A9297;
                --md-sys-color-outline-variant: #40484C;
                
                --md-sys-color-surface-container: #1B2023;
                --md-sys-color-surface-container-high: #262B2D;
                --md-sys-color-surface-container-highest: #303538;
            }
        }

        body {
            font-family: var(--md-sys-font-family);
            background: var(--md-sys-color-background);
            color: var(--md-sys-color-on-background);
            min-height: 100vh;
            padding: var(--md-sys-spacing-xl);
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: var(--md-sys-color-surface);
        }

        h1 {
            text-align: center;
            color: var(--md-sys-color-on-surface);
            margin-bottom: var(--md-sys-spacing-xs);
            font-size: 28px;
        }

        .subtitle {
            text-align: center;
            color: var(--md-sys-color-on-surface-variant);
            margin-bottom: var(--md-sys-spacing-2xl);
            font-size: 14px;
        }

        /* 卡片组件 - 参考 Material Design 3 Elevation */
        .card {
            background: var(--md-sys-color-surface-container);
            border-radius: var(--md-sys-shape-corner-large);
            padding: var(--md-sys-spacing-lg);
            margin-bottom: var(--md-sys-spacing-lg);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.06), 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: box-shadow 0.2s ease;
        }

        .card.warning-card {
            border: 2px solid var(--md-sys-color-tertiary-container);
            background: linear-gradient(to bottom, var(--md-sys-color-surface-container) 0%, rgba(255, 220, 162, 0.1) 100%);
        }

        /* 上传卡片增强阴影 */
        .upload-card {
            background: var(--md-sys-color-surface-container-high);
            border-radius: var(--md-sys-shape-corner-large);
            padding: var(--md-sys-spacing-lg);
            position: relative;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.06), 0 2px 4px rgba(0, 0, 0, 0.08);
            transition: box-shadow 0.2s ease;
        }

        .upload-card:hover {
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08), 0 4px 8px rgba(0, 0, 0, 0.12);
        }

        /* Tab 按钮 */
        .tabs {
            display: flex;
            gap: var(--md-sys-spacing-sm);
            margin-bottom: var(--md-sys-spacing-lg);
            border-bottom: 1px solid var(--md-sys-color-outline-variant);
            padding-bottom: var(--md-sys-spacing-sm);
        }

        .tab-btn {
            background: none;
            border: none;
            color: var(--md-sys-color-on-surface-variant);
            font-family: var(--md-sys-font-family);
            font-size: 14px;
            font-weight: 500;
            padding: var(--md-sys-spacing-sm) var(--md-sys-spacing-md);
            border-radius: var(--md-sys-shape-corner-full);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .tab-btn:hover {
            background: var(--md-sys-color-surface-container-high);
            transform: translateY(-1px);
        }

        .tab-btn.active {
            background: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            font-weight: 600;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .tab-content p {
            color: var(--md-sys-color-on-surface);
            font-size: 14px;
            line-height: 1.8;
            margin: var(--md-sys-spacing-sm) 0;
        }

        .tab-content strong {
            color: var(--md-sys-color-on-surface);
            font-weight: 600;
        }

        .tab-content ul {
            margin: var(--md-sys-spacing-sm) 0;
            padding-left: 20px;
            list-style-position: outside;
        }

        .tab-content li {
            color: var(--md-sys-color-on-surface);
            font-size: 14px;
            line-height: 1.8;
            margin: var(--md-sys-spacing-xs) 0;
            padding-left: 4px;
        }

        /* 按钮组 */
        .button-group {
            display: flex;
            gap: var(--md-sys-spacing-sm);
            margin-bottom: var(--md-sys-spacing-lg);
            flex-wrap: wrap;
        }

        .btn-text {
            background: none;
            border: none;
            color: var(--md-sys-color-primary);
            font-family: var(--md-sys-font-family);
            font-size: 14px;
            font-weight: 500;
            padding: var(--md-sys-spacing-sm) var(--md-sys-spacing-md);
            border-radius: var(--md-sys-shape-corner-full);
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .btn-text::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: var(--md-sys-color-primary-container);
            transform: translate(-50%, -50%);
            transition: width 0.4s ease, height 0.4s ease;
            opacity: 0.5;
        }

        .btn-text:hover {
            background: var(--md-sys-color-primary-container);
            transform: translateY(-1px);
        }

        .btn-text:hover::before {
            width: 200%;
            height: 200%;
        }

        /* 自定义下拉框 */
        .select-wrapper {
            position: relative;
            width: 100%;
        }

        .custom-select {
            width: 100%;
            padding: var(--md-sys-spacing-md);
            border: 1px solid var(--md-sys-color-outline);
            border-radius: var(--md-sys-shape-corner-medium);
            background: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            font-family: var(--md-sys-font-family);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .custom-select:hover {
            border-color: var(--md-sys-color-primary);
            background: var(--md-sys-color-surface-container-high);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .select-wrapper.open .custom-select {
            border-color: var(--md-sys-color-primary);
            box-shadow: 0 4px 12px rgba(142, 73, 85, 0.15);
        }

        .custom-select::after {
            content: '';
            position: absolute;
            right: var(--md-sys-spacing-md);
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 6px solid var(--md-sys-color-on-surface-variant);
            pointer-events: none;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .select-wrapper.open .custom-select::after {
            transform: translateY(-50%) rotate(180deg);
        }

        .select-dropdown {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            right: 0;
            background: var(--md-sys-color-surface);
            border: 1px solid var(--md-sys-color-outline);
            border-radius: var(--md-sys-shape-corner-medium);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
            z-index: 100;
            display: none;
            animation: dropdownFadeIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
            max-height: 200px;
            overflow-y: auto;
        }

        .select-dropdown.show {
            display: block;
        }

        .select-option {
            padding: var(--md-sys-spacing-md);
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            color: var(--md-sys-color-on-surface);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .select-option:hover {
            background: var(--md-sys-color-surface-container-high);
        }

        .select-option.selected {
            background: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            font-weight: 500;
        }

        @keyframes dropdownFadeIn {
            from {
                opacity: 0;
                transform: translateY(-8px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* 上传网格布局 */
        .upload-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: var(--md-sys-spacing-lg);
            margin-bottom: var(--md-sys-spacing-lg);
        }

        /* 平板及以上设备使用双列，手机竖屏使用单列 */
        @media (max-width: 768px) and (orientation: portrait) {
            .upload-grid {
                grid-template-columns: 1fr;
            }
        }

        /* 小屏设备强制单列 */
        @media (max-width: 600px) {
            .upload-grid {
                grid-template-columns: 1fr;
            }
        }

        /* 上传卡片 */
        .upload-card {
            background: var(--md-sys-color-surface-container-high);
            border-radius: var(--md-sys-shape-corner-large);
            padding: var(--md-sys-spacing-lg);
            position: relative;
        }

        .step-badge {
            position: absolute;
            top: var(--md-sys-spacing-md);
            right: var(--md-sys-spacing-md);
            background: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 600;
        }

        .upload-card h3 {
            color: var(--md-sys-color-on-surface);
            margin-bottom: var(--md-sys-spacing-md);
            font-size: 14px;
        }

        /* 上传框 */
        .upload-box {
            border: 2px dashed var(--md-sys-color-outline);
            border-radius: var(--md-sys-shape-corner-medium);
            padding: var(--md-sys-spacing-xl);
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: var(--md-sys-color-surface);
        }

        .upload-box:hover {
            border-color: var(--md-sys-color-primary);
            background: var(--md-sys-color-surface-container);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .upload-box.has-file {
            border: 2px solid #4CAF50;
            background: #C8E6C9;
            color: #1B5E20;
        }

        .upload-box.error {
            border-color: var(--md-sys-color-error);
            background: var(--md-sys-color-error-container);
            color: var(--md-sys-color-on-error-container);
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: var(--md-sys-spacing-sm);
            transition: transform 0.3s ease;
        }

        .upload-box:hover .upload-icon {
            transform: scale(1.1);
        }

        .upload-text {
            color: var(--md-sys-color-on-surface-variant);
            font-size: 14px;
        }

        .upload-box.has-file .upload-text {
            color: #1B5E20;
        }

        /* 粘贴按钮组 */
        .paste-buttons {
            display: flex;
            gap: var(--md-sys-spacing-sm);
            margin-top: var(--md-sys-spacing-md);
        }

        .paste-btn {
            flex: 1;
            padding: var(--md-sys-spacing-sm) var(--md-sys-spacing-md);
            background: var(--md-sys-color-secondary-container);
            color: var(--md-sys-color-on-secondary-container);
            border: 1px solid var(--md-sys-color-outline);
            border-radius: var(--md-sys-shape-corner-small);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: var(--md-sys-font-family);
        }

        .paste-btn:hover {
            background: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            border-color: var(--md-sys-color-primary);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(142, 73, 85, 0.3);
        }

        .paste-btn:active {
            transform: translateY(0);
        }

        /* 粘贴对话框 */
        .paste-modal {
            max-width: 600px;
            width: 90%;
        }

        .paste-textarea {
            width: 100%;
            min-height: 200px;
            max-height: 400px;
            padding: var(--md-sys-spacing-md);
            border: 2px solid var(--md-sys-color-outline);
            border-radius: var(--md-sys-shape-corner-medium);
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: vertical;
            background: var(--md-sys-color-surface-container-low);
            color: var(--md-sys-color-on-surface);
            transition: all 0.2s ease;
        }

        .paste-textarea:focus {
            outline: none;
            border-color: var(--md-sys-color-primary);
            box-shadow: 0 0 0 3px rgba(142, 73, 85, 0.1);
        }

        .paste-textarea::placeholder {
            color: var(--md-sys-color-on-surface-variant);
            opacity: 0.7;
        }

        /* 预览编辑对话框 */
        .preview-edit-modal {
            max-width: 1040px;
            width: 94%;
            max-height: 92vh;
        }

        .preview-modal-body {
            max-height: calc(92vh - 80px);
            overflow-y: auto;
        }

        .preview-intro {
            margin-bottom: var(--md-sys-spacing-md);
            color: var(--md-sys-color-on-surface-variant);
            font-size: 13px;
            line-height: 1.6;
        }

        .preview-layout {
            display: flex;
            flex-direction: column;
            gap: var(--md-sys-spacing-md);
        }

        .preview-edit-modal.message-only .preview-meta-panel {
            display: none;
        }

        .preview-edit-modal.message-only .preview-intro {
            margin-bottom: var(--md-sys-spacing-sm);
        }

        .preview-meta-panel,
        .preview-messages-panel {
            display: flex;
            flex-direction: column;
            gap: var(--md-sys-spacing-md);
            min-width: 0;
        }

        .preview-section {
            padding: var(--md-sys-spacing-md);
            background: var(--md-sys-color-surface-container-low);
            border-radius: var(--md-sys-shape-corner-medium);
            margin-bottom: 0;
        }

        .preview-section-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: var(--md-sys-spacing-md);
            color: var(--md-sys-color-on-surface);
            letter-spacing: 0;
        }

        .preview-form {
            display: flex;
            flex-direction: column;
            gap: var(--md-sys-spacing-md);
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--md-sys-spacing-md);
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: var(--md-sys-spacing-xs);
        }

        .form-label {
            font-size: 13px;
            font-weight: 500;
            color: var(--md-sys-color-on-surface-variant);
        }

        .form-input {
            padding: var(--md-sys-spacing-sm) var(--md-sys-spacing-md);
            border: 2px solid var(--md-sys-color-outline);
            border-radius: var(--md-sys-shape-corner-small);
            font-size: 14px;
            background: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            transition: all 0.2s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--md-sys-color-primary);
            box-shadow: 0 0 0 3px rgba(142, 73, 85, 0.1);
        }

        .form-input[readonly] {
            background: var(--md-sys-color-surface-container-high);
            cursor: not-allowed;
            opacity: 0.7;
        }

        /* 消息列表工具栏 */
        .preview-messages-toolbar {
            display: flex;
            gap: var(--md-sys-spacing-sm);
            margin-bottom: var(--md-sys-spacing-sm);
        }

        .toolbar-btn {
            padding: 6px 12px;
            font-size: 12px;
            background: var(--md-sys-color-secondary-container);
            color: var(--md-sys-color-on-secondary-container);
            border: 1px solid var(--md-sys-color-outline);
            border-radius: var(--md-sys-shape-corner-small);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .toolbar-btn:hover {
            background: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            border-color: var(--md-sys-color-primary);
        }

        /* 消息列表 */
        .preview-messages-list {
            min-height: 280px;
            max-height: min(58vh, 640px);
            overflow-y: auto;
            border: 2px solid var(--md-sys-color-outline);
            border-radius: var(--md-sys-shape-corner-small);
            background: var(--md-sys-color-surface);
        }

        .preview-message-item {
            padding: var(--md-sys-spacing-md);
            border-bottom: 1px solid var(--md-sys-color-outline);
            display: flex;
            gap: var(--md-sys-spacing-sm);
            align-items: flex-start;
            transition: background 0.2s ease;
        }

        .preview-message-item:last-child {
            border-bottom: none;
        }

        .preview-message-item:hover {
            background: var(--md-sys-color-surface-container-low);
        }

        .preview-message-item.is-unselected {
            opacity: 0.62;
        }

        .preview-message-item.role-user {
            background: color-mix(in srgb, var(--md-sys-color-primary-container) 18%, transparent);
        }

        .preview-message-item.role-assistant {
            background: color-mix(in srgb, var(--md-sys-color-surface-container-high) 60%, transparent);
        }

        .preview-message-checkbox {
            margin-top: 4px;
            cursor: pointer;
        }

        .preview-message-content {
            flex: 1;
            min-width: 0;
        }

        .preview-message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--md-sys-spacing-xs);
        }

        .preview-message-role {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .preview-message-role.user {
            color: var(--md-sys-color-primary);
        }

        .preview-message-role.assistant {
            color: var(--md-sys-color-on-surface-variant);
        }

        .preview-message-role.system {
            color: #7b57c2;
        }

        .preview-message-role.tool {
            color: #0b7f8c;
        }

        .preview-message-time {
            font-size: 11px;
            color: var(--md-sys-color-on-surface-variant);
        }

        .preview-message-text {
            font-size: 13px;
            line-height: 1.5;
            color: var(--md-sys-color-on-surface);
            word-wrap: break-word;
            white-space: pre-wrap;
            max-height: 84px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .preview-message-actions {
            display: flex;
            gap: var(--md-sys-spacing-xs);
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .preview-chat-main {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .preview-chat-meta {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .preview-chat-bubble {
            position: relative;
            border: 1px solid var(--md-sys-color-outline-variant);
            border-radius: 12px;
            padding: 10px 12px;
            background: var(--md-sys-color-surface);
            overflow: hidden;
        }

        .preview-message-item.role-user .preview-chat-bubble {
            border-color: color-mix(in srgb, var(--md-sys-color-primary) 30%, var(--md-sys-color-outline-variant));
            background: color-mix(in srgb, var(--md-sys-color-primary-container) 38%, var(--md-sys-color-surface));
        }

        .preview-chat-bubble.collapsed {
            max-height: 148px;
        }

        .preview-chat-bubble.collapsed::after {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 36px;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0), var(--md-sys-color-surface));
            pointer-events: none;
        }

        .preview-message-item.role-user .preview-chat-bubble.collapsed::after {
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0), color-mix(in srgb, var(--md-sys-color-primary-container) 38%, var(--md-sys-color-surface)));
        }

        .preview-chat-text {
            font-size: 13px;
            line-height: 1.6;
            color: var(--md-sys-color-on-surface);
            white-space: normal;
            word-break: break-word;
        }

        .preview-chat-text pre {
            margin: 8px 0;
            padding: 8px 10px;
            border-radius: 8px;
            background: var(--md-sys-color-surface-container-high);
            overflow-x: auto;
            font-size: 12px;
        }

        .preview-chat-text code {
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        }

        .preview-chat-text img {
            max-width: min(320px, 100%);
            max-height: 220px;
            border-radius: 10px;
            border: 1px solid var(--md-sys-color-outline-variant);
            display: block;
            margin: 8px 0;
            object-fit: cover;
        }

        .preview-chat-text a {
            color: var(--md-sys-color-primary);
            text-decoration: underline;
            word-break: break-all;
        }

        .preview-chat-text .preview-rich-callout,
        .workspace-preview-rich .preview-rich-callout {
            margin: 8px 0;
            border: 1px solid var(--md-sys-color-outline-variant);
            border-radius: 10px;
            background: color-mix(in srgb, var(--md-sys-color-surface-container-high) 70%, var(--md-sys-color-surface));
            overflow: hidden;
        }

        .preview-chat-text .preview-rich-callout-summary,
        .workspace-preview-rich .preview-rich-callout-summary {
            list-style: none;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            cursor: pointer;
            user-select: none;
            color: var(--md-sys-color-on-surface);
            font-size: 12px;
            font-weight: 600;
        }

        .preview-chat-text .preview-rich-callout-summary::-webkit-details-marker,
        .workspace-preview-rich .preview-rich-callout-summary::-webkit-details-marker {
            display: none;
        }

        .preview-chat-text details.preview-rich-callout[open] .preview-rich-callout-summary,
        .workspace-preview-rich details.preview-rich-callout[open] .preview-rich-callout-summary {
            border-bottom: 1px dashed var(--md-sys-color-outline-variant);
        }

        .preview-chat-text .preview-rich-callout-head,
        .workspace-preview-rich .preview-rich-callout-head {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            border-bottom: 1px dashed var(--md-sys-color-outline-variant);
            font-size: 12px;
            font-weight: 600;
            color: var(--md-sys-color-on-surface);
        }

        .preview-chat-text .preview-rich-callout-icon,
        .workspace-preview-rich .preview-rich-callout-icon {
            width: 18px;
            height: 18px;
            border-radius: 999px;
            border: 1px solid var(--md-sys-color-outline-variant);
            background: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface-variant);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            line-height: 1;
            flex-shrink: 0;
        }

        .preview-chat-text .preview-rich-callout-title,
        .workspace-preview-rich .preview-rich-callout-title {
            min-width: 0;
            word-break: break-word;
        }

        .preview-chat-text .preview-rich-callout-body,
        .workspace-preview-rich .preview-rich-callout-body {
            padding: 8px 10px;
            font-size: 12px;
            line-height: 1.6;
            color: var(--md-sys-color-on-surface);
            word-break: break-word;
            overflow-wrap: anywhere;
        }

        .preview-chat-text .preview-rich-callout-reasoning,
        .workspace-preview-rich .preview-rich-callout-reasoning {
            background: color-mix(in srgb, #7b57c2 8%, var(--md-sys-color-surface));
            border-color: color-mix(in srgb, #7b57c2 38%, var(--md-sys-color-outline-variant));
        }

        .preview-chat-text .preview-rich-callout-tool,
        .workspace-preview-rich .preview-rich-callout-tool {
            background: color-mix(in srgb, #2f7fbf 8%, var(--md-sys-color-surface));
            border-color: color-mix(in srgb, #2f7fbf 34%, var(--md-sys-color-outline-variant));
        }

        .preview-chat-text .preview-rich-callout-tool-result,
        .workspace-preview-rich .preview-rich-callout-tool-result {
            background: color-mix(in srgb, #2b9860 8%, var(--md-sys-color-surface));
            border-color: color-mix(in srgb, #2b9860 34%, var(--md-sys-color-outline-variant));
        }

        .preview-chat-text .preview-rich-callout-image,
        .workspace-preview-rich .preview-rich-callout-image {
            background: color-mix(in srgb, #8a6f35 8%, var(--md-sys-color-surface));
            border-color: color-mix(in srgb, #8a6f35 30%, var(--md-sys-color-outline-variant));
        }

        .preview-chat-text .preview-rich-ref-url,
        .workspace-preview-rich .preview-rich-ref-url {
            display: block;
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
            font-size: 11px;
            color: var(--md-sys-color-on-surface-variant);
            word-break: break-all;
            white-space: pre-wrap;
        }

        .preview-chat-text .preview-rich-empty,
        .workspace-preview-rich .preview-rich-empty {
            opacity: 0.72;
            font-size: 11px;
        }

        .preview-chat-text .preview-rich-image-figure,
        .workspace-preview-rich .preview-rich-image-figure {
            margin: 8px 0;
        }

        .preview-chat-text .preview-rich-image-caption,
        .workspace-preview-rich .preview-rich-image-caption {
            margin-top: 4px;
            font-size: 11px;
            color: var(--md-sys-color-on-surface-variant);
            word-break: break-word;
        }

        .preview-chat-text .preview-rich-section-gap,
        .workspace-preview-rich .preview-rich-section-gap {
            height: 8px;
        }

        .preview-chat-text .preview-rich-process-card,
        .workspace-preview-rich .preview-rich-process-card {
            margin: 8px 0;
            border: 1px solid color-mix(in srgb, #6f7dc2 34%, var(--md-sys-color-outline-variant));
            border-radius: 12px;
            background: color-mix(in srgb, #6f7dc2 8%, var(--md-sys-color-surface));
            overflow: hidden;
        }

        .preview-chat-text .preview-rich-process-summary,
        .workspace-preview-rich .preview-rich-process-summary {
            list-style: none;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            cursor: pointer;
            user-select: none;
            border-bottom: 1px dashed color-mix(in srgb, #6f7dc2 26%, var(--md-sys-color-outline-variant));
        }

        .preview-chat-text .preview-rich-process-summary::-webkit-details-marker,
        .workspace-preview-rich .preview-rich-process-summary::-webkit-details-marker {
            display: none;
        }

        .preview-chat-text .preview-rich-process-summary-icon,
        .workspace-preview-rich .preview-rich-process-summary-icon {
            width: 18px;
            height: 18px;
            border-radius: 999px;
            border: 1px solid color-mix(in srgb, #6f7dc2 42%, var(--md-sys-color-outline-variant));
            background: color-mix(in srgb, #6f7dc2 14%, var(--md-sys-color-surface));
            color: #6f7dc2;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            line-height: 1;
            flex-shrink: 0;
        }

        .preview-chat-text .preview-rich-process-summary-title,
        .workspace-preview-rich .preview-rich-process-summary-title {
            font-size: 12px;
            font-weight: 700;
            color: var(--md-sys-color-on-surface);
        }

        .preview-chat-text .preview-rich-process-summary-meta,
        .workspace-preview-rich .preview-rich-process-summary-meta {
            margin-left: auto;
            font-size: 11px;
            color: var(--md-sys-color-on-surface-variant);
            white-space: nowrap;
        }

        .preview-chat-text .preview-rich-process-body,
        .workspace-preview-rich .preview-rich-process-body {
            padding: 10px 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .preview-chat-text .preview-rich-process-step,
        .workspace-preview-rich .preview-rich-process-step {
            border: none;
            border-left: 2px solid var(--md-sys-color-outline);
            border-radius: 0;
            background: transparent;
            padding-left: 10px;
        }

        .preview-chat-text .preview-rich-process-step-head,
        .workspace-preview-rich .preview-rich-process-step-head {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 2px 0;
            font-size: 12px;
            font-weight: 600;
            color: var(--md-sys-color-on-surface);
        }

        .preview-chat-text .preview-rich-process-step-icon,
        .workspace-preview-rich .preview-rich-process-step-icon {
            width: 16px;
            height: 16px;
            border-radius: 999px;
            border: 1px solid var(--md-sys-color-outline-variant);
            background: var(--md-sys-color-surface-container);
            color: var(--md-sys-color-on-surface-variant);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            line-height: 1;
            flex-shrink: 0;
        }

        .preview-chat-text .preview-rich-process-step-title,
        .workspace-preview-rich .preview-rich-process-step-title {
            min-width: 0;
            word-break: break-word;
        }

        .preview-chat-text .preview-rich-process-step-body,
        .workspace-preview-rich .preview-rich-process-step-body {
            padding: 4px 0 0 0;
            font-size: 12px;
            line-height: 1.6;
            color: var(--md-sys-color-on-surface);
            word-break: break-word;
            overflow-wrap: anywhere;
        }

        .preview-chat-text .preview-rich-process-thinking-body,
        .workspace-preview-rich .preview-rich-process-thinking-body {
            font-size: 12px;
            line-height: 1.65;
            color: var(--md-sys-color-on-surface);
            word-break: break-word;
            overflow-wrap: anywhere;
        }

        .preview-chat-text .preview-rich-process-step.kind-reasoning,
        .workspace-preview-rich .preview-rich-process-step.kind-reasoning {
            border-color: color-mix(in srgb, #6f7dc2 34%, var(--md-sys-color-outline-variant));
            background: color-mix(in srgb, #6f7dc2 6%, var(--md-sys-color-surface));
        }

        .preview-chat-text .preview-rich-process-step.kind-tool-call,
        .workspace-preview-rich .preview-rich-process-step.kind-tool-call {
            border-color: color-mix(in srgb, #2f7fbf 34%, var(--md-sys-color-outline-variant));
            background: color-mix(in srgb, #2f7fbf 7%, var(--md-sys-color-surface));
        }

        .preview-chat-text .preview-rich-process-step.kind-tool-result,
        .workspace-preview-rich .preview-rich-process-step.kind-tool-result {
            border-color: color-mix(in srgb, #2b9860 34%, var(--md-sys-color-outline-variant));
            background: color-mix(in srgb, #2b9860 7%, var(--md-sys-color-surface));
        }

        .preview-message-action-btn {
            padding: 4px 8px;
            font-size: 11px;
            background: transparent;
            color: var(--md-sys-color-on-surface-variant);
            border: 1px solid var(--md-sys-color-outline);
            border-radius: var(--md-sys-shape-corner-small);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .preview-message-action-btn:hover {
            background: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            border-color: var(--md-sys-color-primary);
        }

        /* 操作按钮 */
        .preview-actions {
            display: flex;
            gap: var(--md-sys-spacing-md);
            justify-content: flex-end;
            padding-top: var(--md-sys-spacing-lg);
            border-top: 2px solid var(--md-sys-color-outline);
            margin-top: var(--md-sys-spacing-md);
            background: var(--md-sys-color-surface);
        }

        @media (max-width: 900px) {
            .preview-edit-modal {
                width: 96%;
                max-height: 95vh;
            }

            .preview-modal-body {
                max-height: calc(95vh - 76px);
            }

            .preview-messages-list {
                min-height: 44vh;
                max-height: 56vh;
            }

            .preview-messages-toolbar {
                flex-wrap: wrap;
            }

            .preview-actions {
                flex-wrap: wrap;
                gap: var(--md-sys-spacing-sm);
                justify-content: stretch;
            }

            .preview-actions > button {
                flex: 1 1 140px;
            }
        }

        @media (max-width: 640px) {
            .form-row {
                grid-template-columns: 1fr;
            }

            .preview-section {
                padding: var(--md-sys-spacing-sm);
            }

            .preview-message-item {
                padding: var(--md-sys-spacing-sm);
            }
        }

        /* 消息编辑对话框 */
        .message-edit-modal {
            max-width: 600px;
            width: 90%;
        }

        .message-content-textarea {
            width: 100%;
            min-height: 200px;
            max-height: 400px;
            padding: var(--md-sys-spacing-md);
            border: 2px solid var(--md-sys-color-outline);
            border-radius: var(--md-sys-shape-corner-medium);
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: vertical;
            background: var(--md-sys-color-surface-container-low);
            color: var(--md-sys-color-on-surface);
            transition: all 0.2s ease;
        }

        .message-content-textarea:focus {
            outline: none;
            border-color: var(--md-sys-color-primary);
            box-shadow: 0 0 0 3px rgba(142, 73, 85, 0.1);
        }

        .file-info {
            margin-top: var(--md-sys-spacing-sm);
            color: var(--md-sys-color-on-surface);
            font-weight: 500;
            font-size: 14px;
        }

        .upload-box.has-file .file-info {
            color: #1B5E20;
        }

        input[type="file"] {
            display: none;
        }

        /* 合并按钮 - 增强 Material Design 3 风格 */
        .merge-button {
            width: 100%;
            padding: var(--md-sys-spacing-lg);
            background: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            border: none;
            border-radius: var(--md-sys-shape-corner-full);
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin-top: var(--md-sys-spacing-lg);
            font-family: var(--md-sys-font-family);
            box-shadow: 0 2px 8px rgba(142, 73, 85, 0.3);
            position: relative;
            overflow: hidden;
        }

        .merge-button::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s ease, height 0.6s ease, opacity 0.6s ease;
        }

        .merge-button:hover:not(:disabled) {
            box-shadow: 0 4px 16px rgba(142, 73, 85, 0.4);
            transform: translateY(-2px);
        }

        .merge-button:hover:not(:disabled)::after {
            width: 300px;
            height: 300px;
            opacity: 0;
        }

        .merge-button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(142, 73, 85, 0.3);
        }

        .merge-button:disabled {
            background: var(--md-sys-color-on-surface-variant);
            cursor: not-allowed;
            opacity: 0.6;
            box-shadow: none;
        }

        .merge-button .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: var(--md-sys-spacing-sm);
            vertical-align: middle;
        }

        /* 合并按钮中的波浪加载 */
        .merge-button .circular-wavy-loading {
            display: inline-block;
            vertical-align: middle;
            margin-right: var(--md-sys-spacing-sm);
        }

        .merge-button .circular-wavy-loading .wave {
            border-top-color: var(--md-sys-color-on-primary);
        }

        /* Material Design 3 旋转加载动画 (参考 RikkaHub CircularProgressIndicator) */
        .circular-loading {
            position: relative;
            width: 20px;
            height: 20px;
            display: inline-block;
            vertical-align: middle;
        }

        .circular-loading::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 2px solid var(--md-sys-color-on-surface-variant);
            border-right-color: transparent;
            opacity: 0.2;
        }

        .circular-loading::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 2px solid var(--md-sys-color-primary);
            border-right-color: transparent;
            border-bottom-color: transparent;
            animation: circularSpin 1s cubic-bezier(0.4, 0, 0.2, 1) infinite;
        }

        @keyframes circularSpin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        /* 波浪形进度指示器 (参考 RikkaHub CircularWavyProgressIndicator) */
        .circular-wavy-loading {
            position: relative;
            width: 20px;
            height: 20px;
            display: inline-block;
            vertical-align: middle;
        }

        .circular-wavy-loading .wave {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 2px solid transparent;
            border-top-color: var(--md-sys-color-primary);
            animation: waveSpin 1.2s cubic-bezier(0.4, 0, 0.2, 1) infinite;
        }

        .circular-wavy-loading .wave:nth-child(2) {
            animation-delay: 0.15s;
        }

        .circular-wavy-loading .wave:nth-child(3) {
            animation-delay: 0.3s;
        }

        .circular-wavy-loading .wave:nth-child(4) {
            animation-delay: 0.45s;
        }

        .circular-wavy-loading .wave:nth-child(5) {
            animation-delay: 0.6s;
        }

        @keyframes waveSpin {
            0% {
                transform: rotate(0deg) scale(1);
            }
            50% {
                transform: rotate(180deg) scale(0.6);
            }
            100% {
                transform: rotate(360deg) scale(1);
            }
        }

        /* 上传框加载状态 */
        .upload-box.loading {
            border-color: var(--md-sys-color-primary);
            background: var(--md-sys-color-surface-container);
            position: relative;
        }

        .upload-box.loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
        }

        .upload-box.loading.has-wave::after {
            content: '';
            display: inline-block;
        }

        .upload-box.loading.has-wave::after {
            background: none;
        }

        .upload-box.loading.has-wave::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
        }

        .upload-box.loading.has-wave::before {
            content: '';
            display: none;
        }

        /* Grid Loading 动画 (参考 RikkaHub) */
        .grid-loading {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            width: 20px;
            height: 20px;
        }

        .grid-cell {
            width: 100%;
            height: 100%;
            border-radius: 2px;
            background: var(--md-sys-color-surface-container-low);
            transition: background 0.3s ease;
        }

        .grid-cell.active {
            background: var(--md-sys-color-primary);
        }

        .grid-cell:nth-child(1) { animation: gridPulse 1.2s ease-in-out infinite; animation-delay: 0s; }
        .grid-cell:nth-child(2) { animation: gridPulse 1.2s ease-in-out infinite; animation-delay: 0.15s; }
        .grid-cell:nth-child(3) { animation: gridPulse 1.2s ease-in-out infinite; animation-delay: 0.3s; }
        .grid-cell:nth-child(4) { animation: gridPulse 1.2s ease-in-out infinite; animation-delay: 0.45s; }
        .grid-cell:nth-child(5) { animation: gridPulse 1.2s ease-in-out infinite; animation-delay: 0.6s; }
        .grid-cell:nth-child(6) { animation: gridPulse 1.2s ease-in-out infinite; animation-delay: 0.75s; }
        .grid-cell:nth-child(7) { animation: gridPulse 1.2s ease-in-out infinite; animation-delay: 0.9s; }
        .grid-cell:nth-child(8) { animation: gridPulse 1.2s ease-in-out infinite; animation-delay: 1.05s; }
        .grid-cell:nth-child(9) { animation: gridPulse 1.2s ease-in-out infinite; animation-delay: 1.2s; }

        @keyframes gridPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Toast 提示组件 */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 12px;
            pointer-events: none;
        }

        .toast {
            pointer-events: auto;
            min-width: 300px;
            max-width: 420px;
            background: var(--md-sys-color-surface);
            border-radius: var(--md-sys-shape-corner-large);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15), 0 0 0 1px var(--md-sys-color-outline-variant);
            padding: 16px 20px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            animation: toastSlideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .toast.success {
            border-left: 4px solid var(--md-sys-color-primary);
        }

        .toast.error {
            border-left: 4px solid var(--md-sys-color-error);
        }

        .toast.info {
            border-left: 4px solid var(--md-sys-color-primary);
        }

        .toast.hiding {
            opacity: 0;
            transform: translateX(100%);
        }

        @keyframes toastSlideIn {
            from {
                opacity: 0;
                transform: translateX(100%);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .toast-icon {
            font-size: 20px;
            line-height: 1;
            flex-shrink: 0;
        }

        .toast-content {
            flex: 1;
            min-width: 0;
        }

        .toast-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--md-sys-color-on-surface);
            margin-bottom: 4px;
        }

        .toast-message {
            font-size: 13px;
            color: var(--md-sys-color-on-surface-variant);
            line-height: 1.5;
            word-wrap: break-word;
        }

        .toast-close {
            flex-shrink: 0;
            background: none;
            border: none;
            color: var(--md-sys-color-on-surface-variant);
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .toast-close:hover {
            background: var(--md-sys-color-surface-container-high);
            color: var(--md-sys-color-on-surface);
        }

        /* 进度条 */
        .progress-bar {
            width: 100%;
            height: 6px;
            background: var(--md-sys-color-surface-container-high);
            border-radius: 3px;
            overflow: hidden;
            margin-top: var(--md-sys-spacing-md);
            display: none;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: var(--md-sys-color-primary);
            width: 0%;
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        /* 进度条波浪动画 */
        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.3) 50%,
                transparent 100%
            );
            transform: translateX(-100%);
            animation: progressWave 1.5s infinite;
        }

        @keyframes progressWave {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(100%);
            }
        }

        /* 网格加载动画 - 参考 RikkaHub LoadingBlock */
        .grid-loading-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: var(--md-sys-spacing-md);
        }

        .grid-loading {
            display: grid;
            grid-template-columns: repeat(3, 6px);
            grid-template-rows: repeat(3, 6px);
            gap: 4px;
        }

        .grid-cell {
            width: 6px;
            height: 6px;
            border-radius: 1px;
            background: var(--md-sys-color-surface-container-high);
            transition: background 0.3s ease, transform 0.3s ease;
        }

        .grid-cell.active {
            background: var(--md-sys-color-primary);
            transform: scale(1.1);
        }

        /* 网格动画 - 对角线模式 */
        .grid-loading.animating .grid-cell:nth-child(1) { animation: gridPulse 0.9s infinite 0s; }
        .grid-loading.animating .grid-cell:nth-child(2) { animation: gridPulse 0.9s infinite 0.1s; }
        .grid-loading.animating .grid-cell:nth-child(3) { animation: gridPulse 0.9s infinite 0.2s; }
        .grid-loading.animating .grid-cell:nth-child(4) { animation: gridPulse 0.9s infinite 0.3s; }
        .grid-loading.animating .grid-cell:nth-child(5) { animation: gridPulse 0.9s infinite 0.4s; }
        .grid-loading.animating .grid-cell:nth-child(6) { animation: gridPulse 0.9s infinite 0.3s; }
        .grid-loading.animating .grid-cell:nth-child(7) { animation: gridPulse 0.9s infinite 0.2s; }
        .grid-loading.animating .grid-cell:nth-child(8) { animation: gridPulse 0.9s infinite 0.1s; }
        .grid-loading.animating .grid-cell:nth-child(9) { animation: gridPulse 0.9s infinite 0s; }

        @keyframes gridPulse {
            0%, 100% {
                background: var(--md-sys-color-surface-container-high);
                transform: scale(1);
            }
            50% {
                background: var(--md-sys-color-primary);
                transform: scale(1.1);
            }
        }

        /* 状态提示 - 参考 RikkaHub ErrorCard 设计 */
        .status {
            margin-top: var(--md-sys-spacing-md);
            padding: var(--md-sys-spacing-md) var(--md-sys-spacing-lg);
            border-radius: var(--md-sys-shape-corner-medium);
            font-size: 14px;
            display: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            animation: statusSlideIn 0.3s ease;
        }

        .status.success {
            background: var(--md-sys-color-tertiary-container);
            color: var(--md-sys-color-on-tertiary-container);
            border-left: 4px solid var(--md-sys-color-tertiary);
        }

        .status.error {
            background: var(--md-sys-color-error-container);
            color: var(--md-sys-color-on-error-container);
            border-left: 4px solid var(--md-sys-color-error);
        }

        .status.info {
            background: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            border-left: 4px solid var(--md-sys-color-primary);
        }

        @keyframes statusSlideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Tag 状态指示器 - 参考 RikkaHub Tag.kt */
        .tag {
            display: inline-flex;
            align-items: center;
            padding: 2px 8px;
            border-radius: 9999px;
            font-size: 12px;
            font-weight: 500;
            margin-top: var(--md-sys-spacing-sm);
        }

        .tag.success {
            background: #C8E6C9;
            color: #1B5E20;
        }

        .tag.error {
            background: #FFCDD2;
            color: #B71C1C;
        }

        .tag.warning {
            background: #FFE0B2;
            color: #E65100;
        }

        .tag.info {
            background: #BBDEFB;
            color: #0D47A1;
        }

/* 弹窗组件 */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: var(--md-sys-spacing-xl);
            backdrop-filter: blur(4px);  /* 毛玻璃效果 */
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--md-sys-color-surface);
            border-radius: 24px;
            max-width: 700px;
            width: 100%;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(20px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--md-sys-color-outline-variant);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--md-sys-color-on-surface);
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            color: var(--md-sys-color-on-surface-variant);
            cursor: pointer;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .modal-close:hover {
            background: var(--md-sys-color-surface-container-high);
            color: var(--md-sys-color-error);
            transform: rotate(90deg);
        }

        .modal-close:active {
            transform: rotate(90deg) scale(0.9);
        }

        .modal-body {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
            /* 隐藏滚动条但保持滚动功能 */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE 10+ */
        }

        .modal-body::-webkit-scrollbar {
            display: none; /* Chrome/Safari/Edge */
        }

        .merge-report-block {
            margin: 0 0 14px 0;
            padding: 12px;
            border: 1px solid var(--md-sys-color-outline-variant);
            border-radius: var(--md-sys-shape-corner-medium);
            background: var(--md-sys-color-surface-container-low);
        }

        .merge-report-title {
            margin: 0 0 8px 0;
            color: var(--md-sys-color-on-surface);
            font-size: 13px;
            font-weight: 600;
            line-height: 1.5;
        }

        .merge-report-list {
            margin: 0 0 0 18px;
            color: var(--md-sys-color-on-surface-variant);
            font-size: 13px;
            line-height: 1.7;
        }

        .merge-report-list li {
            margin-bottom: 4px;
        }

        /* 支持列表样式 */
        .support-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            padding: 8px;
        }

        .support-card {
            border-radius: 16px;
            padding: 20px;
            color: white;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .support-success {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
        }

        .support-error {
            background: linear-gradient(135deg, #F44336 0%, #da3c31 100%);
        }

        .support-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
        }

        .support-icon {
            font-size: 20px;
            line-height: 1;
        }

        .support-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: white;
        }

        .support-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .support-list li {
            position: relative;
            padding-left: 16px;
            margin-bottom: 10px;
            font-size: 14px;
            line-height: 1.5;
            color: white;
            opacity: 0.95;
        }

        .support-list li::before {
            content: '•';
            position: absolute;
            left: 0;
            color: rgba(255, 255, 255, 0.8);
            font-weight: bold;
        }

        @media (max-width: 600px) {
            .support-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }

            .support-card {
                padding: 16px;
            }

            .support-list li {
                font-size: 13px;
                margin-bottom: 8px;
            }
        }

        /* 会话工作台 */
        .workspace-card {
            background: var(--md-sys-color-surface-container-high);
        }

        .workspace-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 12px;
        }

        .workspace-header h3 {
            margin: 0;
            font-size: 16px;
            color: var(--md-sys-color-on-surface);
        }

        .workspace-meta {
            font-size: 12px;
            color: var(--md-sys-color-on-surface-variant);
            white-space: nowrap;
        }

        .workspace-toolbar {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 12px;
        }

        .workspace-search {
            flex: 1;
            min-width: 200px;
            padding: 10px 12px;
            border: 1px solid var(--md-sys-color-outline-variant);
            border-radius: var(--md-sys-shape-corner-medium);
            background: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            font-family: var(--md-sys-font-family);
            font-size: 14px;
        }

        .workspace-search:focus {
            outline: none;
            border-color: var(--md-sys-color-primary);
        }

        .workspace-list {
            max-height: 340px;
            overflow-y: auto;
            border: 1px solid var(--md-sys-color-outline-variant);
            border-radius: var(--md-sys-shape-corner-medium);
            background: var(--md-sys-color-surface);
        }

        .workspace-row {
            display: grid;
            grid-template-columns: auto 1fr auto auto;
            gap: 10px;
            align-items: center;
            padding: 10px 12px;
            border-bottom: none;
        }

        .workspace-item {
            border-bottom: 1px solid var(--md-sys-color-outline-variant);
        }

        .workspace-item:last-child {
            border-bottom: none;
        }

        .workspace-row:last-child {
            border-bottom: none;
        }

        .workspace-row:hover {
            background: var(--md-sys-color-surface-container-high);
        }

        .workspace-row-main {
            min-width: 0;
        }

        .workspace-row-title {
            font-size: 14px;
            color: var(--md-sys-color-on-surface);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .workspace-row-sub {
            font-size: 12px;
            color: var(--md-sys-color-on-surface-variant);
            margin-top: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .workspace-badge {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 999px;
            background: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            white-space: nowrap;
        }

        .workspace-action-btn {
            padding: 6px 10px;
            border: 1px solid var(--md-sys-color-outline-variant);
            border-radius: var(--md-sys-shape-corner-small);
            background: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .workspace-action-btn:hover {
            border-color: var(--md-sys-color-primary);
            color: var(--md-sys-color-primary);
            background: var(--md-sys-color-primary-container);
        }

        .workspace-empty {
            padding: 24px 12px;
            text-align: center;
            color: var(--md-sys-color-on-surface-variant);
            font-size: 13px;
        }

        .workspace-preview-overlay {
            z-index: 1080;
        }

        .workspace-preview-modal {
            max-width: 960px;
            width: 96%;
            max-height: 92vh;
        }

        .workspace-preview-modal .modal-body {
            padding: 16px 18px 20px;
        }

        .workspace-preview-toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .workspace-preview-title {
            font-size: 12px;
            color: var(--md-sys-color-on-surface-variant);
        }

        .workspace-preview-chat {
            max-height: min(68vh, 720px);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border: 1px solid var(--md-sys-color-outline-variant);
            border-radius: var(--md-sys-shape-corner-medium);
            padding: 12px;
            background: var(--md-sys-color-surface-container-high);
        }

        .workspace-preview-message {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .workspace-preview-message.user {
            justify-content: flex-end;
            flex-direction: row-reverse;
        }

        .workspace-preview-message.assistant,
        .workspace-preview-message.system,
        .workspace-preview-message.tool {
            justify-content: flex-start;
        }

        .workspace-preview-avatar {
            width: 28px;
            height: 28px;
            border-radius: 999px;
            border: 1px solid var(--md-sys-color-outline-variant);
            background: var(--md-sys-color-surface-container);
            color: var(--md-sys-color-on-surface-variant);
            font-size: 11px;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            user-select: none;
        }

        .workspace-preview-message.user .workspace-preview-avatar {
            border-color: color-mix(in srgb, var(--md-sys-color-primary) 28%, var(--md-sys-color-outline-variant));
            background: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
        }

        .workspace-preview-message.system .workspace-preview-avatar {
            border-color: color-mix(in srgb, #8e62d9 32%, var(--md-sys-color-outline-variant));
            background: color-mix(in srgb, #8e62d9 18%, var(--md-sys-color-surface));
            color: #8e62d9;
        }

        .workspace-preview-message.tool .workspace-preview-avatar {
            border-color: color-mix(in srgb, #1c9cb4 32%, var(--md-sys-color-outline-variant));
            background: color-mix(in srgb, #1c9cb4 14%, var(--md-sys-color-surface));
            color: #1c9cb4;
        }

        .workspace-preview-content {
            min-width: 0;
            width: min(82%, 660px);
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .workspace-preview-message.user .workspace-preview-content {
            align-items: flex-end;
        }

        .workspace-preview-head {
            display: flex;
            align-items: center;
            gap: 8px;
            min-height: 18px;
        }

        .workspace-preview-message.user .workspace-preview-head {
            justify-content: flex-end;
        }

        .workspace-preview-role {
            font-size: 11px;
            font-weight: 600;
            color: var(--md-sys-color-on-surface-variant);
        }

        .workspace-preview-time {
            font-size: 10px;
            color: var(--md-sys-color-on-surface-variant);
            opacity: 0.86;
            white-space: nowrap;
        }

        .workspace-preview-bubble {
            width: 100%;
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid var(--md-sys-color-outline-variant);
            font-size: 12px;
            line-height: 1.5;
            background: var(--md-sys-color-surface);
            overflow: visible;
        }

        .workspace-preview-message.user .workspace-preview-bubble {
            background: color-mix(in srgb, var(--md-sys-color-primary-container) 40%, var(--md-sys-color-surface));
            border-color: color-mix(in srgb, var(--md-sys-color-primary) 24%, var(--md-sys-color-outline-variant));
        }

        .workspace-preview-message.system .workspace-preview-bubble {
            border-style: dashed;
            background: color-mix(in srgb, #8e62d9 6%, var(--md-sys-color-surface));
        }

        .workspace-preview-message.tool .workspace-preview-bubble {
            border-style: dashed;
            background: color-mix(in srgb, #1c9cb4 8%, var(--md-sys-color-surface));
        }

        .workspace-preview-rich {
            color: var(--md-sys-color-on-surface);
            word-break: break-word;
            overflow-wrap: anywhere;
            line-height: 1.5;
            max-height: none;
            overflow: visible;
        }

        .workspace-preview-rich pre {
            margin: 6px 0;
            padding: 8px 10px;
            border-radius: 8px;
            background: var(--md-sys-color-surface-container-high);
            overflow-x: auto;
            font-size: 12px;
        }

        .workspace-preview-rich blockquote {
            margin: 6px 0;
            padding: 4px 0 4px 10px;
            border-left: 3px solid var(--md-sys-color-outline);
            color: var(--md-sys-color-on-surface-variant);
        }

        .workspace-preview-rich img {
            max-width: min(220px, 100%);
            max-height: min(320px, 56vh);
            border-radius: 8px;
            border: 1px solid var(--md-sys-color-outline-variant);
            display: block;
            margin: 6px 0;
            object-fit: contain;
        }

        .workspace-preview-rich a {
            color: var(--md-sys-color-primary);
            text-decoration: underline;
            word-break: break-all;
        }

        .workspace-preview-empty {
            padding: 26px 12px;
            text-align: center;
            color: var(--md-sys-color-on-surface-variant);
            font-size: 13px;
        }

        .merge-options-card {
            background: var(--md-sys-color-surface-container-high);
        }

        .merge-options-row {
            display: grid;
            grid-template-columns: 120px 1fr;
            gap: 12px;
            align-items: center;
        }

        .merge-options-label {
            font-size: 13px;
            color: var(--md-sys-color-on-surface);
            font-weight: 600;
        }

        .merge-options-hint {
            margin-top: 8px;
            font-size: 12px;
            color: var(--md-sys-color-on-surface-variant);
            line-height: 1.5;
        }

        .target-backup-card {
            background: var(--md-sys-color-surface-container-high);
        }

        .target-backup-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 8px;
        }

        .target-backup-head h3 {
            margin: 0;
            font-size: 16px;
            color: var(--md-sys-color-on-surface);
        }

        .merge-option-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .merge-option-tag {
            border: 1px solid var(--md-sys-color-outline);
            background: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            border-radius: var(--md-sys-shape-corner-full);
            padding: 8px 12px;
            font-family: var(--md-sys-font-family);
            font-size: 13px;
            line-height: 1.3;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .merge-option-tag:hover {
            border-color: var(--md-sys-color-primary);
            background: var(--md-sys-color-surface-container-high);
        }

        .merge-option-tag.selected {
            border-color: var(--md-sys-color-primary-container);
            background: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            font-weight: 600;
        }

        .workspace-edit-modal {
            max-width: 560px;
            width: 92%;
        }

        @media (max-width: 600px) {
            .merge-options-row {
                grid-template-columns: 1fr;
                gap: 8px;
            }

            .workspace-preview-overlay {
                padding: 0;
                align-items: stretch;
            }

            .workspace-preview-modal {
                width: 100%;
                max-width: none;
                height: 100vh;
                max-height: 100vh;
                border-radius: 0;
            }

            .workspace-preview-modal .modal-header {
                padding: 14px 16px;
            }

            .workspace-preview-modal .modal-title {
                font-size: 16px;
            }

            .workspace-preview-modal .modal-body {
                padding: 10px 12px 14px;
            }

            .workspace-preview-chat {
                max-height: calc(100vh - 180px);
                padding: 10px;
                gap: 8px;
            }

            .workspace-preview-message {
                gap: 8px;
            }

            .workspace-preview-avatar {
                width: 24px;
                height: 24px;
                font-size: 10px;
            }

            .workspace-preview-content {
                width: min(93%, 620px);
            }

            .workspace-preview-bubble {
                font-size: 12px;
                padding: 9px 10px;
            }
        }

        /* 关于页面 */
        .about-info {
            background: var(--md-sys-color-surface-container);
            padding: var(--md-sys-spacing-lg);
            border-radius: var(--md-sys-shape-corner-medium);
            margin: var(--md-sys-spacing-md) 0;
        }

        .about-info p {
            margin: var(--md-sys-spacing-sm) 0;
            line-height: 1.6;
        }

        .about-info strong {
            color: var(--md-sys-color-primary);
        }

        .about-link {
            color: var(--md-sys-color-primary);
            text-decoration: none;
            font-weight: 500;
        }

        .about-link:hover {
            text-decoration: underline;
        }

        .disclaimer {
            font-size: 12px;
            color: var(--md-sys-color-on-surface-variant);
            margin-top: var(--md-sys-spacing-lg);
            padding-top: var(--md-sys-spacing-lg);
            border-top: 1px solid var(--md-sys-color-outline-variant);
        }

        /* 主题选择样式 */
        .theme-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
            margin-top: 8px;
        }

        @media (max-width: 480px) {
            .theme-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        .theme-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px 8px;
            background: var(--md-sys-color-surface-container-high);
            border-radius: var(--md-sys-shape-corner-medium);
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
        }

        .theme-card:hover {
            background: var(--md-sys-color-surface-container);
            transform: translateY(-2px);
        }

        .theme-card.active {
            border-color: var(--md-sys-color-primary);
            background: var(--md-sys-color-primary-container);
        }

        .theme-preview {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 8px;
        }

        .theme-card span {
            font-size: 12px;
            color: var(--md-sys-color-on-surface);
        }

        /* 触摸设备与焦点交互优化 */
        :where(
            button,
            .btn-text,
            .paste-btn,
            .toolbar-btn,
            .workspace-action-btn,
            .merge-option-tag,
            .custom-select,
            .select-option,
            .upload-box,
            .merge-button,
            .tab-btn,
            .theme-card,
            .modal-close,
            .toast-close,
            input,
            textarea,
            select,
            a
        ) {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        :where(
            button,
            .btn-text,
            .paste-btn,
            .toolbar-btn,
            .workspace-action-btn,
            .merge-option-tag,
            .custom-select,
            .upload-box,
            .merge-button,
            .tab-btn,
            .theme-card,
            .modal-close,
            .toast-close,
            input,
            textarea,
            select,
            a
        ):focus {
            outline: none;
        }

        :where(
            button,
            .btn-text,
            .paste-btn,
            .toolbar-btn,
            .workspace-action-btn,
            .merge-option-tag,
            .custom-select,
            .upload-box,
            .merge-button,
            .tab-btn,
            .theme-card,
            .modal-close,
            .toast-close,
            input,
            textarea,
            select,
            a
        ):focus-visible {
            outline: 2px solid var(--md-sys-color-primary);
            outline-offset: 2px;
        }

        @media (hover: none), (pointer: coarse) {
            .upload-card:hover,
            .tab-btn:hover,
            .btn-text:hover,
            .custom-select:hover,
            .select-option:hover,
            .upload-box:hover,
            .paste-btn:hover,
            .toolbar-btn:hover,
            .workspace-row:hover,
            .workspace-action-btn:hover,
            .merge-option-tag:hover,
            .theme-card:hover,
            .toast-close:hover,
            .modal-close:hover,
            .merge-button:hover:not(:disabled) {
                transform: none !important;
                box-shadow: none !important;
            }

            .btn-text:hover {
                background: none !important;
            }

            .btn-text:hover::before {
                width: 0 !important;
                height: 0 !important;
            }

            .custom-select:hover {
                border-color: var(--md-sys-color-outline) !important;
                background: var(--md-sys-color-surface) !important;
            }

            .select-option:hover {
                background: transparent !important;
            }

            .upload-box:hover {
                border-color: var(--md-sys-color-outline) !important;
                background: var(--md-sys-color-surface) !important;
            }

            .upload-box:hover .upload-icon {
                transform: none !important;
            }

            .paste-btn:hover {
                background: var(--md-sys-color-secondary-container) !important;
                color: var(--md-sys-color-on-secondary-container) !important;
                border-color: var(--md-sys-color-outline) !important;
            }

            .toolbar-btn:hover {
                background: var(--md-sys-color-secondary-container) !important;
                color: var(--md-sys-color-on-secondary-container) !important;
                border-color: var(--md-sys-color-outline) !important;
            }

            .workspace-row:hover {
                background: var(--md-sys-color-surface) !important;
            }

            .workspace-action-btn:hover {
                border-color: var(--md-sys-color-outline-variant) !important;
                color: var(--md-sys-color-on-surface) !important;
                background: var(--md-sys-color-surface) !important;
            }

            .theme-card:hover {
                background: var(--md-sys-color-surface-container-high) !important;
            }

            .merge-button:hover:not(:disabled)::after {
                width: 0 !important;
                height: 0 !important;
                opacity: 1 !important;
            }

            .btn-text:active,
            .paste-btn:active,
            .toolbar-btn:active,
            .workspace-action-btn:active,
            .merge-option-tag:active,
            .merge-button:active:not(:disabled),
            .custom-select:active,
            .upload-box:active,
            .tab-btn:active,
            .theme-card:active,
            .modal-close:active {
                transform: scale(0.98);
                transition: transform 0.08s ease;
            }
        }
    </style>
<base target="_blank">
</head>
<body>
    <!-- Toast 容器 -->
    <div class="toast-container" id="toastContainer"></div>

    <div class="container">
        <h1>ChatWeave</h1>
        <p class="subtitle">统一聊天记录工作台（导入 / 浏览 / 编辑 / 合并）v1.6.2</p>

        <!-- 重要须知卡片 -->
        <div class="card warning-card">
            <p><strong>⚠️ 风险与备份须知</strong></p>
            <p>本工具为第三方本地转换工具，不代表 ChatGPT、DeepSeek、YourAIScroll 或 RikkaHub 官方立场。</p>
            <ul style="margin: 8px 0 0 20px; line-height: 1.8;">
                <li>务必保留：源导出文件 + RikkaHub 原始备份 ZIP（回滚基线）</li>
                <li>建议先导入 1-3 个会话做小样验证，再进行全量合并</li>
                <li>如导入后闪退或异常，可清空应用数据并回滚原始备份</li>
                <li>详细兼容范围与恢复建议见“关于”页面</li>
            </ul>
        </div>

        <!-- 按钮组 -->
        <div class="button-group">
            <button class="btn-text" onclick="openModal('usage')">📖 使用说明</button>
            <button class="btn-text" onclick="openModal('support')">📋 支持列表明细</button>
            <button class="btn-text" onclick="openModal('about')">ℹ️ 关于</button>
        </div>

        <!-- 自定义下拉框 -->
        <div class="card">
            <div class="select-wrapper" id="dataSourceWrapper">
                <div class="custom-select" onclick="toggleSelect()">
                    <span id="selectedValue">ChatGPT 数据</span>
                </div>
                <div class="select-dropdown" id="selectDropdown">
                    <div class="select-option selected" data-value="chatgpt" onclick="selectOption('chatgpt', 'ChatGPT 数据')">ChatGPT 数据</div>
                    <div class="select-option" data-value="deepseek" onclick="selectOption('deepseek', 'DeepSeek 数据（新旧两个版本）')">DeepSeek 数据（新旧两个版本）</div>
                    <div class="select-option" data-value="youraiscroll" onclick="selectOption('youraiscroll', 'YourAIScroll 数据（支持 12 个平台）')">YourAIScroll 数据（支持 12 个平台）</div>
                                </div>            </div>
        </div>

        <!-- 上传网格（双列布局） -->
        <div class="upload-grid">
            <div class="upload-card">
                <div class="step-badge">1</div>
                <h3>上传源数据</h3>
                <div class="upload-box" id="sourceUpload" onclick="document.getElementById('sourceFile').click()">
                    <div class="upload-icon">📁</div>
                    <div class="upload-text" id="sourceUploadText">点击或拖拽上传 ChatGPT 压缩包</div>
                    <div class="file-info" id="sourceFileInfo"></div>
                    <input type="file" id="sourceFile" accept=".zip,.csv" onchange="handleSourceFile(this)">
                </div>
                                <div class="paste-buttons" id="pasteButtons" style="display: none;">
                                    <button class="paste-btn" onclick="openPasteModal()">📝 粘贴 Markdown 文本</button>
                                </div>
            </div>

            <div class="upload-card" id="deepseekSecondCard" style="display: none;">
                <div class="step-badge">2</div>
                <h3>上传 DeepSeek 旧版数据</h3>
                <div class="upload-box" id="deepseekSecondUpload" onclick="document.getElementById('deepseekSecondFile').click()">
                    <div class="upload-icon">📁</div>
                    <div class="upload-text" id="deepseekSecondUploadText">点击或拖拽上传 DeepSeek 旧版压缩包（如果有的话）</div>
                    <div class="file-info" id="deepseekSecondFileInfo"></div>
                    <input type="file" id="deepseekSecondFile" accept=".zip" onchange="handleDeepSeekSecondFile(this)">
                </div>
            </div>
        </div>

        <!-- 会话工作台 -->
        <div class="card workspace-card" id="workspaceCard" style="display: none;">
            <div class="workspace-header">
                <h3>会话工作台</h3>
                <span class="workspace-meta" id="workspaceMeta">已选 0 / 0</span>
            </div>
            <div class="workspace-toolbar">
                <input
                    type="text"
                    id="workspaceSearchInput"
                    class="workspace-search"
                    placeholder="搜索会话标题或来源..."
                    oninput="renderWorkspaceList()"
                >
                <button class="btn-text" type="button" onclick="setWorkspaceSelectionState(true)">全选</button>
                <button class="btn-text" type="button" onclick="setWorkspaceSelectionState(false)">全不选</button>
                <button class="btn-text" type="button" onclick="invertWorkspaceSelection()">反选</button>
            </div>
            <div class="workspace-list" id="workspaceList"></div>
        </div>

        <div class="card target-backup-card" id="rikkahubCard">
            <div class="target-backup-head">
                <h3>目标备份（RikkaHub）</h3>
                <button class="btn-text" type="button" onclick="triggerRikkaHubFilePicker(false)">选择备份 ZIP</button>
            </div>
            <p class="merge-options-hint" style="margin-top: 0;">
                可以先导入并整理会话，再点击“合并聊天记录”时选择 RikkaHub 原始备份。你也可以现在先上传，后续会直接合并。
            </p>
            <div class="upload-box" id="rikkahubUpload" onclick="triggerRikkaHubFilePicker(false)">
                <div class="upload-icon">📁</div>
                <div class="upload-text">点击选择 RikkaHub 原始备份 ZIP</div>
                <div class="file-info" id="rikkahubFileInfo"></div>
                <input type="file" id="rikkahubFile" accept=".zip" onchange="handleRikkaHubFile(this)">
            </div>
        </div>

        <div class="card merge-options-card">
            <div class="merge-options-row">
                <label class="merge-options-label">冲突处理策略</label>
                <div class="merge-option-tags" id="duplicateStrategyTags">
                    <button type="button" class="merge-option-tag selected" data-value="skip" onclick="setDuplicateStrategy('skip')">跳过已存在会话（默认）</button>
                    <button type="button" class="merge-option-tag" data-value="keep_both" onclick="setDuplicateStrategy('keep_both')">保留并另存（自动生成新会话 ID）</button>
                </div>
                <input type="hidden" id="duplicateStrategyValue" value="skip">
            </div>
            <div class="merge-options-row" style="margin-top: 12px;">
                <label class="merge-options-label">助手合并策略</label>
                <div class="merge-option-tags" id="assistantMergeStrategyTags">
                    <button type="button" class="merge-option-tag selected" data-value="by_source" onclick="setAssistantMergeStrategy('by_source')">按来源分配助手（默认）</button>
                    <button type="button" class="merge-option-tag" data-value="single_assistant" onclick="setAssistantMergeStrategy('single_assistant')">统一到单一助手</button>
                </div>
                <input type="hidden" id="assistantMergeStrategyValue" value="by_source">
            </div>
            <div class="merge-options-row" id="unifiedAssistantNameRow" style="margin-top: 12px; display: none;">
                <label for="unifiedAssistantNameInput" class="merge-options-label">统一助手名称</label>
                <input type="text" id="unifiedAssistantNameInput" class="form-input" placeholder="留空使用默认名称 Unified Import">
            </div>
            <p class="merge-options-hint">当待导入会话与目标备份中的会话 ID 相同，会按此策略处理。建议默认使用“跳过”，更稳妥。</p>
            <p class="merge-options-hint" id="assistantMergeStrategyHint">默认按来源创建/复用导入助手，便于区分来源。</p>
        </div>

        <!-- 合并按钮 -->
        <button class="merge-button" id="mergeButton" onclick="mergeData()" disabled>
            合并聊天记录
        </button>

        <!-- 进度条 -->
        <div class="progress-bar" id="progressBar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <!-- 网格加载动画 -->
        <div class="grid-loading-container" id="gridLoading" style="display: none;">
            <div class="grid-loading">
                <div class="grid-cell" data-index="0"></div>
                <div class="grid-cell" data-index="1"></div>
                <div class="grid-cell" data-index="2"></div>
                <div class="grid-cell" data-index="3"></div>
                <div class="grid-cell" data-index="4"></div>
                <div class="grid-cell" data-index="5"></div>
                <div class="grid-cell" data-index="6"></div>
                <div class="grid-cell" data-index="7"></div>
                <div class="grid-cell" data-index="8"></div>
            </div>
        </div>

        <!-- 状态提示 -->
        <div class="status" id="status"></div>
    </div>

    <div class="modal-overlay" id="rikkahubRequiredModal" onclick="closeRikkaHubRequiredModalOnOverlay(event)">
        <div class="modal" style="max-width: 560px;">
            <div class="modal-header">
                <h3 class="modal-title">📦 选择 RikkaHub 原始备份</h3>
                <button class="modal-close" onclick="closeRikkaHubRequiredModal()">×</button>
            </div>
            <div class="modal-body">
                <p style="margin: 0 0 12px 0; color: var(--md-sys-color-on-surface); line-height: 1.6;">
                    当前已完成来源导入与会话选择。下一步请选择一个 <strong>RikkaHub 原始备份 ZIP</strong> 作为合并目标。
                </p>
                <p style="margin: 0 0 18px 0; color: var(--md-sys-color-on-surface-variant); font-size: 13px; line-height: 1.6;">
                    只会在你选择的备份副本上写入，不会修改源聊天导出文件。
                </p>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button class="btn-text" type="button" onclick="closeRikkaHubRequiredModal()" style="padding: 10px 18px; border: 1px solid var(--md-sys-color-outline);">取消</button>
                    <button class="btn-primary" type="button" onclick="triggerRikkaHubFilePicker(true)" style="padding: 10px 18px; background: var(--md-sys-color-primary); color: var(--md-sys-color-on-primary); border: none; border-radius: var(--md-sys-shape-corner-small); cursor: pointer;">选择备份并继续</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="mergeDryRunModal" onclick="closeMergeDryRunModalOnOverlay(event)">
        <div class="modal" style="max-width: 700px;">
            <div class="modal-header">
                <h3 class="modal-title">🧪 合并前预检（Dry Run）</h3>
                <button class="modal-close" onclick="closeMergeDryRunModal(false)">×</button>
            </div>
            <div class="modal-body">
                <p id="mergeDryRunSummary" style="margin: 0 0 12px 0; color: var(--md-sys-color-on-surface); line-height: 1.6;">
                    正在生成预检报告...
                </p>
                <div class="merge-report-block">
                    <p class="merge-report-title">按来源差异预估</p>
                    <ul class="merge-report-list" id="mergeDryRunDiffList">
                        <li>暂无数据</li>
                    </ul>
                </div>
                <div class="merge-report-block">
                    <p class="merge-report-title">预检警告</p>
                    <ul class="merge-report-list" id="mergeDryRunWarningList">
                        <li>暂无警告</li>
                    </ul>
                </div>
                <div class="merge-report-block" id="mergeDryRunUnknownBlock" style="display: none;">
                    <p class="merge-report-title">无法识别块详情（样例）</p>
                    <ul class="merge-report-list" id="mergeDryRunUnknownList"></ul>
                </div>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button class="btn-text" type="button" onclick="closeMergeDryRunModal(false)" style="padding: 10px 18px; border: 1px solid var(--md-sys-color-outline);">取消</button>
                    <button class="btn-primary" type="button" onclick="closeMergeDryRunModal(true)" style="padding: 10px 18px; background: var(--md-sys-color-primary); color: var(--md-sys-color-on-primary); border: none; border-radius: var(--md-sys-shape-corner-small); cursor: pointer;">继续合并</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="mergeDownloadModal" onclick="closeMergeDownloadModalOnOverlay(event)">
        <div class="modal" style="max-width: 620px;">
            <div class="modal-header">
                <h3 class="modal-title">✅ 合并完成，请确认下载</h3>
                <button class="modal-close" onclick="closeMergeDownloadModal(true)">×</button>
            </div>
            <div class="modal-body">
                <p id="mergeDownloadSummary" style="margin: 0 0 12px 0; color: var(--md-sys-color-on-surface); line-height: 1.6;">
                    合并包已准备完成。
                </p>
                <p id="mergeDownloadRiskHint" style="display: none; margin: 0 0 12px 0; color: #D97706; font-size: 13px; line-height: 1.6;"></p>
                <div class="merge-report-block" id="mergeDownloadDiffBlock" style="display: none;">
                    <p class="merge-report-title">按来源差异清单（实际执行）</p>
                    <ul class="merge-report-list" id="mergeDownloadDiffList"></ul>
                </div>
                <div class="merge-report-block" id="mergeDownloadWarningBlock" style="display: none;">
                    <p class="merge-report-title">预检警告（请重点留意）</p>
                    <ul class="merge-report-list" id="mergeDownloadWarningList"></ul>
                </div>
                <div class="merge-report-block" id="mergeDownloadUnknownBlock" style="display: none;">
                    <p class="merge-report-title">无法识别块详情（样例）</p>
                    <ul class="merge-report-list" id="mergeDownloadUnknownList"></ul>
                </div>
                <p style="margin: 0 0 8px 0; color: var(--md-sys-color-on-surface-variant); font-size: 13px; line-height: 1.6;">
                    下载前请确认以下事项：
                </p>
                <ul style="margin: 0 0 18px 20px; color: var(--md-sys-color-on-surface-variant); font-size: 13px; line-height: 1.7;">
                    <li>请保留原始导出文件与原始 RikkaHub 备份 ZIP，便于回滚</li>
                    <li>建议先用少量会话验证导入，再执行全量替换</li>
                    <li>若应用导入异常，请回滚到原始备份并重试</li>
                </ul>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button class="btn-text" type="button" onclick="closeMergeDownloadModal(true)" style="padding: 10px 18px; border: 1px solid var(--md-sys-color-outline);">取消</button>
                    <button class="btn-primary" type="button" id="mergeDownloadConfirmBtn" onclick="downloadMergedZipNow()" style="padding: 10px 18px; background: var(--md-sys-color-primary); color: var(--md-sys-color-on-primary); border: none; border-radius: var(--md-sys-shape-corner-small); cursor: pointer;">下载</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 使用说明弹窗 -->
    <div class="modal-overlay" id="modalUsage">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">📖 使用说明</h3>
                <button class="modal-close" onclick="closeModalDirect('usage')">×</button>
            </div>
            <div class="modal-body">
                <p><strong>推荐流程（统一会话工作台）</strong></p>
                <ol style="margin-left: 20px; line-height: 1.8;">
                    <li>准备至少一种源数据：ChatGPT ZIP / DeepSeek ZIP / YourAIScroll Markdown</li>
                    <li>导入到会话工作台，逐条预览并编辑</li>
                    <li>点击“合并聊天记录”，按提示选择 RikkaHub 原始备份 ZIP</li>
                    <li>下载合并包并导入 RikkaHub（建议先小批量验证）</li>
                </ol>

                <p style="margin-top: 16px;"><strong>一、准备源数据（可多选）</strong></p>
                <ol style="margin-left: 20px; line-height: 1.8;">
                    <li><strong>ChatGPT</strong>：在 <a href="https://chatgpt.com/#settings/DataControls" target="_blank">Data Controls</a> 导出全部数据，上传完整 ZIP（不要只取 conversations.json）</li>
                    <li><strong>DeepSeek</strong>：导出新版 ZIP（conversations.json），如有历史旧数据可再导出旧版 ZIP（chat.csv / coder.csv）</li>
                    <li><strong>YourAIScroll</strong>：在对话页复制 Markdown，每次粘贴一个会话（应包含 Original URL 与 [USER]/[ASSISTANT] 标记）</li>
                </ol>

                <p style="margin-top: 16px;"><strong>二、导入并整理会话</strong></p>
                <ol style="margin-left: 20px; line-height: 1.8;">
                    <li>按来源上传或粘贴后，会自动进入“会话工作台”</li>
                    <li>可在“预览和编辑会话”中修改标题、时间和消息内容，取消勾选即不参与合并</li>
                    <li>可混合导入多个来源，统一勾选后一次合并</li>
                </ol>

                <p style="margin-top: 16px;"><strong>三、执行合并</strong></p>
                <ol style="margin-left: 20px; line-height: 1.8;">
                    <li>按需选择冲突处理策略与助手合并策略</li>
                    <li>若未提前上传 RikkaHub 备份，点击“合并聊天记录”后会弹窗要求选择备份 ZIP</li>
                    <li>合并完成后会弹出确认窗口，阅读提示后再下载</li>
                </ol>

                <p style="margin-top: 16px;"><strong>四、导入回 RikkaHub</strong></p>
                <ol style="margin-left: 20px; line-height: 1.8;">
                    <li>RikkaHub → 设置 → 数据备份 → 备份文件导入</li>
                    <li>选择本工具下载的 ZIP，完成后重启应用并检查会话显示</li>
                </ol>

                <p style="margin-top: 24px; padding: 16px; background: var(--md-sys-color-primary-container); border-radius: var(--md-sys-shape-corner-medium); color: var(--md-sys-color-on-primary-container);">
                    <strong>📸 图片与链接说明</strong><br>
                    ChatGPT 导出包中的图片会迁移为 RikkaHub 本地文件；YourAIScroll Markdown 中的图片保留为原链接（不会自动下载入包）。
                </p>
                <p style="margin-top: 16px; padding: 16px; background: var(--md-sys-color-secondary-container); border-radius: var(--md-sys-shape-corner-medium); color: var(--md-sys-color-on-secondary-container);">
                    <strong>🕒 时间戳说明</strong><br>
                    YourAIScroll Markdown 通常不包含原始精确时间戳，导入时会使用粘贴时刻作为默认时间。
                </p>
            </div>
        </div>
    </div>

    <!-- 支持列表弹窗 -->
    <div class="modal-overlay" id="modalSupport">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">📋 支持列表明细</h3>
                <button class="modal-close" onclick="closeModalDirect('support')">×</button>
            </div>
            <div class="modal-body">
                <div class="support-grid">
                    <!-- 已支持 -->
                    <div class="support-card support-success">
                        <div class="support-header">
                            <span class="support-icon">✅</span>
                            <h3>已支持</h3>
                        </div>
                        <ul class="support-list">
                            <li><strong>ChatGPT 官方导出 ZIP</strong>：对话文本、图片（用户上传 + 生成图）、标题与创建/更新时间（按 v1.5 稳定口径，不单独写入 thoughts/reasoning_recap）</li>
                            <li><strong>DeepSeek 新版 ZIP（conversations.json）</strong>：REQUEST/THINK/RESPONSE 片段（含 THINK-only 节点）、标题与时间</li>
                            <li><strong>DeepSeek 旧版 ZIP（chat.csv / coder.csv）</strong>：角色、文本、消息时间与标题</li>
                            <li><strong>YourAIScroll Markdown 粘贴导入</strong>：每次一个会话，支持 URL 平台识别、角色标记、Markdown 图片/链接、常见深度思考标记</li>
                            <li><strong>YourAIScroll 工具/文档标记</strong>：支持显式语法 <code>Function: name(args)</code> 与文档链接提取（非显式格式不保证识别）</li>
                            <li><strong>统一会话工作台</strong>：多来源并存导入、会话级与消息级勾选、逐条编辑后再合并</li>
                            <li><strong>RikkaHub 兼容口径</strong>：写入 ConversationEntity + message_node（DB v12），并对 v1.9.0beta 源码 schema（DB v13）完成结构对照</li>
                        </ul>
                    </div>

                    <!-- 不支持 -->
                    <div class="support-card support-error">
                        <div class="support-header">
                            <span class="support-icon">❌</span>
                            <h3>不支持</h3>
                        </div>
                        <ul class="support-list">
                            <li>ChatGPT：账号信息（邮箱、手机号）、收藏/归档状态、插件数据、自定义助手（Gizmo）、群聊记录、消息反馈、Sora 视频、购物相关数据</li>
                            <li>DeepSeek：语音消息、文件附件</li>
                            <li>YourAIScroll：文件上传导入（仅支持粘贴 Markdown）；原始精确时间戳（Markdown 通常不含）；外链图片不会自动下载入包</li>
                            <li>所有平台：消息编辑历史、已删除消息、完整分支状态、实时会话状态、精确 token 使用量</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 关于弹窗 -->
    <div class="modal-overlay" id="modalAbout">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">ℹ️ 关于</h3>
                <button class="modal-close" onclick="closeModalDirect('about')">×</button>
            </div>
            <div class="modal-body">
                <h2 style="font-size: 24px; margin-bottom: 8px;">ChatWeave</h2>
                <p style="color: var(--md-sys-color-on-surface-variant); margin-bottom: 24px;">统一会话工作台 v1.6.2</p>
                <div class="about-info">
                    <p>ChatWeave 是一个统一聊天记录工作台：支持多来源导入、会话预览、消息编辑、勾选过滤和目标备份合并。</p>
                    <p>当前版本重点输出可导入 RikkaHub 的备份包，同时保留统一数据层，便于后续扩展更多目标平台。</p>
                </div>
                <p style="margin-top: 16px;">
                    <a href="https://rikka-ai.com/" target="_blank" class="about-link">RikkaHub 官网</a>
                </p>
                
                <h3 style="margin-top: 32px; margin-bottom: 12px; font-size: 16px;">🎨 主题选择</h3>
                
                <div style="margin-bottom: 16px;">
                    <button class="btn-text" id="darkModeToggle" onclick="toggleDarkMode()" style="padding: 8px 16px; background: var(--md-sys-color-surface-container-high);">
                        🌙 切换深色/浅色模式
                    </button>
                </div>
                
                <div class="theme-grid">
                    <div class="theme-card" data-theme="sakura" onclick="applyTheme('sakura', this)" title="樱花粉">
                        <div class="theme-preview">
                            <div style="background: #8E4955; border-radius: 50%; width: 40px; height: 40px;"></div>
                        </div>
                        <span>樱花粉</span>
                    </div>
                    <div class="theme-card active" data-theme="ocean" onclick="applyTheme('ocean', this)" title="海湾蓝">
                        <div class="theme-preview">
                            <div style="background: #116682; border-radius: 50%; width: 40px; height: 40px;"></div>
                        </div>
                        <span>海湾蓝</span>
                    </div>
                    <div class="theme-card" data-theme="spring" onclick="applyTheme('spring', this)" title="原野绿">
                        <div class="theme-preview">
                            <div style="background: #4C662B; border-radius: 50%; width: 40px; height: 40px;"></div>
                        </div>
                        <span>原野绿</span>
                    </div>
                    <div class="theme-card" data-theme="autumn" onclick="applyTheme('autumn', this)" title="秋黄">
                        <div class="theme-preview">
                            <div style="background: #735C0C; border-radius: 50%; width: 40px; height: 40px;"></div>
                        </div>
                        <span>秋黄</span>
                    </div>
                    <div class="theme-card" data-theme="black" onclick="applyTheme('black', this)" title="中性黑">
                        <div class="theme-preview">
                            <div style="background: #606060; border-radius: 50%; width: 40px; height: 40px;"></div>
                        </div>
                        <span>中性黑</span>
                    </div>
                </div>
                
                <div style="margin-top: 24px; padding: 16px; background: var(--md-sys-color-surface-container-low); border-radius: var(--md-sys-shape-corner-medium);">
                    <h4 style="margin-bottom: 8px; font-size: 14px; font-weight: 600;">📝 说明与条款</h4>
                    <p style="font-size: 13px; line-height: 1.6; color: var(--md-sys-color-on-surface-variant); margin: 0;">
                        本工具为社区项目，与 ChatGPT、DeepSeek、YourAIScroll、RikkaHub 均无官方从属关系。
                    </p>
                    <p style="font-size: 13px; line-height: 1.6; color: var(--md-sys-color-on-surface-variant); margin: 8px 0 0 0;">
                        数据转换在本地浏览器完成；请自行保管源文件与备份文件，确认可用前不要删除原始备份。
                    </p>
                    <p style="font-size: 13px; line-height: 1.6; color: var(--md-sys-color-on-surface-variant); margin: 8px 0 0 0;">
                        兼容验证基线：RikkaHub 备份数据库结构 v12（实测）与 v1.9.0beta 源码 schema v13（结构对照）。后续版本仍可能出现差异。
                    </p>
                    <p style="font-size: 13px; line-height: 1.6; color: var(--md-sys-color-on-surface-variant); margin: 8px 0 0 0;">
                        无担保声明：本工具不对导入结果作绝对保证。因使用导致的数据丢失、崩溃或其他损失，请自行承担风险。
                    </p>
                    <ul style="margin: 8px 0 0 20px; font-size: 13px; line-height: 1.7; color: var(--md-sys-color-on-surface-variant);">
                        <li>请保留原始导出 ZIP 与 RikkaHub 原始备份 ZIP，确认可用前不要删除</li>
                        <li>建议每次导入前额外复制一份 RikkaHub 备份作为回滚点</li>
                        <li>若导入后异常，请清空应用数据并重新导入原始备份</li>
                        <li>本工具并非 RikkaHub 官方支持渠道，请优先在项目社区反馈问题</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- 粘贴对话框 -->
    <div class="modal-overlay" id="pasteModal">
        <div class="modal paste-modal">
            <div class="modal-header">
                <h3 class="modal-title" id="pasteModalTitle">📋 粘贴内容</h3>
                <button class="modal-close" onclick="closePasteModal()">×</button>
            </div>
            <div class="modal-body">
                <p id="pasteModalHint" style="color: var(--md-sys-color-on-surface-variant); margin-bottom: 16px;">
                    请粘贴 YourAIScroll 复制的 Markdown 内容（每次一个对话，确认后会追加到会话工作台）：
                </p>
                <textarea id="pasteTextArea" class="paste-textarea" placeholder="在此粘贴内容..."></textarea>
                <div style="display: flex; gap: var(--md-sys-spacing-md); margin-top: var(--md-sys-spacing-lg); justify-content: flex-end;">
                    <button class="btn-text" onclick="closePasteModal()" style="padding: 10px 20px; border: 1px solid var(--md-sys-color-outline);">取消</button>
                    <button class="btn-primary" onclick="handlePaste()" style="padding: 10px 20px; background: var(--md-sys-color-primary); color: var(--md-sys-color-on-primary); border: none; border-radius: var(--md-sys-shape-corner-small); cursor: pointer;">确认</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 预览编辑对话框 -->
    <div class="modal-overlay" id="previewEditModal">
        <div class="modal preview-edit-modal">
            <div class="modal-header">
                <h3 class="modal-title">📝 预览和编辑会话</h3>
                <button class="modal-close" onclick="closePreviewEditModal()">×</button>
            </div>
            <div class="modal-body preview-modal-body">
                <p class="preview-intro" id="previewEditIntro">你只需要做两件事：确认会话信息、勾选要保留的消息。</p>

                <div class="preview-layout">
                    <div class="preview-meta-panel">
                        <div class="preview-section">
                            <h4 class="preview-section-title">基本信息</h4>
                            <div class="preview-form">
                                <div class="form-group">
                                    <label class="form-label">会话标题</label>
                                    <input type="text" id="previewTitleInput" class="form-input" placeholder="输入会话标题">
                                </div>
                                <div class="form-row">
                                    <div class="form-group">
                                        <label class="form-label">创建时间</label>
                                        <input type="datetime-local" id="previewCreateTimeInput" class="form-input">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">更新时间</label>
                                        <input type="datetime-local" id="previewUpdateTimeInput" class="form-input">
                                    </div>
                                </div>
                            </div>
                        </div>

                    </div>

                    <div class="preview-messages-panel">
                        <div class="preview-section">
                            <h4 class="preview-section-title">消息列表 <span id="previewMessageCount">(已选 0 / 0 条)</span></h4>
                            <div class="preview-messages-toolbar">
                                <button class="toolbar-btn" onclick="selectAllPreviewMessages()">全选</button>
                                <button class="toolbar-btn" onclick="deselectAllPreviewMessages()">全不选</button>
                                <button class="toolbar-btn" onclick="invertPreviewMessageSelection()">反选</button>
                            </div>
                            <div class="preview-messages-list" id="previewMessagesList"></div>
                        </div>
                    </div>
                </div>

                <!-- 操作按钮 -->
                <div class="preview-actions">
                    <button class="btn-text" onclick="openPreviewEditStandalonePreview()" style="padding: 12px 24px; border: 1px solid var(--md-sys-color-outline);">独立预览</button>
                    <button class="btn-text" onclick="closePreviewEditModal()" style="padding: 12px 24px; border: 1px solid var(--md-sys-color-outline);">取消</button>
                    <button class="btn-primary" onclick="savePreviewEdit()" style="padding: 12px 24px; background: var(--md-sys-color-primary); color: var(--md-sys-color-on-primary); border: none; border-radius: var(--md-sys-shape-corner-small); cursor: pointer;">保存并关闭</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 消息编辑对话框 -->
    <div class="modal-overlay" id="messageEditModal">
        <div class="modal message-edit-modal">
            <div class="modal-header">
                <h3 class="modal-title">✏️ 编辑消息</h3>
                <button class="modal-close" onclick="closeMessageEditModal()">×</button>
            </div>
            <div class="modal-body">
                <div class="form-group" id="messageRoleGroup">
                    <label class="form-label">角色</label>
                    <select id="messageRoleInput" class="form-input">
                        <option value="user">User (用户)</option>
                        <option value="assistant">Assistant (助手)</option>
                        <option value="system">System (系统)</option>
                        <option value="tool">Tool (工具)</option>
                    </select>
                </div>
                <div class="form-group" id="messageTimeGroup">
                    <label class="form-label">时间</label>
                    <input type="datetime-local" id="messageTimeInput" class="form-input">
                </div>
                <div class="form-group">
                    <label class="form-label">内容（Markdown 格式）</label>
                    <textarea id="messageContentInput" class="message-content-textarea" placeholder="输入消息内容..."></textarea>
                </div>
                <div class="preview-actions">
                    <button class="btn-text" onclick="closeMessageEditModal()" style="padding: 10px 20px; border: 1px solid var(--md-sys-color-outline);">取消</button>
                    <button class="btn-primary" onclick="saveMessageEdit()" style="padding: 10px 20px; background: var(--md-sys-color-primary); color: var(--md-sys-color-on-primary); border: none; border-radius: var(--md-sys-shape-corner-small); cursor: pointer;">保存</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="workspaceConversationModal">
        <div class="modal workspace-edit-modal">
            <div class="modal-header">
                <h3 class="modal-title">编辑会话</h3>
                <button class="modal-close" onclick="closeWorkspaceConversationModal()">×</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">来源</label>
                    <input type="text" id="workspaceEditSourceInput" class="form-input" readonly>
                </div>
                <div class="form-group">
                    <label class="form-label">会话标题</label>
                    <input type="text" id="workspaceEditTitleInput" class="form-input" placeholder="输入会话标题">
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">创建时间</label>
                        <input type="datetime-local" id="workspaceEditCreateInput" class="form-input">
                    </div>
                    <div class="form-group">
                        <label class="form-label">更新时间</label>
                        <input type="datetime-local" id="workspaceEditUpdateInput" class="form-input">
                    </div>
                </div>
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin-top: 4px;">
                        <input type="checkbox" id="workspaceEditSelectedInput" checked>
                        <span style="font-size: 13px;">参与本次合并</span>
                    </label>
                </div>
                <p id="workspaceEditHint" style="font-size: 12px; color: var(--md-sys-color-on-surface-variant); line-height: 1.5; margin-top: 8px;"></p>
                <div class="preview-actions">
                    <button class="btn-text" onclick="closeWorkspaceConversationModal()" style="padding: 10px 20px; border: 1px solid var(--md-sys-color-outline);">取消</button>
                    <button class="btn-primary" onclick="saveWorkspaceConversationEdit()" style="padding: 10px 20px; background: var(--md-sys-color-primary); color: var(--md-sys-color-on-primary); border: none; border-radius: var(--md-sys-shape-corner-small); cursor: pointer;">保存</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal-overlay workspace-preview-overlay" id="workspacePreviewModal" onclick="closeWorkspacePreviewModalOnOverlay(event)">
        <div class="modal workspace-preview-modal">
            <div class="modal-header">
                <h3 class="modal-title" id="workspacePreviewModalTitle">会话预览</h3>
                <button class="modal-close" onclick="closeWorkspacePreviewModal()">×</button>
            </div>
            <div class="modal-body">
                <div class="workspace-preview-toolbar">
                    <span class="workspace-preview-title" id="workspacePreviewModalMeta">显示 0 / 0 条消息</span>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap; justify-content: flex-end;">
                        <button
                            type="button"
                            class="workspace-action-btn"
                            id="workspacePreviewToggleAllBtn"
                            onclick="toggleWorkspacePreviewModalShowAll()"
                            style="display: none;"
                        >
                            展开全部
                        </button>
                        <button type="button" class="workspace-action-btn" id="workspacePreviewEditBtn" onclick="openWorkspacePreviewConversationEditor()">编辑会话</button>
                    </div>
                </div>
                <div class="workspace-preview-chat" id="workspacePreviewModalChat"></div>
            </div>
        </div>
    </div>

    <script>
        let sourceData = null;
        let secondSourceData = null; // DeepSeek 旧版数据
        let rikkahubData = null;
        let rikkahubSettings = null;
        let rikkahubZip = null;
        let pendingMergeAfterRikkaUpload = false;
        let pendingMergedDownloadBlob = null;
        let pendingMergedDownloadUrl = null;
        let pendingMergedDownloadFilename = 'rikka_hub_merged.zip';
        let pendingMergedDownloadSize = 0;
        let pendingMergedDownloadRisk = null;
        let pendingMergeDryRunResolver = null;
        let db = null;
        let currentDataSource = 'chatgpt';

        // 存储 ChatGPT ZIP 和图片索引：key -> { zipPath: string, mimeType: string }
        let chatgptZip = null;
        let chatgptImages = new Map();
        let chatgptIndexedImageKeys = new Set();
        let importedSourcePool = {
            chatgpt: { sourceData: null, secondSourceData: null },
            deepseek: { sourceData: null, secondSourceData: null },
            youraiscroll: { sourceData: null, secondSourceData: null }
        };

        // 统一会话工作区（第一阶段）
        let workspaceStore = {
            sourceType: null,
            conversations: [],
            updatedAt: null
        };
        let pendingRikkaCompatSettings = {
            chatgpt: { userNickname: null, assistantName: null },
            deepseek: { userNickname: null, assistantName: null },
            youraiscroll: { userNickname: null, assistantName: null }
        };
        let workspaceEditContext = null;
        let workspacePreviewState = {
            workspaceId: null,
            showAll: false,
            customConversation: null
        };

        function ensureSourcePoolBucket(sourceType) {
            if (!importedSourcePool[sourceType] || typeof importedSourcePool[sourceType] !== 'object') {
                importedSourcePool[sourceType] = { sourceData: null, secondSourceData: null };
            }
            return importedSourcePool[sourceType];
        }

        function saveCurrentSourceBuffersToPool() {
            const bucket = ensureSourcePoolBucket(currentDataSource);
            bucket.sourceData = sourceData;
            bucket.secondSourceData = secondSourceData;
        }

        function loadSourceBuffersFromPool(sourceType) {
            const bucket = ensureSourcePoolBucket(sourceType);
            sourceData = bucket.sourceData;
            secondSourceData = bucket.secondSourceData;
        }

        function hasAnyImportedSourceData() {
            const currentPrimaryCount = Array.isArray(sourceData) ? sourceData.length : (sourceData ? 1 : 0);
            const currentSecondaryCount = Array.isArray(secondSourceData) ? secondSourceData.length : (secondSourceData ? 1 : 0);
            if ((currentPrimaryCount + currentSecondaryCount) > 0) {
                return true;
            }

            const sourceTypes = ['chatgpt', 'deepseek', 'youraiscroll'];
            return sourceTypes.some(type => {
                const bucket = ensureSourcePoolBucket(type);
                const primaryCount = Array.isArray(bucket.sourceData)
                    ? bucket.sourceData.length
                    : (bucket.sourceData ? 1 : 0);
                const secondaryCount = Array.isArray(bucket.secondSourceData)
                    ? bucket.secondSourceData.length
                    : (bucket.secondSourceData ? 1 : 0);
                return (primaryCount + secondaryCount) > 0;
            });
        }

        function resetPendingRikkaCompatSettings() {
            pendingRikkaCompatSettings = {
                chatgpt: { userNickname: null, assistantName: null },
                deepseek: { userNickname: null, assistantName: null },
                youraiscroll: { userNickname: null, assistantName: null }
            };
        }

        function getPendingCompatSettingsForSource(sourceType) {
            const key = sourceType || 'chatgpt';
            if (!pendingRikkaCompatSettings[key] || typeof pendingRikkaCompatSettings[key] !== 'object') {
                pendingRikkaCompatSettings[key] = { userNickname: null, assistantName: null };
            }
            return pendingRikkaCompatSettings[key];
        }

        function setPendingCompatSettingsForSource(sourceType, settings) {
            const key = sourceType || 'chatgpt';
            pendingRikkaCompatSettings[key] = {
                userNickname: settings?.userNickname || null,
                assistantName: settings?.assistantName || null
            };
        }

        function setMergeOptionTagSelection(groupId, value, hiddenInputId) {
            const group = document.getElementById(groupId);
            if (group) {
                const tags = group.querySelectorAll('.merge-option-tag');
                tags.forEach(tag => {
                    const selected = tag.getAttribute('data-value') === value;
                    tag.classList.toggle('selected', selected);
                    tag.setAttribute('aria-pressed', selected ? 'true' : 'false');
                });
            }

            const hiddenInput = document.getElementById(hiddenInputId);
            if (hiddenInput) {
                hiddenInput.value = value;
            }
        }

        function getDuplicateStrategy() {
            const hiddenInput = document.getElementById('duplicateStrategyValue');
            return hiddenInput?.value === 'keep_both' ? 'keep_both' : 'skip';
        }

        function setDuplicateStrategy(value) {
            const normalized = value === 'keep_both' ? 'keep_both' : 'skip';
            setMergeOptionTagSelection('duplicateStrategyTags', normalized, 'duplicateStrategyValue');
        }

        function getAssistantMergeStrategy() {
            const hiddenInput = document.getElementById('assistantMergeStrategyValue');
            return hiddenInput?.value === 'single_assistant' ? 'single_assistant' : 'by_source';
        }

        function setAssistantMergeStrategy(value) {
            const normalized = value === 'single_assistant' ? 'single_assistant' : 'by_source';
            setMergeOptionTagSelection('assistantMergeStrategyTags', normalized, 'assistantMergeStrategyValue');
            updateAssistantMergeStrategyUI();
        }

        function getUnifiedAssistantCustomName() {
            const nameInput = document.getElementById('unifiedAssistantNameInput');
            return String(nameInput?.value || '').trim();
        }

        function updateAssistantMergeStrategyUI() {
            const strategy = getAssistantMergeStrategy();
            const unifiedNameRow = document.getElementById('unifiedAssistantNameRow');
            const unifiedNameInput = document.getElementById('unifiedAssistantNameInput');
            const strategyHint = document.getElementById('assistantMergeStrategyHint');
            const isSingleAssistant = strategy === 'single_assistant';

            if (unifiedNameRow) {
                unifiedNameRow.style.display = isSingleAssistant ? 'grid' : 'none';
            }

            if (isSingleAssistant && unifiedNameInput && !String(unifiedNameInput.value || '').trim()) {
                const existingUnifiedName = String(getImportAssistantNameFromSettings('unified') || '').trim();
                if (existingUnifiedName) {
                    unifiedNameInput.value = existingUnifiedName;
                }
            }

            if (strategyHint) {
                strategyHint.textContent = isSingleAssistant
                    ? '所有导入会话会写入同一个助手，适合统一归档；可自定义助手名称。'
                    : '按来源创建/复用导入助手，便于区分 ChatGPT / DeepSeek / YourAIScroll。';
            }
        }

        function resetWorkspaceStore() {
            workspaceStore = {
                sourceType: 'all',
                conversations: [],
                updatedAt: null
            };
            resetPendingRikkaCompatSettings();
            importedSourcePool = {
                chatgpt: { sourceData: null, secondSourceData: null },
                deepseek: { sourceData: null, secondSourceData: null },
                youraiscroll: { sourceData: null, secondSourceData: null }
            };
            sourceData = null;
            secondSourceData = null;
            workspacePreviewState = {
                workspaceId: null,
                showAll: false,
                customConversation: null
            };
            const searchInput = document.getElementById('workspaceSearchInput');
            if (searchInput) {
                searchInput.value = '';
            }
            closeWorkspacePreviewModal();
            renderWorkspaceList();
        }

        function escapeWorkspaceHtml(text) {
            return String(text || '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function normalizeTimestampToMs(value) {
            if (value == null || value === '') return null;
            if (typeof value === 'number') {
                if (!Number.isFinite(value)) return null;
                return value < 1e12 ? Math.floor(value * 1000) : Math.floor(value);
            }
            const date = new Date(value);
            if (Number.isNaN(date.getTime())) return null;
            return date.getTime();
        }

        function formatWorkspaceTimestamp(ms) {
            if (!ms || !Number.isFinite(ms)) return '未知时间';
            try {
                return new Date(ms).toLocaleString('zh-CN', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch (error) {
                return new Date(ms).toISOString();
            }
        }

        function estimateChatGPTConversationMessageCount(conv) {
            if (conv && Array.isArray(conv._editedMessages)) {
                return conv._editedMessages.filter(msg => String(msg?.content || '').trim()).length;
            }
            const mapping = conv && typeof conv.mapping === 'object' ? conv.mapping : {};
            const currentNodeId = conv ? conv.current_node : null;
            if (!currentNodeId || !mapping[currentNodeId]) return 0;

            let count = 0;
            const visited = new Set();
            let nodeId = currentNodeId;
            while (nodeId && mapping[nodeId] && !visited.has(nodeId)) {
                visited.add(nodeId);
                const role = mapping[nodeId]?.message?.author?.role;
                if (role === 'user' || role === 'assistant' || role === 'system') {
                    count++;
                }
                nodeId = mapping[nodeId]?.parent;
            }
            return count;
        }

        function estimateDeepSeekNewConversationMessageCount(conv) {
            if (conv && Array.isArray(conv._editedMessages)) {
                return conv._editedMessages.filter(msg => String(msg?.content || '').trim()).length;
            }
            const mapping = conv && typeof conv.mapping === 'object' ? conv.mapping : {};
            let count = 0;
            Object.keys(mapping).forEach(key => {
                const fragments = mapping[key]?.message?.fragments;
                if (!Array.isArray(fragments) || fragments.length === 0) return;

                let hasRequest = false;
                let hasResponse = false;
                let hasThink = false;
                fragments.forEach(fragment => {
                    const type = String(fragment?.type || '');
                    const content = String(fragment?.content || '').trim();
                    if (!content) return;
                    if (type === 'REQUEST') hasRequest = true;
                    if (type === 'RESPONSE') hasResponse = true;
                    if (type === 'THINK') hasThink = true;
                });

                if (hasRequest) count++;
                if (hasResponse) count++;
                if (!hasRequest && !hasResponse && hasThink) count++;
            });
            return count;
        }

        function estimateDeepSeekOldConversationMessageCount(conv) {
            if (conv && Array.isArray(conv._editedMessages)) {
                return conv._editedMessages.filter(msg => String(msg?.content || '').trim()).length;
            }
            if (!conv || !Array.isArray(conv.messages)) return 0;
            return conv.messages.filter(msg => {
                const content = String(msg?.content || '').trim();
                const role = String(msg?.role || '').toLowerCase();
                return content && (role === 'user' || role === 'assistant');
            }).length;
        }

        function estimateYourAIScrollConversationMessageCount(conv) {
            if (conv && Array.isArray(conv._editedMessages)) {
                return conv._editedMessages.filter(msg => String(msg?.content || '').trim()).length;
            }
            if (conv && Array.isArray(conv._rawMessages)) {
                return conv._rawMessages.filter(msg => {
                    const role = typeof normalizeMessageRole === 'function'
                        ? normalizeMessageRole(msg?.role)
                        : String(msg?.role || '').toLowerCase();
                    return msg && Array.isArray(msg.parts) && msg.parts.length > 0 && !!role;
                }).length;
            }
            if (conv && Array.isArray(conv.messages)) {
                return conv.messages.length;
            }
            return 0;
        }

        function rebuildWorkspaceFromCurrentSource() {
            const searchInput = document.getElementById('workspaceSearchInput');
            const previousSelection = new Map((workspaceStore.conversations || []).map(item => [item.id, item.selected !== false]));
            if (searchInput && workspaceStore.sourceType !== 'all') {
                searchInput.value = '';
            }

            const conversations = [];

            const chatgptBucket = ensureSourcePoolBucket('chatgpt');
            if (Array.isArray(chatgptBucket.sourceData)) {
                chatgptBucket.sourceData.forEach((conv, index) => {
                    const sourceConversationId = conv?.conversation_id || conv?.id || `chatgpt-${index}`;
                    const fallbackKey = `${conv?.title || ''}|${conv?.create_time || ''}|${conv?.update_time || ''}`;
                    const normalizedConvId = normalizeConversationId(sourceConversationId, 'chatgpt', fallbackKey);
                    const workspaceId = deterministicUuidFromString(`workspace|chatgpt|${normalizedConvId}`);
                    conversations.push({
                        id: workspaceId,
                        dataSource: 'chatgpt',
                        normalizedConvId: normalizedConvId,
                        title: conv?.title || 'Untitled',
                        sourceLabel: 'ChatGPT',
                        bucket: 'sourceData',
                        rawIndex: index,
                        messageCount: estimateChatGPTConversationMessageCount(conv),
                        createdAtMs: normalizeTimestampToMs(conv?.create_time),
                        updatedAtMs: normalizeTimestampToMs(conv?.update_time),
                        selected: previousSelection.has(workspaceId) ? previousSelection.get(workspaceId) : true,
                        previewMessages: null
                    });
                });
            }

            const deepseekBucket = ensureSourcePoolBucket('deepseek');
            if (Array.isArray(deepseekBucket.sourceData)) {
                deepseekBucket.sourceData.forEach((conv, index) => {
                    const sourceConversationId = conv?.id || `deepseek-${index}`;
                    const fallbackKey = `${conv?.title || ''}|${conv?.inserted_at || ''}|${conv?.updated_at || ''}`;
                    const normalizedConvId = normalizeConversationId(sourceConversationId, 'deepseek', fallbackKey);
                    const workspaceId = deterministicUuidFromString(`workspace|deepseek|${normalizedConvId}`);
                    conversations.push({
                        id: workspaceId,
                        dataSource: 'deepseek',
                        normalizedConvId: normalizedConvId,
                        title: conv?.title || 'Untitled',
                        sourceLabel: 'DeepSeek 新版',
                        bucket: 'sourceData',
                        rawIndex: index,
                        messageCount: estimateDeepSeekNewConversationMessageCount(conv),
                        createdAtMs: normalizeTimestampToMs(conv?.inserted_at),
                        updatedAtMs: normalizeTimestampToMs(conv?.updated_at),
                        selected: previousSelection.has(workspaceId) ? previousSelection.get(workspaceId) : true,
                        previewMessages: null
                    });
                });
            }

            if (Array.isArray(deepseekBucket.secondSourceData)) {
                deepseekBucket.secondSourceData.forEach((conv, index) => {
                    const sourceConversationId = conv?.id || `deepseek-old-${index}`;
                    const fallbackKey = `${conv?.title || ''}|${conv?.created_at || ''}|${conv?.updated_at || ''}`;
                    const normalizedConvId = normalizeConversationId(sourceConversationId, 'deepseek-old', fallbackKey);
                    const workspaceId = deterministicUuidFromString(`workspace|deepseek-old|${normalizedConvId}`);
                    conversations.push({
                        id: workspaceId,
                        dataSource: 'deepseek',
                        normalizedConvId: normalizedConvId,
                        title: conv?.title || 'Untitled',
                        sourceLabel: 'DeepSeek 旧版',
                        bucket: 'secondSourceData',
                        rawIndex: index,
                        messageCount: estimateDeepSeekOldConversationMessageCount(conv),
                        createdAtMs: normalizeTimestampToMs(conv?.created_at),
                        updatedAtMs: normalizeTimestampToMs(conv?.updated_at),
                        selected: previousSelection.has(workspaceId) ? previousSelection.get(workspaceId) : true,
                        previewMessages: null
                    });
                });
            }

            const youraiscrollBucket = ensureSourcePoolBucket('youraiscroll');
            if (Array.isArray(youraiscrollBucket.sourceData)) {
                youraiscrollBucket.sourceData.forEach((conv, index) => {
                    const sourceConversationId = conv?.id || `youraiscroll-${index}`;
                    const fallbackKey = `${conv?.title || ''}|${conv?.create_at || ''}|${conv?.update_at || ''}`;
                    const normalizedConvId = normalizeConversationId(sourceConversationId, 'youraiscroll', fallbackKey);
                    const workspaceId = deterministicUuidFromString(`workspace|youraiscroll|${normalizedConvId}`);
                    const platform = conv?.platform ? String(conv.platform) : 'unknown';
                    const platformLabel = getPlatformName(platform) || platform;
                    conversations.push({
                        id: workspaceId,
                        dataSource: 'youraiscroll',
                        normalizedConvId: normalizedConvId,
                        title: conv?.title || 'Untitled',
                        sourceLabel: `YourAIScroll · ${platformLabel}`,
                        bucket: 'sourceData',
                        rawIndex: index,
                        messageCount: estimateYourAIScrollConversationMessageCount(conv),
                        createdAtMs: normalizeTimestampToMs(conv?.create_at),
                        updatedAtMs: normalizeTimestampToMs(conv?.update_at),
                        selected: previousSelection.has(workspaceId) ? previousSelection.get(workspaceId) : true,
                        previewMessages: null
                    });
                });
            }

            workspaceStore = {
                sourceType: 'all',
                conversations: conversations,
                updatedAt: Date.now()
            };

            renderWorkspaceList();
            checkReady();
        }

        function renderWorkspaceList() {
            const card = document.getElementById('workspaceCard');
            const meta = document.getElementById('workspaceMeta');
            const list = document.getElementById('workspaceList');
            const searchInput = document.getElementById('workspaceSearchInput');
            if (!card || !meta || !list) return;

            const allConversations = Array.isArray(workspaceStore.conversations) ? workspaceStore.conversations : [];
            const shouldShow = allConversations.length > 0;
            if (!shouldShow) {
                card.style.display = 'none';
                list.innerHTML = '';
                meta.textContent = '已选 0 / 0';
                return;
            }

            card.style.display = 'block';
            const selectedCount = allConversations.filter(item => item.selected !== false).length;
            meta.textContent = `已选 ${selectedCount} / ${allConversations.length}`;

            const keyword = String(searchInput?.value || '').trim().toLowerCase();
            const visibleConversations = keyword
                ? allConversations.filter(item => {
                    const haystack = `${item.title || ''} ${item.sourceLabel || ''}`.toLowerCase();
                    return haystack.includes(keyword);
                })
                : allConversations;

            if (visibleConversations.length === 0) {
                list.innerHTML = '<div class="workspace-empty">没有匹配的会话</div>';
                return;
            }

            list.innerHTML = visibleConversations.map(item => {
                const subtitleParts = [];
                subtitleParts.push(`${item.messageCount || 0} 条消息`);
                subtitleParts.push(formatWorkspaceTimestamp(item.updatedAtMs || item.createdAtMs));
                return `
                    <div class="workspace-item">
                        <div class="workspace-row">
                            <input
                                type="checkbox"
                                class="workspace-checkbox"
                                data-id="${escapeWorkspaceHtml(item.id)}"
                                ${item.selected !== false ? 'checked' : ''}
                            >
                            <div class="workspace-row-main">
                                <div class="workspace-row-title">${escapeWorkspaceHtml(item.title || 'Untitled')}</div>
                                <div class="workspace-row-sub">${escapeWorkspaceHtml(subtitleParts.join(' · '))}</div>
                            </div>
                            <span class="workspace-badge">${escapeWorkspaceHtml(item.sourceLabel || 'Source')}</span>
                            <div style="display: flex; gap: 6px; justify-content: flex-end;">
                                <button
                                    type="button"
                                    class="workspace-action-btn"
                                    data-action="preview"
                                    data-id="${escapeWorkspaceHtml(item.id)}"
                                >
                                    预览
                                </button>
                                <button
                                    type="button"
                                    class="workspace-action-btn"
                                    data-action="edit"
                                    data-id="${escapeWorkspaceHtml(item.id)}"
                                >
                                    编辑
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            list.querySelectorAll('.workspace-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', event => {
                    const id = event.target.getAttribute('data-id');
                    toggleWorkspaceConversation(id, event.target.checked);
                });
            });

            list.querySelectorAll('.workspace-action-btn[data-action="edit"]').forEach(button => {
                button.addEventListener('click', event => {
                    const id = event.target.getAttribute('data-id');
                    openWorkspaceConversationEditor(id);
                });
            });

            list.querySelectorAll('.workspace-action-btn[data-action="preview"]').forEach(button => {
                button.addEventListener('click', event => {
                    const id = event.target.getAttribute('data-id');
                    openWorkspaceConversationPreview(id);
                });
            });
        }

        function toggleWorkspaceConversation(workspaceId, selected) {
            const target = (workspaceStore.conversations || []).find(item => item.id === workspaceId);
            if (!target) return;
            target.selected = !!selected;
            renderWorkspaceList();
            checkReady();
        }

        function setWorkspaceSelectionState(selected) {
            if (!Array.isArray(workspaceStore.conversations) || workspaceStore.conversations.length === 0) return;
            workspaceStore.conversations.forEach(item => {
                item.selected = !!selected;
            });
            renderWorkspaceList();
            checkReady();
        }

        function invertWorkspaceSelection() {
            if (!Array.isArray(workspaceStore.conversations) || workspaceStore.conversations.length === 0) return;
            workspaceStore.conversations.forEach(item => {
                item.selected = item.selected === false;
            });
            renderWorkspaceList();
            checkReady();
        }

        function toPreviewMessageObjectsFromRikkaMessages(rikkaMessages, baseMs = Date.now()) {
            if (!Array.isArray(rikkaMessages)) return [];
            return rikkaMessages.map((msg, index) => {
                const content = extractTextFromRikkaParts(msg?.parts || []);
                const fallbackMs = baseMs + (index * 1000);
                const timestamp = normalizeIsoString(msg?.createdAt || msg?.timestamp, fallbackMs);
                return {
                    role: normalizeMessageRole(msg?.role) || 'assistant',
                    content: String(content || '').trim(),
                    timestamp: timestamp
                };
            }).filter(msg => msg.content);
        }

        function getWorkspaceConversationPreviewMessages(workspaceId) {
            const binding = getWorkspaceConversationBinding(workspaceId);
            if (!binding) return [];

            const { item, conversation } = binding;
            if (Array.isArray(conversation?._editedMessages) && conversation._editedMessages.length > 0) {
                const baseMs = item.createdAtMs || Date.now();
                const editedPreviewMessages = conversation._editedMessages.map((msg, index) => ({
                    role: normalizeMessageRole(msg?.role) || 'assistant',
                    content: String(msg?.content || '').trim(),
                    timestamp: normalizeIsoString(msg?.timestamp, baseMs + (index * 1000))
                })).filter(msg => msg.content);
                item.previewMessages = editedPreviewMessages;
                return editedPreviewMessages;
            }

            if (Array.isArray(item.previewMessages) && item.previewMessages.length > 0) {
                return item.previewMessages;
            }

            let previewMessages = [];
            const baseMs = item.createdAtMs || Date.now();
            const sourceType = item.dataSource || currentDataSource;

            try {
                if (sourceType === 'chatgpt') {
                    const mapping = conversation?.mapping || {};
                    const currentNode = conversation?.current_node;
                    const rikkahubMessages = extractMessages(mapping, currentNode, null, null);
                    previewMessages = toPreviewMessageObjectsFromRikkaMessages(rikkahubMessages, baseMs);
                } else if (sourceType === 'deepseek' && item.bucket === 'sourceData') {
                    const mapping = conversation?.mapping || {};
                    const rikkahubMessages = extractDeepSeekMessages(mapping, null);
                    previewMessages = toPreviewMessageObjectsFromRikkaMessages(rikkahubMessages, baseMs);
                } else if (sourceType === 'deepseek' && item.bucket === 'secondSourceData') {
                    previewMessages = (Array.isArray(conversation?.messages) ? conversation.messages : [])
                        .map((msg, index) => {
                            const role = normalizeMessageRole(msg?.role) || 'assistant';
                            const content = String(msg?.content || '').trim();
                            const timestamp = normalizeIsoString(msg?.time || msg?.timestamp, baseMs + (index * 1000));
                            return { role, content, timestamp };
                        })
                        .filter(msg => msg.content);
                } else if (sourceType === 'youraiscroll') {
                    const editableMessages = buildPreviewEditableMessages(conversation);
                    previewMessages = editableMessages.map(msg => ({
                        role: normalizeMessageRole(msg?.role) || 'assistant',
                        content: String(msg?.content || '').trim(),
                        timestamp: normalizeIsoString(msg?.timestamp, baseMs)
                    })).filter(msg => msg.content);
                }
            } catch (error) {
                console.warn('failed to build workspace preview messages:', error);
                previewMessages = [];
            }

            item.previewMessages = previewMessages;
            return previewMessages;
        }

        function resolvePreviewSourceLabel(sourceType) {
            const normalized = String(sourceType || '').trim().toLowerCase();
            if (!normalized) return 'Source';
            if (normalized === 'chatgpt') return 'ChatGPT';
            if (normalized === 'deepseek') return 'DeepSeek';
            if (normalized === 'youraiscroll') return 'YourAIScroll';
            return getPlatformName(normalized) || sourceType;
        }

        function getWorkspacePreviewRoleMeta(role) {
            const normalized = normalizeMessageRole(role) || 'assistant';
            if (normalized === 'user') {
                return { role: 'user', label: '用户', avatar: 'U' };
            }
            if (normalized === 'assistant') {
                return { role: 'assistant', label: '助手', avatar: 'A' };
            }
            if (normalized === 'system') {
                return { role: 'system', label: '系统', avatar: 'S' };
            }
            return { role: 'tool', label: '工具', avatar: 'T' };
        }

        function showWorkspacePreviewModalPanel() {
            const modal = document.getElementById('workspacePreviewModal');
            if (modal) {
                modal.classList.add('active');
                document.body.style.overflow = 'hidden';
            }
        }

        function openWorkspacePreviewWithCustomConversation(conversationLike) {
            const rawMessages = Array.isArray(conversationLike?.messages) ? conversationLike.messages : [];
            const baseMs = Date.now();
            const normalizedMessages = rawMessages.map((msg, index) => {
                const fallbackMs = baseMs + (index * 1000);
                return {
                    role: normalizeMessageRole(msg?.role) || 'assistant',
                    content: String(msg?.content || '').trim(),
                    timestamp: normalizeIsoString(msg?.timestamp, fallbackMs)
                };
            }).filter(msg => msg.content);

            workspacePreviewState = {
                workspaceId: null,
                showAll: false,
                customConversation: {
                    title: String(conversationLike?.title || 'Untitled'),
                    sourceLabel: String(conversationLike?.sourceLabel || 'Source'),
                    messages: normalizedMessages
                }
            };
            renderWorkspacePreviewModal();
            showWorkspacePreviewModalPanel();
        }

        function openWorkspaceConversationPreview(workspaceId) {
            const target = (workspaceStore.conversations || []).find(item => item.id === workspaceId);
            if (!target) return;

            workspacePreviewState = {
                workspaceId: workspaceId,
                showAll: false,
                customConversation: null
            };
            renderWorkspacePreviewModal();
            showWorkspacePreviewModalPanel();
        }

        function closeWorkspacePreviewModal() {
            const modal = document.getElementById('workspacePreviewModal');
            if (modal) {
                modal.classList.remove('active');
            }
            workspacePreviewState = {
                workspaceId: null,
                showAll: false,
                customConversation: null
            };
            document.body.style.overflow = '';
        }

        function closeWorkspacePreviewModalOnOverlay(event) {
            if (event.target === event.currentTarget) {
                closeWorkspacePreviewModal();
            }
        }

        function renderWorkspacePreviewModal() {
            const defaultCount = 12;
            const titleElement = document.getElementById('workspacePreviewModalTitle');
            const metaElement = document.getElementById('workspacePreviewModalMeta');
            const chatElement = document.getElementById('workspacePreviewModalChat');
            const toggleBtn = document.getElementById('workspacePreviewToggleAllBtn');
            const editBtn = document.getElementById('workspacePreviewEditBtn');
            if (!titleElement || !metaElement || !chatElement || !toggleBtn || !editBtn) return;

            const workspaceId = workspacePreviewState.workspaceId;
            const customConversation = workspacePreviewState.customConversation;

            let title = 'Untitled';
            let sourceLabel = 'Source';
            let messages = [];
            let allowEdit = false;

            if (customConversation && Array.isArray(customConversation.messages)) {
                title = String(customConversation.title || 'Untitled');
                sourceLabel = String(customConversation.sourceLabel || 'Source');
                messages = customConversation.messages;
                allowEdit = false;
            } else {
                if (!workspaceId) return;
                const binding = getWorkspaceConversationBinding(workspaceId);
                if (!binding) {
                    closeWorkspacePreviewModal();
                    return;
                }
                const { item } = binding;
                title = String(item?.title || 'Untitled');
                sourceLabel = String(item?.sourceLabel || 'Source');
                messages = getWorkspaceConversationPreviewMessages(workspaceId);
                allowEdit = true;
            }

            const total = messages.length;
            const showAll = workspacePreviewState.showAll === true;
            const visibleMessages = showAll ? messages : messages.slice(Math.max(total - defaultCount, 0));

            titleElement.textContent = sourceLabel ? `${title} · ${sourceLabel}` : title;
            metaElement.textContent = `显示 ${visibleMessages.length} / ${total} 条消息`;
            editBtn.style.display = allowEdit ? 'inline-block' : 'none';

            if (total > defaultCount) {
                toggleBtn.style.display = 'inline-block';
                toggleBtn.textContent = showAll ? `仅看最近 ${defaultCount} 条` : `展开全部 ${total} 条`;
            } else {
                toggleBtn.style.display = 'none';
            }

            if (visibleMessages.length === 0) {
                chatElement.innerHTML = '<div class="workspace-preview-empty">此会话暂无可预览消息</div>';
                return;
            }

            chatElement.innerHTML = visibleMessages.map(msg => {
                const roleMeta = getWorkspacePreviewRoleMeta(msg?.role);
                const text = String(msg?.content || '').trim() || '[空消息]';
                const timestampText = formatWorkspaceTimestamp(normalizeTimestampToMs(msg?.timestamp));
                const previewHtml = renderPreviewMessageHtml(text);
                return `
                    <div class="workspace-preview-message ${escapeWorkspaceHtml(roleMeta.role)}">
                        <div class="workspace-preview-avatar">${escapeWorkspaceHtml(roleMeta.avatar)}</div>
                        <div class="workspace-preview-content">
                            <div class="workspace-preview-head">
                                <span class="workspace-preview-role">${escapeWorkspaceHtml(roleMeta.label)}</span>
                                <span class="workspace-preview-time">${escapeWorkspaceHtml(timestampText)}</span>
                            </div>
                            <div class="workspace-preview-bubble">
                                <div class="workspace-preview-rich">${previewHtml}</div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function toggleWorkspacePreviewModalShowAll() {
            if (!workspacePreviewState.workspaceId && !workspacePreviewState.customConversation) return;
            workspacePreviewState.showAll = workspacePreviewState.showAll !== true;
            renderWorkspacePreviewModal();
        }

        function openWorkspacePreviewConversationEditor() {
            const workspaceId = workspacePreviewState.workspaceId;
            if (!workspaceId) return;
            closeWorkspacePreviewModal();
            openWorkspaceConversationEditor(workspaceId);
        }

        function getWorkspaceConversationBinding(workspaceId) {
            const item = (workspaceStore.conversations || []).find(conv => conv.id === workspaceId);
            if (!item) return null;

            const sourceType = item.dataSource || currentDataSource;
            const sourceBucket = ensureSourcePoolBucket(sourceType);
            const bucketData = item.bucket === 'secondSourceData'
                ? sourceBucket.secondSourceData
                : sourceBucket.sourceData;
            if (!Array.isArray(bucketData)) return null;

            const conversation = bucketData[item.rawIndex];
            if (!conversation) return null;

            return { item, conversation };
        }

        function normalizeIsoString(input, fallbackMs = Date.now()) {
            const normalizedMs = normalizeTimestampToMs(input);
            const safeMs = normalizedMs && Number.isFinite(normalizedMs) ? normalizedMs : fallbackMs;
            return new Date(safeMs).toISOString();
        }

        function parseDateTimeInputToMs(inputValue, fallbackMs) {
            const parsedMs = new Date(String(inputValue || '')).getTime();
            if (!Number.isFinite(parsedMs)) return fallbackMs;
            return parsedMs;
        }

        function extractTextFromRikkaParts(parts) {
            if (!Array.isArray(parts) || parts.length === 0) return '';
            const stringifyToolPayload = (value) => {
                if (value == null) return '';
                if (typeof value === 'string') return value;

                if (Array.isArray(value)) {
                    return value.map(item => {
                        if (item == null) return '';
                        if (typeof item === 'string') return item;
                        if (typeof item === 'object') {
                            const nestedType = String(item.type || '');
                            if (nestedType === 'me.rerere.ai.ui.UIMessagePart.Text') {
                                return String(item.text || '');
                            }
                            if (nestedType === 'me.rerere.ai.ui.UIMessagePart.Reasoning') {
                                return String(item.reasoning || '');
                            }
                            if (nestedType === 'me.rerere.ai.ui.UIMessagePart.Image') {
                                return String(item.url || '');
                            }
                            if (item.text != null) return String(item.text);
                            if (item.content != null) return String(item.content);
                        }
                        try {
                            return JSON.stringify(item, null, 2);
                        } catch (error) {
                            return String(item);
                        }
                    }).filter(Boolean).join('\n').trim();
                }

                if (typeof value === 'object') {
                    if (value.text != null) return String(value.text);
                    if (value.content != null) return String(value.content);
                    try {
                        return JSON.stringify(value, null, 2);
                    } catch (error) {
                        return String(value);
                    }
                }

                return String(value);
            };

            return parts.map(part => {
                const partType = String(part?.type || '');
                if (partType === 'me.rerere.ai.ui.UIMessagePart.Text') {
                    return String(part?.text || '');
                }
                if (partType === 'me.rerere.ai.ui.UIMessagePart.Reasoning') {
                    const reasoning = String(part?.reasoning || '').trim();
                    return reasoning ? `[深度思考]\n${reasoning}\n[/深度思考]` : '';
                }
                if (partType === 'me.rerere.ai.ui.UIMessagePart.Image') {
                    const url = String(part?.url || '').trim();
                    return url ? `![image](${url})` : '';
                }
                if (partType === 'me.rerere.ai.ui.UIMessagePart.ToolCall') {
                    const toolName = String(part?.toolName || 'tool');
                    const args = String(part?.arguments || '').trim();
                    return args
                        ? `[工具调用] ${toolName}\n${args}\n[/工具调用]`
                        : `[工具调用] ${toolName}\n[/工具调用]`;
                }
                if (partType === 'me.rerere.ai.ui.UIMessagePart.Tool') {
                    const toolName = String(part?.toolName || 'tool');
                    const args = String(part?.arguments || '').trim();
                    const output = stringifyToolPayload(part?.output).trim();
                    const callText = args
                        ? `[工具调用] ${toolName}\n${args}\n[/工具调用]`
                        : `[工具调用] ${toolName}\n[/工具调用]`;
                    return output
                        ? `${callText}\n\n[工具结果] ${toolName}\n${output}\n[/工具结果]`
                        : callText;
                }
                if (partType === 'me.rerere.ai.ui.UIMessagePart.ToolResult') {
                    const toolName = String(part?.toolName || 'tool');
                    const output = stringifyToolPayload(part?.output ?? part?.result ?? part?.content).trim();
                    return output
                        ? `[工具结果] ${toolName}\n${output}\n[/工具结果]`
                        : `[工具结果] ${toolName}\n[/工具结果]`;
                }
                return '';
            }).filter(Boolean).join('\n\n').trim();
        }

        function ensureYourAIScrollConversationEditable(conversation) {
            if (!conversation || !Array.isArray(conversation._rawMessages)) return;

            if (!Array.isArray(conversation.messages) || conversation.messages.length === 0) {
                const baseMs = normalizeTimestampToMs(conversation.create_at) || Date.now();
                conversation.messages = conversation._rawMessages.map((msg, index) => {
                    const content = extractTextFromRikkaParts(msg?.parts);
                    const fallbackMs = baseMs + (index * 1000);
                    return {
                        role: normalizeMessageRole(msg?.role) || 'assistant',
                        content: content,
                        timestamp: normalizeIsoString(msg?.createdAt, fallbackMs),
                        selected: true
                    };
                });
            }

            if (!conversation.original_data || typeof conversation.original_data !== 'object') {
                const baseMs = normalizeTimestampToMs(conversation.create_at) || Date.now();
                conversation.original_data = { timestamp: new Date(baseMs).toISOString() };
            }
        }

        function buildWorkspaceEditableMessages(binding) {
            if (!binding) return [];
            const { item, conversation } = binding;
            const baseMs = item?.createdAtMs || Date.now();
            const sourceType = item?.dataSource || currentDataSource;

            if (Array.isArray(conversation?._editedMessages) && conversation._editedMessages.length > 0) {
                return conversation._editedMessages.map((msg, index) => normalizePreviewMessage(msg, baseMs + (index * 1000)));
            }

            try {
                if (sourceType === 'chatgpt') {
                    const mapping = conversation?.mapping || {};
                    const currentNode = conversation?.current_node;
                    const rikkahubMessages = extractMessages(mapping, currentNode, null, null);
                    const previewMessages = toPreviewMessageObjectsFromRikkaMessages(rikkahubMessages, baseMs);
                    return previewMessages.map((msg, index) => normalizePreviewMessage(msg, baseMs + (index * 1000)));
                }

                if (sourceType === 'deepseek' && item?.bucket === 'sourceData') {
                    const mapping = conversation?.mapping || {};
                    const rikkahubMessages = extractDeepSeekMessages(mapping, null);
                    const previewMessages = toPreviewMessageObjectsFromRikkaMessages(rikkahubMessages, baseMs);
                    return previewMessages.map((msg, index) => normalizePreviewMessage(msg, baseMs + (index * 1000)));
                }

                if (sourceType === 'deepseek' && item?.bucket === 'secondSourceData') {
                    const sourceMessages = Array.isArray(conversation?.messages) ? conversation.messages : [];
                    return sourceMessages.map((msg, index) => normalizePreviewMessage({
                        role: normalizeMessageRole(msg?.role) || 'assistant',
                        content: String(msg?.content || ''),
                        timestamp: msg?.time || msg?.timestamp
                    }, baseMs + (index * 1000))).filter(msg => String(msg.content || '').trim());
                }

                if (sourceType === 'youraiscroll') {
                    ensureYourAIScrollConversationEditable(conversation);
                    return buildPreviewEditableMessages(conversation);
                }
            } catch (error) {
                console.warn('buildWorkspaceEditableMessages failed:', error);
            }

            return [];
        }

        function buildWorkspaceEditableConversation(binding) {
            const { item, conversation } = binding;
            const createMs = item?.createdAtMs || Date.now();
            const updateMs = item?.updatedAtMs || createMs;
            const sourceType = item?.dataSource || currentDataSource;
            const platform = sourceType === 'youraiscroll'
                ? (conversation?.platform || 'unknown')
                : sourceType;
            const assistantName = getPlatformName(platform) || item?.sourceLabel || 'AI Assistant';

            return {
                id: conversation?.id || item?.normalizedConvId || generateUUID(),
                title: item?.title || conversation?.title || 'Untitled',
                create_at: Math.floor(createMs / 1000),
                update_at: Math.floor(updateMs / 1000),
                user_id: conversation?.user_id || generateUUID(),
                user_name: conversation?.user_name || 'User',
                assistant_id: conversation?.assistant_id || generateUUID(),
                assistant_name: conversation?.assistant_name || assistantName,
                platform: platform,
                original_data: conversation?.original_data || null,
                messages: buildWorkspaceEditableMessages(binding),
                __workspaceMode: true,
                __workspaceId: item?.id || null,
                __sourceType: sourceType
            };
        }

        function openWorkspaceConversationEditor(workspaceId) {
            closeWorkspacePreviewModal();
            const binding = getWorkspaceConversationBinding(workspaceId);
            if (!binding) {
                showError('未找到会话，可能已被刷新。');
                return;
            }

            const editableConversation = buildWorkspaceEditableConversation(binding);
            openPreviewEditModal(editableConversation, {
                mode: 'workspace',
                messageOnly: true,
                sourceType: binding.item?.dataSource || currentDataSource
            });
        }

        function closeWorkspaceConversationModal() {
            const modal = document.getElementById('workspaceConversationModal');
            if (modal) {
                modal.classList.remove('active');
            }
            workspaceEditContext = null;
        }

        function saveWorkspaceConversationEdit() {
            if (!workspaceEditContext) return;

            const { item, conversation } = workspaceEditContext;
            const titleInput = document.getElementById('workspaceEditTitleInput');
            const createInput = document.getElementById('workspaceEditCreateInput');
            const updateInput = document.getElementById('workspaceEditUpdateInput');
            const selectedInput = document.getElementById('workspaceEditSelectedInput');

            const title = (titleInput?.value || '').trim() || 'Untitled';
            const fallbackCreateMs = item.createdAtMs || Date.now();
            const fallbackUpdateMs = item.updatedAtMs || fallbackCreateMs;
            const createMs = parseDateTimeInputToMs(createInput?.value, fallbackCreateMs);
            const updateMs = parseDateTimeInputToMs(updateInput?.value, Math.max(createMs, fallbackUpdateMs));
            const selected = !!selectedInput?.checked;

            conversation.title = title;

            if (currentDataSource === 'chatgpt') {
                conversation.create_time = Math.floor(createMs / 1000);
                conversation.update_time = Math.floor(updateMs / 1000);
            } else if (currentDataSource === 'deepseek') {
                if (item.bucket === 'sourceData') {
                    conversation.inserted_at = new Date(createMs).toISOString();
                    conversation.updated_at = new Date(updateMs).toISOString();
                } else {
                    conversation.created_at = createMs;
                    conversation.updated_at = updateMs;
                }
            } else if (currentDataSource === 'youraiscroll') {
                conversation.create_at = Math.floor(createMs / 1000);
                conversation.update_at = Math.floor(updateMs / 1000);
            }

            item.title = title;
            item.createdAtMs = createMs;
            item.updatedAtMs = updateMs;
            item.selected = selected;

            closeWorkspaceConversationModal();
            renderWorkspaceList();
            checkReady();
            showInfo('会话已更新');
        }

        function getMergeDataByWorkspaceSelection() {
            const workspaceHasItems = Array.isArray(workspaceStore?.conversations) && workspaceStore.conversations.length > 0;
            if (!workspaceHasItems) {
                const fallbackBySource = {
                    chatgpt: { sourceData: [], secondSourceData: [] },
                    deepseek: { sourceData: [], secondSourceData: [] },
                    youraiscroll: { sourceData: [], secondSourceData: [] }
                };
                const fallbackBindings = [];
                const currentSourceType = currentDataSource || 'chatgpt';

                const fallbackSourceData = Array.isArray(sourceData) ? sourceData : [];
                const fallbackSecondSourceData = Array.isArray(secondSourceData) ? secondSourceData : [];

                fallbackSourceData.forEach((conversation, index) => {
                    const item = {
                        id: `fallback-${currentSourceType}-source-${index}`,
                        dataSource: currentSourceType,
                        bucket: 'sourceData',
                        rawIndex: index
                    };
                    fallbackBindings.push({ item, conversation });
                    if (!fallbackBySource[currentSourceType]) {
                        fallbackBySource[currentSourceType] = { sourceData: [], secondSourceData: [] };
                    }
                    fallbackBySource[currentSourceType].sourceData.push(conversation);
                });

                fallbackSecondSourceData.forEach((conversation, index) => {
                    const item = {
                        id: `fallback-${currentSourceType}-second-${index}`,
                        dataSource: currentSourceType,
                        bucket: 'secondSourceData',
                        rawIndex: index
                    };
                    fallbackBindings.push({ item, conversation });
                    if (!fallbackBySource[currentSourceType]) {
                        fallbackBySource[currentSourceType] = { sourceData: [], secondSourceData: [] };
                    }
                    fallbackBySource[currentSourceType].secondSourceData.push(conversation);
                });

                return {
                    selectedItems: [],
                    selectedBindings: fallbackBindings,
                    bySource: fallbackBySource,
                    selectedCount: fallbackBindings.length
                };
            }

            const selectedItems = Array.isArray(workspaceStore?.conversations)
                ? workspaceStore.conversations.filter(item => item.selected !== false)
                : [];

            const selectedBindings = selectedItems
                .map(item => {
                    const binding = getWorkspaceConversationBinding(item.id);
                    if (!binding) return null;
                    return {
                        item: binding.item,
                        conversation: binding.conversation
                    };
                })
                .filter(Boolean);

            const bySource = {
                chatgpt: { sourceData: [], secondSourceData: [] },
                deepseek: { sourceData: [], secondSourceData: [] },
                youraiscroll: { sourceData: [], secondSourceData: [] }
            };

            selectedBindings.forEach(binding => {
                const sourceType = binding.item?.dataSource || currentDataSource;
                if (!bySource[sourceType]) {
                    bySource[sourceType] = { sourceData: [], secondSourceData: [] };
                }
                if (binding.item?.bucket === 'secondSourceData') {
                    bySource[sourceType].secondSourceData.push(binding.conversation);
                } else {
                    bySource[sourceType].sourceData.push(binding.conversation);
                }
            });

            return {
                selectedItems: selectedItems,
                selectedBindings: selectedBindings,
                bySource: bySource,
                selectedCount: selectedBindings.length
            };
        }

        function getSelectedConversationCountForCurrentSource() {
            const mergeDataSelection = getMergeDataByWorkspaceSelection();
            return mergeDataSelection.selectedCount || 0;
        }

        // 主题相关变量
        let currentTheme = 'ocean';
        let isDarkMode = true;

        // RikkaHub 预设主题颜色
        const presetThemes = {
            sakura: {
                light: {
                    primary: '#8E4955',
                    onPrimary: '#FFFFFF',
                    primaryContainer: '#FFD9DD',
                    onPrimaryContainer: '#72333E',
                    secondary: '#76565A',
                    onSecondary: '#FFFFFF',
                    secondaryContainer: '#FFD9DD',
                    onSecondaryContainer: '#5C3F43',
                    tertiary: '#785831',
                    onTertiary: '#FFFFFF',
                    tertiaryContainer: '#FFDDB8',
                    onTertiaryContainer: '#5E411C',
                    background: '#FFF8F7',
                    onBackground: '#22191A',
                    surface: '#FFF8F7',
                    onSurface: '#22191A',
                    surfaceVariant: '#F3DDDF',
                    onSurfaceVariant: '#524345',
                    outline: '#847374',
                    surfaceContainer: '#FBEAEB',
                    surfaceContainerHigh: '#F6E4E5',
                    surfaceContainerHighest: '#F0DEDF'
                },
                dark: {
                    primary: '#FFB2BC',
                    onPrimary: '#561D28',
                    primaryContainer: '#72333E',
                    onPrimaryContainer: '#FFD9DD',
                    secondary: '#E5BDC1',
                    onSecondary: '#43292D',
                    secondaryContainer: '#5C3F43',
                    onSecondaryContainer: '#FFD9DD',
                    tertiary: '#EABF8F',
                    onTertiary: '#452B07',
                    tertiaryContainer: '#5E411C',
                    onTertiaryContainer: '#FFDDB8',
                    background: '#1A1112',
                    onBackground: '#F0DEDF',
                    surface: '#1A1112',
                    onSurface: '#F0DEDF',
                    surfaceVariant: '#524345',
                    onSurfaceVariant: '#D7C1C3',
                    outline: '#9F8C8E',
                    surfaceContainer: '#261D1E',
                    surfaceContainerHigh: '#312828',
                    surfaceContainerHighest: '#3D3233'
                }
            },
            ocean: {
                light: {
                    primary: '#116682',
                    onPrimary: '#FFFFFF',
                    primaryContainer: '#BDE9FF',
                    onPrimaryContainer: '#004D64',
                    secondary: '#4D616C',
                    onSecondary: '#FFFFFF',
                    secondaryContainer: '#D0E6F2',
                    onSecondaryContainer: '#354A53',
                    tertiary: '#5D5B7D',
                    onTertiary: '#FFFFFF',
                    tertiaryContainer: '#E3DFFF',
                    onTertiaryContainer: '#454364',
                    background: '#F6FAFD',
                    onBackground: '#171C1F',
                    surface: '#F6FAFD',
                    onSurface: '#171C1F',
                    surfaceVariant: '#DCE4E9',
                    onSurfaceVariant: '#40484C',
                    outline: '#70787D',
                    surfaceContainer: '#EAEEF2',
                    surfaceContainerHigh: '#E4E9EC',
                    surfaceContainerHighest: '#DFE3E7'
                },
                dark: {
                    primary: '#8BD0EF',
                    onPrimary: '#003546',
                    primaryContainer: '#004D64',
                    onPrimaryContainer: '#BDE9FF',
                    secondary: '#B4CAD6',
                    onSecondary: '#1F333C',
                    secondaryContainer: '#354A53',
                    onSecondaryContainer: '#D0E6F2',
                    tertiary: '#C6C2EA',
                    onTertiary: '#2E2D4D',
                    tertiaryContainer: '#454364',
                    onTertiaryContainer: '#E3DFFF',
                    background: '#0F1417',
                    onBackground: '#DFE3E7',
                    surface: '#0F1417',
                    onSurface: '#DFE3E7',
                    surfaceVariant: '#40484C',
                    onSurfaceVariant: '#C0C8CD',
                    outline: '#8A9297',
                    surfaceContainer: '#1B2023',
                    surfaceContainerHigh: '#262B2D',
                    surfaceContainerHighest: '#303538'
                }
            },
            spring: {
                light: {
                    primary: '#4C662B',
                    onPrimary: '#FFFFFF',
                    primaryContainer: '#CDEDA3',
                    onPrimaryContainer: '#354E16',
                    secondary: '#586249',
                    onSecondary: '#FFFFFF',
                    secondaryContainer: '#DCE7C8',
                    onSecondaryContainer: '#404A33',
                    tertiary: '#386663',
                    onTertiary: '#FFFFFF',
                    tertiaryContainer: '#BCECE7',
                    onTertiaryContainer: '#1F4E4B',
                    background: '#F9FAEF',
                    onBackground: '#1A1C16',
                    surface: '#F9FAEF',
                    onSurface: '#1A1C16',
                    surfaceVariant: '#E1E4D5',
                    onSurfaceVariant: '#44483D',
                    outline: '#75796C',
                    surfaceContainer: '#EEEFE3',
                    surfaceContainerHigh: '#E8E9DE',
                    surfaceContainerHighest: '#E2E3D8'
                },
                dark: {
                    primary: '#B1D18A',
                    onPrimary: '#1F3701',
                    primaryContainer: '#354E16',
                    onPrimaryContainer: '#CDEDA3',
                    secondary: '#BFCBAD',
                    onSecondary: '#2A331E',
                    secondaryContainer: '#404A33',
                    onSecondaryContainer: '#DCE7C8',
                    tertiary: '#A0D0CB',
                    onTertiary: '#003735',
                    tertiaryContainer: '#1F4E4B',
                    onTertiaryContainer: '#BCECE7',
                    background: '#12140E',
                    onBackground: '#E2E3D8',
                    surface: '#12140E',
                    onSurface: '#E2E3D8',
                    surfaceVariant: '#44483D',
                    onSurfaceVariant: '#C5C8BA',
                    outline: '#8F9285',
                    surfaceContainer: '#1E201A',
                    surfaceContainerHigh: '#282B24',
                    surfaceContainerHighest: '#33362E'
                }
            },
            autumn: {
                light: {
                    primary: '#735C0C',
                    onPrimary: '#FFFFFF',
                    primaryContainer: '#FFE08B',
                    onPrimaryContainer: '#584400',
                    secondary: '#695D3F',
                    onSecondary: '#FFFFFF',
                    secondaryContainer: '#F2E1BB',
                    onSecondaryContainer: '#50462A',
                    tertiary: '#47664A',
                    onTertiary: '#FFFFFF',
                    tertiaryContainer: '#C8ECC9',
                    onTertiaryContainer: '#2F4D34',
                    background: '#FFF8F1',
                    onBackground: '#1F1B13',
                    surface: '#FFF8F1',
                    onSurface: '#1F1B13',
                    surfaceVariant: '#EBE1CF',
                    onSurfaceVariant: '#4C4639',
                    outline: '#7E7667',
                    surfaceContainer: '#F5EDDF',
                    surfaceContainerHigh: '#F0E7D9',
                    surfaceContainerHighest: '#EAE1D4'
                },
                dark: {
                    primary: '#E3C46D',
                    onPrimary: '#3D2F00',
                    primaryContainer: '#584400',
                    onPrimaryContainer: '#FFE08B',
                    secondary: '#D5C5A1',
                    onSecondary: '#392F15',
                    secondaryContainer: '#50462A',
                    onSecondaryContainer: '#F2E1BB',
                    tertiary: '#ADCFAE',
                    onTertiary: '#19361F',
                    tertiaryContainer: '#2F4D34',
                    onTertiaryContainer: '#C8ECC9',
                    background: '#16130B',
                    onBackground: '#EAE1D4',
                    surface: '#16130B',
                    onSurface: '#EAE1D4',
                    surfaceVariant: '#4C4639',
                    onSurfaceVariant: '#CFC6B4',
                    outline: '#989080',
                    surfaceContainer: '#1F1B13',
                    surfaceContainerHigh: '#2D2A21',
                    surfaceContainerHighest: '#38342B'
                }
            },
            black: {
                light: {
                    primary: '#606060',
                    onPrimary: '#FFFFFF',
                    primaryContainer: '#E6E6E6',
                    onPrimaryContainer: '#424242',
                    secondary: '#424242',
                    onSecondary: '#FFFFFF',
                    secondaryContainer: '#F3F3F3',
                    onSecondaryContainer: '#575757',
                    tertiary: '#343434',
                    onTertiary: '#FFFFFF',
                    tertiaryContainer: '#444444',
                    onTertiaryContainer: '#B5B5B5',
                    background: '#FFFFFF',
                    onBackground: '#252525',
                    surface: '#FFFFFF',
                    onSurface: '#252525',
                    surfaceVariant: '#F7F7F7',
                    onSurfaceVariant: '#444444',
                    outline: '#B5B5B5',
                    surfaceContainer: '#F7F7F7',
                    surfaceContainerHigh: '#EBEBEB',
                    surfaceContainerHighest: '#E8E8E8'
                },
                dark: {
                    primary: '#EBEBEB',
                    onPrimary: '#343434',
                    primaryContainer: '#3B3B3B',
                    onPrimaryContainer: '#B5B5B5',
                    secondary: '#B5B5B5',
                    onSecondary: '#343434',
                    secondaryContainer: '#444444',
                    onSecondary: '#FCFCFC',
                    tertiary: '#EBEBEB',
                    onTertiary: '#343434',
                    tertiaryContainer: '#444444',
                    onTertiaryContainer: '#B5B5B5',
                    background: '#1C1C1C',
                    onBackground: '#FCFCFC',
                    surface: '#1C1C1C',
                    onSurface: '#FCFCFC',
                    surfaceVariant: '#444444',
                    onSurfaceVariant: '#B5B5B5',
                    outline: '#8E8E8E',
                    surfaceContainer: '#252525',
                    surfaceContainerHigh: '#343434',
                    surfaceContainerHighest: '#3F3F3F'
                }
            }
        };

        // Tab 切换函数
        function showTab(tab) {
            const contentWarning = document.getElementById('contentWarning');
            const contentAlert = document.getElementById('contentAlert');
            const tabWarning = document.getElementById('tabWarning');
            const tabAlert = document.getElementById('tabAlert');

            if (!contentWarning || !contentAlert || !tabWarning || !tabAlert) {
                return;
            }

            if (tab === 'warning') {
                contentWarning.classList.add('active');
                contentAlert.classList.remove('active');
                tabWarning.classList.add('active');
                tabAlert.classList.remove('active');
            } else {
                contentWarning.classList.remove('active');
                contentAlert.classList.add('active');
                tabWarning.classList.remove('active');
                tabAlert.classList.add('active');
            }
        }

// 打开弹窗
        function openModal(type) {
            const modal = document.getElementById('modal' + type.charAt(0).toUpperCase() + type.slice(1));
            if (modal) {
                modal.classList.add('active');
                document.body.style.overflow = 'hidden';  // 禁止背景滚动
            }
        }

        // 点击遮罩层关闭
        function closeModal(event, type) {
            if (event.target === event.currentTarget) {
                closeModalDirect(type);
            }
        }

        // 直接关闭
        function closeModalDirect(type) {
            const modal = document.getElementById('modal' + type.charAt(0).toUpperCase() + type.slice(1));
            if (modal) {
                modal.classList.remove('active');
                document.body.style.overflow = '';  // 恢复背景滚动
            }
        }

        function openRikkaHubRequiredModal() {
            const modal = document.getElementById('rikkahubRequiredModal');
            if (modal) {
                modal.classList.add('active');
                document.body.style.overflow = 'hidden';
            }
        }

        function closeRikkaHubRequiredModal() {
            const modal = document.getElementById('rikkahubRequiredModal');
            if (modal) {
                modal.classList.remove('active');
            }
            pendingMergeAfterRikkaUpload = false;
            document.body.style.overflow = '';
        }

        function closeRikkaHubRequiredModalOnOverlay(event) {
            if (event.target === event.currentTarget) {
                closeRikkaHubRequiredModal();
            }
        }

        function triggerRikkaHubFilePicker(continueMerge = false) {
            const input = document.getElementById('rikkahubFile');
            if (!input) {
                showError('未找到 RikkaHub 文件选择控件');
                return;
            }

            pendingMergeAfterRikkaUpload = !!continueMerge;
            input.value = '';
            input.click();
        }

        function renderMergeReportList(listElement, items, emptyText) {
            if (!listElement) return;
            listElement.innerHTML = '';
            const safeItems = Array.isArray(items) ? items.filter(item => String(item || '').trim()) : [];
            if (safeItems.length === 0) {
                const li = document.createElement('li');
                li.textContent = emptyText || '暂无数据';
                listElement.appendChild(li);
                return;
            }

            safeItems.forEach(item => {
                const li = document.createElement('li');
                li.textContent = String(item);
                listElement.appendChild(li);
            });
        }

        function openMergeDryRunModal(summaryText, diffLines, warningLines, options = {}) {
            const modal = document.getElementById('mergeDryRunModal');
            const summaryElement = document.getElementById('mergeDryRunSummary');
            const diffList = document.getElementById('mergeDryRunDiffList');
            const warningList = document.getElementById('mergeDryRunWarningList');
            const unknownBlock = document.getElementById('mergeDryRunUnknownBlock');
            const unknownList = document.getElementById('mergeDryRunUnknownList');
            const unknownLines = Array.isArray(options?.unknownLines) ? options.unknownLines : [];
            const unknownTotal = Number(options?.unknownTotal || 0);

            if (summaryElement) {
                summaryElement.textContent = summaryText || '预检完成。';
            }
            renderMergeReportList(diffList, diffLines, '暂无来源差异。');
            renderMergeReportList(warningList, warningLines, '未发现结构风险。');
            if (unknownBlock) {
                unknownBlock.style.display = unknownTotal > 0 ? 'block' : 'none';
            }
            if (unknownTotal > 0) {
                renderMergeReportList(unknownList, unknownLines, '未收集到具体样例。');
            } else {
                renderMergeReportList(unknownList, [], '无无法识别块。');
            }

            if (modal) {
                modal.classList.add('active');
                document.body.style.overflow = 'hidden';
            }
        }

        function closeMergeDryRunModal(confirmMerge = false) {
            const modal = document.getElementById('mergeDryRunModal');
            if (modal) {
                modal.classList.remove('active');
            }
            document.body.style.overflow = '';

            const resolver = pendingMergeDryRunResolver;
            pendingMergeDryRunResolver = null;
            if (typeof resolver === 'function') {
                resolver(confirmMerge === true);
            }
        }

        function closeMergeDryRunModalOnOverlay(event) {
            if (event.target === event.currentTarget) {
                closeMergeDryRunModal(false);
            }
        }

        function requestMergeDryRunConfirmation(summaryText, diffLines, warningLines, options = {}) {
            if (typeof pendingMergeDryRunResolver === 'function') {
                pendingMergeDryRunResolver(false);
                pendingMergeDryRunResolver = null;
            }
            return new Promise(resolve => {
                pendingMergeDryRunResolver = resolve;
                openMergeDryRunModal(summaryText, diffLines, warningLines, options);
            });
        }

        function detectDownloadRisk(sizeBytes) {
            const ua = String(navigator.userAgent || '').toLowerCase();
            const isMobile = /android|iphone|ipad|ipod|mobile/.test(ua);
            const isEdgeMobile = /edga|edgios/.test(ua);
            const deviceMemory = Number(navigator.deviceMemory || 0);
            const lowMemoryDevice = deviceMemory > 0 && deviceMemory <= 4;

            const sizeMB = Math.max(0, Number(sizeBytes || 0)) / (1024 * 1024);
            const isLarge = sizeMB >= 60;
            const isVeryLarge = sizeMB >= 120;
            const isHuge = sizeMB >= 180;

            const shouldWarn = isMobile && (isLarge || lowMemoryDevice);
            const shouldCompactBeforeDownload = isMobile && (isVeryLarge || lowMemoryDevice);
            const preferCompatMode = isEdgeMobile && isLarge;

            const lines = [];
            if (shouldWarn) {
                lines.push(`检测到移动端下载环境，当前下载包约 ${sizeMB.toFixed(1)} MB。`);
                if (isEdgeMobile) {
                    lines.push('Edge 手机版在大文件 Blob 下载时可能出现闪退，建议优先使用兼容下载方式。');
                }
                if (isHuge) {
                    lines.push('包体积较大，建议分批合并后再下载。');
                }
            }

            return {
                isMobile,
                isEdgeMobile,
                deviceMemory,
                lowMemoryDevice,
                sizeMB,
                shouldWarn,
                shouldCompactBeforeDownload,
                preferCompatMode,
                lines
            };
        }

        function releaseLargeCachesBeforeDownload(riskInfo) {
            const released = [];
            const shouldCompact = !!(riskInfo && riskInfo.shouldCompactBeforeDownload);
            if (!shouldCompact) {
                return released;
            }

            if (chatgptImages instanceof Map && chatgptImages.size > 0) {
                const uniqueImagePaths = new Set();
                chatgptImages.forEach(record => {
                    const zipPath = String(record?.zipPath || '').trim();
                    if (zipPath) {
                        uniqueImagePaths.add(zipPath);
                    }
                });
                const imageCount = uniqueImagePaths.size || chatgptImages.size;
                chatgptImages.clear();
                chatgptIndexedImageKeys.clear();
                released.push(`释放 ChatGPT 图片索引 ${imageCount} 项`);
            }
            if (chatgptZip) {
                chatgptZip = null;
                chatgptIndexedImageKeys.clear();
                released.push('释放 ChatGPT ZIP 缓存');
            }
            return released;
        }

        function triggerStandardBlobDownload(url, filename) {
            try {
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.rel = 'noopener';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                return true;
            } catch (error) {
                console.warn('standard blob download failed:', error);
                return false;
            }
        }

        function triggerCompatBlobDownload(url, filename) {
            try {
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.target = '_blank';
                link.rel = 'noopener';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                return true;
            } catch (error) {
                console.warn('compat blob download failed:', error);
                return false;
            }
        }

        function clearPendingMergedDownload() {
            if (pendingMergedDownloadUrl) {
                try {
                    URL.revokeObjectURL(pendingMergedDownloadUrl);
                } catch (e) {
                    console.warn('revoke object url failed:', e);
                }
            }
            pendingMergedDownloadUrl = null;
            pendingMergedDownloadBlob = null;
            pendingMergedDownloadFilename = 'rikka_hub_merged.zip';
            pendingMergedDownloadSize = 0;
            pendingMergedDownloadRisk = null;
        }

        function openMergeDownloadModal() {
            const modal = document.getElementById('mergeDownloadModal');
            if (modal) {
                modal.classList.add('active');
                document.body.style.overflow = 'hidden';
            }
        }

        function closeMergeDownloadModal(discard = false) {
            const modal = document.getElementById('mergeDownloadModal');
            if (modal) {
                modal.classList.remove('active');
            }
            if (discard) {
                clearPendingMergedDownload();
            }
            document.body.style.overflow = '';
        }

        function closeMergeDownloadModalOnOverlay(event) {
            if (event.target === event.currentTarget) {
                closeMergeDownloadModal(true);
            }
        }

        function prepareMergedZipDownload(blob, filename, summaryText, options = {}) {
            clearPendingMergedDownload();
            pendingMergedDownloadBlob = blob || null;
            pendingMergedDownloadFilename = filename || 'rikka_hub_merged.zip';
            pendingMergedDownloadSize = Number(pendingMergedDownloadBlob?.size || 0);
            pendingMergedDownloadRisk = detectDownloadRisk(pendingMergedDownloadSize);
            if (pendingMergedDownloadBlob) {
                pendingMergedDownloadUrl = URL.createObjectURL(pendingMergedDownloadBlob);
            }
            // Object URL 已持有数据引用，释放 JS 层强引用以降低峰值内存
            pendingMergedDownloadBlob = null;

            const summaryElement = document.getElementById('mergeDownloadSummary');
            if (summaryElement) {
                summaryElement.textContent = summaryText || '合并包已准备完成。';
            }
            const riskHint = document.getElementById('mergeDownloadRiskHint');
            const downloadConfirmBtn = document.getElementById('mergeDownloadConfirmBtn');
            if (riskHint) {
                const riskLines = Array.isArray(pendingMergedDownloadRisk?.lines) ? pendingMergedDownloadRisk.lines : [];
                if (riskLines.length > 0) {
                    riskHint.style.display = 'block';
                    riskHint.textContent = riskLines.join(' ');
                } else {
                    riskHint.style.display = 'none';
                    riskHint.textContent = '';
                }
            }
            if (downloadConfirmBtn) {
                downloadConfirmBtn.textContent = pendingMergedDownloadRisk?.preferCompatMode ? '兼容下载' : '下载';
            }

            const diffBlock = document.getElementById('mergeDownloadDiffBlock');
            const diffList = document.getElementById('mergeDownloadDiffList');
            const warningBlock = document.getElementById('mergeDownloadWarningBlock');
            const warningList = document.getElementById('mergeDownloadWarningList');
            const unknownBlock = document.getElementById('mergeDownloadUnknownBlock');
            const unknownList = document.getElementById('mergeDownloadUnknownList');
            const diffLines = Array.isArray(options?.diffLines) ? options.diffLines.filter(Boolean) : [];
            const warningLines = Array.isArray(options?.warningLines) ? options.warningLines.filter(Boolean) : [];
            const unknownLines = Array.isArray(options?.unknownLines) ? options.unknownLines.filter(Boolean) : [];
            const unknownTotal = Number(options?.unknownTotal || 0);

            if (diffBlock) {
                diffBlock.style.display = diffLines.length > 0 ? 'block' : 'none';
            }
            renderMergeReportList(diffList, diffLines, '暂无来源差异。');

            if (warningBlock) {
                warningBlock.style.display = warningLines.length > 0 ? 'block' : 'none';
            }
            renderMergeReportList(warningList, warningLines, '未发现结构风险。');
            if (unknownBlock) {
                unknownBlock.style.display = unknownTotal > 0 ? 'block' : 'none';
            }
            if (unknownTotal > 0) {
                renderMergeReportList(unknownList, unknownLines, '未收集到具体样例。');
            } else {
                renderMergeReportList(unknownList, [], '无无法识别块。');
            }

            openMergeDownloadModal();
        }

        async function downloadMergedZipNow() {
            if (!pendingMergedDownloadUrl) {
                showError('下载包未准备好，请重新执行合并。');
                return;
            }

            const downloadUrl = pendingMergedDownloadUrl;
            const downloadName = pendingMergedDownloadFilename || 'rikka_hub_merged.zip';
            const riskInfo = pendingMergedDownloadRisk || detectDownloadRisk(pendingMergedDownloadSize);

            // 在高风险移动端先释放大缓存，降低下载触发瞬时内存压力
            const released = releaseLargeCachesBeforeDownload(riskInfo);
            if (released.length > 0) {
                showInfo(`${released.join('，')}，正在启动下载...`);
                await new Promise(resolve => setTimeout(resolve, 120));
            }

            let started = false;
            if (riskInfo?.preferCompatMode) {
                started = triggerCompatBlobDownload(downloadUrl, downloadName);
                if (!started) {
                    started = triggerStandardBlobDownload(downloadUrl, downloadName);
                }
            } else {
                started = triggerStandardBlobDownload(downloadUrl, downloadName);
                if (!started) {
                    started = triggerCompatBlobDownload(downloadUrl, downloadName);
                }
            }

            if (!started) {
                try {
                    window.location.assign(downloadUrl);
                    started = true;
                } catch (error) {
                    console.warn('location fallback failed:', error);
                }
            }

            pendingMergedDownloadBlob = null;
            pendingMergedDownloadUrl = null;
            pendingMergedDownloadFilename = 'rikka_hub_merged.zip';
            pendingMergedDownloadSize = 0;
            pendingMergedDownloadRisk = null;
            setTimeout(() => {
                try {
                    URL.revokeObjectURL(downloadUrl);
                } catch (e) {
                    console.warn('revoke object url failed:', e);
                }
            }, 1800);

            closeMergeDownloadModal(false);
            if (started) {
                showInfo('已开始下载合并包。');
            } else {
                showError('下载启动失败，请改用桌面浏览器或分批合并后重试。');
            }
        }

        // 主题切换函数
        function applyTheme(themeId, element) {
            currentTheme = themeId;
            const themeData = presetThemes[themeId];
            
            if (!themeData) {
                console.error('Theme not found:', themeId);
                return;
            }
            
            const theme = isDarkMode ? themeData.dark : themeData.light;
            
            // 更新 CSS 变量
            const root = document.documentElement;
            root.style.setProperty('--md-sys-color-primary', theme.primary);
            root.style.setProperty('--md-sys-color-on-primary', theme.onPrimary);
            root.style.setProperty('--md-sys-color-primary-container', theme.primaryContainer);
            root.style.setProperty('--md-sys-color-on-primary-container', theme.onPrimaryContainer);
            root.style.setProperty('--md-sys-color-secondary', theme.secondary);
            root.style.setProperty('--md-sys-color-on-secondary', theme.onSecondary);
            root.style.setProperty('--md-sys-color-secondary-container', theme.secondaryContainer);
            root.style.setProperty('--md-sys-color-on-secondary-container', theme.onSecondaryContainer);
            root.style.setProperty('--md-sys-color-tertiary', theme.tertiary);
            root.style.setProperty('--md-sys-color-on-tertiary', theme.onTertiary);
            root.style.setProperty('--md-sys-color-tertiary-container', theme.tertiaryContainer);
            root.style.setProperty('--md-sys-color-on-tertiary-container', theme.onTertiaryContainer);
            root.style.setProperty('--md-sys-color-background', theme.background);
            root.style.setProperty('--md-sys-color-on-background', theme.onBackground);
            root.style.setProperty('--md-sys-color-surface', theme.surface);
            root.style.setProperty('--md-sys-color-on-surface', theme.onSurface);
            root.style.setProperty('--md-sys-color-surface-variant', theme.surfaceVariant);
            root.style.setProperty('--md-sys-color-on-surface-variant', theme.onSurfaceVariant);
            root.style.setProperty('--md-sys-color-outline', theme.outline);
            root.style.setProperty('--md-sys-color-surface-container', theme.surfaceContainer);
            root.style.setProperty('--md-sys-color-surface-container-high', theme.surfaceContainerHigh);
            root.style.setProperty('--md-sys-color-surface-container-highest', theme.surfaceContainerHighest);
            
            // 更新选中状态
            document.querySelectorAll('.theme-card').forEach(card => {
                card.classList.remove('active');
            });
            const activeCard = element || document.querySelector(`.theme-card[data-theme="${themeId}"]`);
            if (activeCard) {
                activeCard.classList.add('active');
            }
            
            console.log('Theme applied:', themeId, 'Dark mode:', isDarkMode);
        }

        // 切换深色/浅色模式
        function toggleDarkMode() {
            isDarkMode = !isDarkMode;
            applyTheme(currentTheme);
            
            // 更新按钮文字
            const btn = document.getElementById('darkModeToggle');
            btn.textContent = isDarkMode ? '☀️ 切换到浅色模式' : '🌙 切换到深色模式';
        }

        // Toast 提示函数
        function showToast(title, message, type = 'info', duration = 8000) {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;

            const iconMap = {
                success: '✅',
                error: '❌',
                info: 'ℹ️',
                warning: '⚠️'
            };

            toast.innerHTML = `
                <span class="toast-icon">${iconMap[type] || iconMap.info}</span>
                <div class="toast-content">
                    <div class="toast-title">${title}</div>
                    <div class="toast-message">${message}</div>
                </div>
                <button class="toast-close" onclick="dismissToast(this)">×</button>
            `;

            container.appendChild(toast);

            // 自动消失（8秒后）
            setTimeout(() => {
                dismissToast(toast.querySelector('.toast-close'));
            }, duration);
        }

        function dismissToast(closeBtn) {
            const toast = closeBtn.closest('.toast');
            if (toast && !toast.classList.contains('hiding')) {
                toast.classList.add('hiding');
                setTimeout(() => {
                    if (toast.parentElement) {
                        toast.parentElement.removeChild(toast);
                    }
                }, 300);
            }
        }

        // 自定义下拉框控制函数
        function toggleSelect() {
            const wrapper = document.getElementById('dataSourceWrapper');
            const dropdown = document.getElementById('selectDropdown');
            wrapper.classList.toggle('open');
            dropdown.classList.toggle('show');
        }

        function selectOption(value, text) {
            const selectedValue = document.getElementById('selectedValue');
            selectedValue.textContent = text;
            
            const wrapper = document.getElementById('dataSourceWrapper');
            const dropdown = document.getElementById('selectDropdown');
            wrapper.classList.remove('open');
            dropdown.classList.remove('show');
            
            // 更新选中状态
            document.querySelectorAll('.select-option').forEach(option => {
                option.classList.remove('selected');
                if (option.dataset.value === value) {
                    option.classList.add('selected');
                }
            });
            
            // 切换来源时保留各来源已导入会话，不清空工作台
            saveCurrentSourceBuffersToPool();
            currentDataSource = value;
            loadSourceBuffersFromPool(currentDataSource);
            updateDataSourceUIInternal(value);
        }

        // 点击外部关闭下拉框
        document.addEventListener('click', function(event) {
            const wrapper = document.getElementById('dataSourceWrapper');
            if (wrapper && !wrapper.contains(event.target)) {
                wrapper.classList.remove('open');
                document.getElementById('selectDropdown').classList.remove('show');
            }
        });

        // ESC 键关闭弹窗
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeModalDirect('usage');
                closeModalDirect('support');
                closeModalDirect('about');
                closeRikkaHubRequiredModal();
                closeMergeDownloadModal(true);
                closeWorkspacePreviewModal();
            }
        });

        async function initSQL() {
            if (!db) {
                const SQL = await initSqlJs({
                    locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
                });
                db = SQL;
            }
        }

        function toggleGuide() {
            const content = document.getElementById('guideContent');
            const toggle = document.getElementById('guideToggle');

            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                toggle.classList.remove('collapsed');
            } else {
                content.classList.add('collapsed');
                toggle.classList.add('collapsed');
            }
        }

        // 页面加载时默认折叠指南
        document.addEventListener('DOMContentLoaded', function() {
            const content = document.getElementById('guideContent');
            const toggle = document.getElementById('guideToggle');
            if (content && toggle) {
                content.classList.add('collapsed');
                toggle.classList.add('collapsed');
            }
            applyTheme(currentTheme);
            const darkModeButton = document.getElementById('darkModeToggle');
            if (darkModeButton) {
                darkModeButton.textContent = isDarkMode ? '☀️ 切换到浅色模式' : '🌙 切换到深色模式';
            }
            setDuplicateStrategy(getDuplicateStrategy());
            setAssistantMergeStrategy(getAssistantMergeStrategy());
            updateAssistantMergeStrategyUI();
        });

        function updateDataSourceUI() {
            // 保留兼容性：如果存在原生 select，使用它的值
            const nativeSelect = document.getElementById('dataSource');
            if (nativeSelect) {
                saveCurrentSourceBuffersToPool();
                currentDataSource = nativeSelect.value;
                loadSourceBuffersFromPool(currentDataSource);
            }
            updateDataSourceUIInternal(currentDataSource);
        }

        function updateDataSourceUIInternal(dataSource) {
            const sourceText = document.getElementById('sourceUploadText');
            const sourceFileInput = document.getElementById('sourceFile');
            const sourceUploadBox = document.getElementById('sourceUpload');
            const deepseekSecondCard = document.getElementById('deepseekSecondCard');
            const pasteButtons = document.getElementById('pasteButtons');

            // 仅重置当前导入控件展示，不清空已导入会话
            sourceUploadBox.classList.remove('has-file', 'error');
            const sourceFileInfo = document.getElementById('sourceFileInfo');
            if (sourceFileInfo) {
                const currentPrimaryCount = Array.isArray(sourceData) ? sourceData.length : 0;
                sourceFileInfo.textContent = currentPrimaryCount > 0 ? `当前来源已加载 ${currentPrimaryCount} 个会话` : '';
            }

            const deepseekSecondUpload = document.getElementById('deepseekSecondUpload');
            const deepseekSecondFileInfo = document.getElementById('deepseekSecondFileInfo');
            if (deepseekSecondUpload && deepseekSecondFileInfo) {
                deepseekSecondUpload.classList.remove('has-file', 'error');
                const currentSecondaryCount = Array.isArray(secondSourceData) ? secondSourceData.length : 0;
                deepseekSecondFileInfo.textContent = currentSecondaryCount > 0 ? `已加载旧版 ${currentSecondaryCount} 个会话` : '';
            }

            // 隐藏粘贴按钮
            if (pasteButtons) pasteButtons.style.display = 'none';

            if (dataSource === 'chatgpt') {
                sourceText.textContent = '点击或拖拽上传 ChatGPT 压缩包';
                sourceFileInput.accept = '.zip';
                sourceFileInput.disabled = false;  // 启用文件输入
                sourceUploadBox.style.display = 'block';  // 显示上传框
                if (deepseekSecondCard) deepseekSecondCard.style.display = 'none';
            } else if (dataSource === 'youraiscroll') {
                sourceText.textContent = '粘贴 YourAIScroll 复制的 Markdown 内容';
                sourceFileInput.accept = '';
                sourceFileInput.disabled = true;  // 禁用文件输入
                sourceUploadBox.style.display = 'none';  // 隐藏上传框
                if (deepseekSecondCard) deepseekSecondCard.style.display = 'none';
                // 显示粘贴按钮
                if (pasteButtons) pasteButtons.style.display = 'flex';
            } else if (dataSource === 'deepseek') {
                sourceText.textContent = '点击或拖拽上传 DeepSeek 新版压缩包（包含 conversations.json）';
                sourceFileInput.accept = '.zip';
                sourceFileInput.disabled = false;  // 启用文件输入
                sourceUploadBox.style.display = 'block';  // 显示上传框
                if (deepseekSecondCard) deepseekSecondCard.style.display = 'block';
            }

            rebuildWorkspaceFromCurrentSource();
            checkReady();
        }

        function handleSourceFile(input) {
            const file = input.files[0];
            const uploadBox = document.getElementById('sourceUpload');
            const fileInfo = document.getElementById('sourceFileInfo');

            if (file) {
                // 清空当前来源之前的导入状态（不影响其他来源）
                sourceData = null;
                secondSourceData = null;
                if (currentDataSource === 'chatgpt') {
                    chatgptZip = null;
                    chatgptImages.clear();
                    chatgptIndexedImageKeys.clear();
                }
                saveCurrentSourceBuffersToPool();
                rebuildWorkspaceFromCurrentSource();
                uploadBox.classList.remove('has-file', 'error');
                checkReady();

                // 验证文件类型
                if (currentDataSource === 'youraiscroll') {
                    if (!file.name.endsWith('.json')) {
                        showError('文件必须是 .json 格式');
                        uploadBox.classList.add('error');
                        return;
                    }
                } else {
                    if (currentDataSource === 'youraiscroll') {
                        showError('YourAIScroll 数据源不支持文件上传，请使用粘贴 Markdown 功能');
                        uploadBox.classList.add('error');
                        return;
                    } else if (!file.name.endsWith('.zip') && !file.name.endsWith('.csv')) {
                        showError('文件必须是 .zip 或 .csv 格式');
                        uploadBox.classList.add('error');
                        return;
                    }
                }

                fileInfo.textContent = file.name + ' (' + formatFileSize(file.size) + ')';
                
                // 添加加载动画
                uploadBox.classList.add('loading', 'has-wave');
                fileInfo.innerHTML = `<span class="circular-wavy-loading"><span class="wave"></span><span class="wave"></span><span class="wave"></span></span> 读取中...`;

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        if (currentDataSource === 'chatgpt') {
                            await handleChatGPTFileInternal(e.target.result, uploadBox, fileInfo, file.name);
                        } else if (currentDataSource === 'deepseek') {
                            await handleDeepSeekNewFile(e.target.result, uploadBox, fileInfo, file.name);
                        } else if (currentDataSource === 'youraiscroll') {
                            showError('YourAIScroll 数据源已移除，请使用粘贴 Markdown 功能');
                            uploadBox.classList.remove('loading', 'has-wave');
                            fileInfo.textContent = file.name + ' (' + formatFileSize(file.size) + ')';
                            uploadBox.classList.add('error');
                            return;
                        }
                    } catch (error) {
                        console.error('文件处理错误:', error);
                        let errorMsg = '读取文件失败: ' + error.message;
                        if (error.message.includes('end of central directory')) {
                            errorMsg = '文件不是有效的 ZIP 文件或文件已损坏。';
                        } else if (error.message.includes('JSON')) {
                            errorMsg = '文件中的 JSON 格式错误。';
                        }
                        // 移除加载状态
                        uploadBox.classList.remove('loading', 'has-wave');
                        fileInfo.textContent = file.name + ' (' + formatFileSize(file.size) + ')';
                        showError(errorMsg);
                        uploadBox.classList.add('error');
                    }
                };

                reader.onerror = function() {
                    // 移除加载状态
                    uploadBox.classList.remove('loading', 'has-wave');
                    fileInfo.textContent = file.name + ' (' + formatFileSize(file.size) + ')';
                    showError('读取文件时发生错误');
                    uploadBox.classList.add('error');
                };

                // 根据数据源类型使用不同的读取方法
                reader.readAsArrayBuffer(file);
            }
        }

        async function handleChatGPTFileInternal(arrayBuffer, uploadBox, fileInfo, fileName) {
            // 验证ZIP文件签名
            const data = new Uint8Array(arrayBuffer);
            if (data.length < 4) {
                uploadBox.classList.remove('loading', 'has-wave');
                showError('文件太小，不是有效的 ZIP 文件');
                uploadBox.classList.add('error');
                return;
            }

            const signature = String.fromCharCode(data[0], data[1]);
            if (signature !== 'PK') {
                uploadBox.classList.remove('loading', 'has-wave');
                fileInfo.textContent = fileName + ' (' + formatFileSize(arrayBuffer.byteLength) + ')';
                showError('文件不是有效的 ZIP 文件');
                uploadBox.classList.add('error');
                return;
            }

            chatgptZip = await JSZip.loadAsync(arrayBuffer);
            const files = Object.keys(chatgptZip.files);

            // 查找 conversations.json
            const convFile = files.find(f => f.includes('conversations.json'));
            if (!convFile) {
                uploadBox.classList.remove('loading', 'has-wave');
                fileInfo.textContent = fileName + ' (' + formatFileSize(arrayBuffer.byteLength) + ')';
                showError('压缩包中未找到 conversations.json 文件。请确保上传的是正确的 ChatGPT 导出文件。');
                uploadBox.classList.add('error');
                return;
            }

            const content = await chatgptZip.file(convFile).async('string');
            sourceData = JSON.parse(content);

            // 图片索引延迟到合并阶段，避免导入阶段扫整包导致移动端内存峰值过高
            chatgptImages.clear();
            chatgptIndexedImageKeys.clear();
            const requiredImageKeys = collectChatGPTAssetPointerKeysFromConversations(sourceData);
            const imageMsg = requiredImageKeys.size > 0
                ? `，检测到 ${requiredImageKeys.size} 个图片引用（将在合并时按需索引）`
                : '';
            
            // 移除加载状态
            uploadBox.classList.remove('loading', 'has-wave');
            fileInfo.textContent = fileName + ' (' + formatFileSize(arrayBuffer.byteLength) + ')';
            
            showInfo(`已加载 ${sourceData.length} 个 ChatGPT 对话${imageMsg}`);
            saveCurrentSourceBuffersToPool();
            rebuildWorkspaceFromCurrentSource();
            checkReady();
            const mergeButton = document.getElementById('mergeButton');
            if (rikkahubData) {
                mergeButton.textContent = '合并聊天记录';
            }
        }

        // 获取 MIME 类型
        function getMimeType(fileName) {
            const ext = fileName.toLowerCase().substring(fileName.lastIndexOf('.'));
            switch (ext) {
                case '.jpg':
                case '.jpeg':
                    return 'image/jpeg';
                case '.png':
                    return 'image/png';
                case '.gif':
                    return 'image/gif';
                case '.webp':
                    return 'image/webp';
                case '.bmp':
                    return 'image/bmp';
                case '.avif':
                    return 'image/avif';
                default:
                    return 'application/octet-stream';
            }
        }

        function safeDecodeURIComponent(text) {
            try {
                return decodeURIComponent(text);
            } catch (_) {
                return text;
            }
        }

        function getChatGPTCanonicalImageKey(rawInput) {
            const raw = String(rawInput || '').trim();
            if (!raw) return '';

            let normalized = raw
                .replace(/^file-service:\/\//i, '')
                .replace(/^sediment:\/\//i, '')
                .split('?')[0]
                .split('#')[0]
                .trim();
            normalized = safeDecodeURIComponent(normalized);
            if (!normalized) return '';

            const fileName = normalized.includes('/') ? normalized.substring(normalized.lastIndexOf('/') + 1) : normalized;
            const dotIndex = fileName.lastIndexOf('.');
            const baseName = dotIndex >= 0 ? fileName.substring(0, dotIndex) : fileName;
            if (!baseName) return '';

            if (baseName.startsWith('file-')) {
                const parts = baseName.split('-');
                if (parts.length >= 2) {
                    return `${parts[0]}-${parts[1]}`;
                }
            }

            if (baseName.startsWith('file_')) {
                const parts = baseName.split('-');
                if (parts.length >= 1) {
                    return parts[0];
                }
            }

            return baseName;
        }

        function collectChatGPTAssetPointerKeysFromConversations(conversations) {
            const keySet = new Set();
            if (!Array.isArray(conversations) || conversations.length === 0) {
                return keySet;
            }

            conversations.forEach(conv => {
                const mapping = conv && typeof conv.mapping === 'object' ? conv.mapping : null;
                if (!mapping) return;
                Object.keys(mapping).forEach(nodeId => {
                    const node = mapping[nodeId];
                    const parts = node?.message?.content?.parts;
                    if (!Array.isArray(parts)) return;
                    parts.forEach(part => {
                        if (!part || typeof part !== 'object') return;
                        if (part.content_type === 'image_asset_pointer' && part.asset_pointer) {
                            const key = getChatGPTCanonicalImageKey(part.asset_pointer);
                            if (key) {
                                keySet.add(key);
                            }
                        }
                    });
                });
            });

            return keySet;
        }

        function collectChatGPTAssetPointerKeysFromBindings(bindings) {
            const keySet = new Set();
            if (!Array.isArray(bindings) || bindings.length === 0) {
                return keySet;
            }

            bindings.forEach(binding => {
                const sourceType = binding?.item?.dataSource || currentDataSource;
                if (sourceType !== 'chatgpt') return;
                const conv = binding?.conversation;
                const mapping = conv && typeof conv.mapping === 'object' ? conv.mapping : null;
                if (!mapping) return;

                Object.keys(mapping).forEach(nodeId => {
                    const parts = mapping[nodeId]?.message?.content?.parts;
                    if (!Array.isArray(parts)) return;
                    parts.forEach(part => {
                        if (!part || typeof part !== 'object') return;
                        if (part.content_type === 'image_asset_pointer' && part.asset_pointer) {
                            const key = getChatGPTCanonicalImageKey(part.asset_pointer);
                            if (key) keySet.add(key);
                        }
                    });
                });
            });

            return keySet;
        }

        async function ensureChatGPTImageIndexForBindings(bindings) {
            if (!chatgptZip || typeof chatgptZip.file !== 'function') {
                return { required: 0, indexed: 0, missing: 0 };
            }

            const requiredKeys = collectChatGPTAssetPointerKeysFromBindings(bindings);
            if (requiredKeys.size === 0) {
                return { required: 0, indexed: 0, missing: 0 };
            }

            const missingKeys = new Set();
            requiredKeys.forEach(key => {
                if (!chatgptIndexedImageKeys.has(key)) {
                    missingKeys.add(key);
                }
            });
            if (missingKeys.size === 0) {
                return { required: requiredKeys.size, indexed: requiredKeys.size, missing: 0 };
            }

            const files = Object.keys(chatgptZip.files || {});
            const imageExtensions = new Set(['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.avif']);
            let scanned = 0;

            for (const zipPath of files) {
                if (missingKeys.size === 0) break;
                const entry = chatgptZip.file(zipPath);
                if (!entry || entry.dir) continue;

                const normalizedPath = String(zipPath || '');
                const dotIndex = normalizedPath.lastIndexOf('.');
                if (dotIndex < 0) continue;

                const ext = normalizedPath.slice(dotIndex).toLowerCase();
                if (!imageExtensions.has(ext)) continue;

                const canonicalKey = getChatGPTCanonicalImageKey(normalizedPath);
                if (!canonicalKey || !missingKeys.has(canonicalKey)) {
                    continue;
                }

                chatgptImages.set(canonicalKey, {
                    zipPath: normalizedPath,
                    mimeType: getMimeType(normalizedPath)
                });
                chatgptIndexedImageKeys.add(canonicalKey);
                missingKeys.delete(canonicalKey);
                scanned++;

                if (scanned % 20 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            return {
                required: requiredKeys.size,
                indexed: requiredKeys.size - missingKeys.size,
                missing: missingKeys.size
            };
        }

        function resolveChatGPTImageRecord(assetPointer) {
            if (!(chatgptImages instanceof Map) || chatgptImages.size === 0) {
                return null;
            }
            const canonicalKey = getChatGPTCanonicalImageKey(assetPointer);
            if (!canonicalKey) return null;
            return chatgptImages.get(canonicalKey) || null;
        }

        function buildYourAIScrollConversationKey(youraiData, platform) {
            const safeData = youraiData && typeof youraiData === 'object' ? youraiData : {};
            const messageList = Array.isArray(safeData.messages) ? safeData.messages : [];
            const messageSignature = messageList.map((msg, index) => {
                const role = normalizeMessageRole(msg?.role) || String(msg?.role || 'unknown').toLowerCase();
                let content = '';
                if (typeof msg?.content === 'string') {
                    content = msg.content;
                } else if (msg?.content != null) {
                    try {
                        content = JSON.stringify(msg.content);
                    } catch (e) {
                        content = String(msg.content);
                    }
                } else if (typeof msg?.text === 'string') {
                    content = msg.text;
                }
                return `${index}|${role}|${content}`;
            }).join('\n');

            return [
                platform || 'unknown',
                safeData.url || '',
                safeData.title || '',
                messageSignature
            ].join('\n');
        }

        function convertYourAIScrollToRikkaHub(youraiData) {
            const platform = youraiData.platform || extractPlatformFromUrl(youraiData.url);
            const timestamp = youraiData.timestamp || youraiData.createdAt || new Date().toISOString();
            const messageList = Array.isArray(youraiData.messages) ? youraiData.messages : [];
            const sourceKey = buildYourAIScrollConversationKey(youraiData, platform);
            const conversationId = deterministicUuidFromString(`youraiscroll|${sourceKey}`);
            const createAtSeconds = Math.floor(new Date(timestamp).getTime() / 1000);
            const safeCreateAtSeconds = Number.isFinite(createAtSeconds)
                ? createAtSeconds
                : Math.floor(Date.now() / 1000);

            return [{
                id: conversationId,
                assistant_id: null,
                title: youraiData.title || `${getPlatformName(platform) || 'YourAIScroll'} 对话`,
                nodes: '[]',
                create_at: safeCreateAtSeconds,
                update_at: safeCreateAtSeconds,
                truncate: 0,
                suggestions: null,
                is_pinned: 0,
                platform: platform,
                _sourceKey: sourceKey,
                _rawMessages: messageList
                    .map((msg, index) => convertYourAIScrollMessage(msg, timestamp, platform, index))
                    .filter(Boolean)
            }];
        }

        function convertYourAIScrollMessage(msg, conversationTimestamp, platform, messageIndex) {
            const safeMsg = msg && typeof msg === 'object' ? msg : {};

            // 处理消息时间戳
            // YourAIScroll 格式: 消息可能有自己的 timestamp 或 createdAt 字段
            // 如果没有，则基于对话时间戳和消息索引生成
            let messageTimestamp = safeMsg.timestamp || safeMsg.createdAt;
            if (!messageTimestamp) {
                // 基于对话时间戳和消息索引生成，每条消息间隔 1 秒
                const baseTime = new Date(conversationTimestamp).getTime();
                const fallbackBaseTime = Number.isFinite(baseTime) ? baseTime : Date.now();
                messageTimestamp = new Date(fallbackBaseTime + (messageIndex * 1000)).toISOString();
            }

            let rawContent = '';
            if (typeof safeMsg.content === 'string') {
                rawContent = safeMsg.content;
            } else if (safeMsg.content == null) {
                rawContent = '';
            } else {
                try {
                    rawContent = JSON.stringify(safeMsg.content);
                } catch (error) {
                    rawContent = String(safeMsg.content);
                }
            }

            // 启用结构化解析，避免“UI 声称支持但实际未生效”
            let parts = [];
            try {
                parts = parseYourAIScrollContent(rawContent, platform, messageTimestamp);
            } catch (error) {
                console.warn('parseYourAIScrollContent failed, fallback to plain text:', error);
            }
            if (!Array.isArray(parts) || parts.length === 0) {
                parts = [{
                    type: 'me.rerere.ai.ui.UIMessagePart.Text',
                    text: rawContent,
                    metadata: null,
                    priority: 0
                }];
            }

            // 格式化时间戳
            const formattedTimestamp = formatTimestampForRikka(messageTimestamp);

            return {
                id: generateUUID(),
                role: normalizeYourAIScrollRole(safeMsg.role),
                parts: parts,
                annotations: [],
                createdAt: formattedTimestamp, // 与 ChatGPT/DeepSeek 保持一致
                finishedAt: null,
                modelId: null,
                usage: null,
                translation: null
            };
        }

        function normalizeYourAIScrollRole(role) {
            const normalized = String(role || '').trim().toLowerCase();
            if (normalized === 'assistant' || normalized === 'model' || normalized === 'ai' || normalized === 'bot') {
                return 'assistant';
            }
            if (normalized === 'system' || normalized === 'tool') {
                return normalized;
            }
            if (normalized === 'user' || normalized === 'human') {
                return 'user';
            }
            return 'user';
        }
        
        // 辅助函数：格式化时间戳为 RikkaHub 格式
        // 与 ChatGPT/DeepSeek 的处理保持一致
        function formatTimestampForRikka(timestamp) {
            if (!timestamp) {
                return new Date().toISOString().slice(0, -1);
            }
            
            try {
                let date;
                
                if (typeof timestamp === 'number') {
                    // 数字时间戳 - 可能是秒级或毫秒级
                    // 如果数字小于 1e10，认为是秒级（Unix 时间戳）
                    // 如果数字大于 1e10，认为是毫秒级
                    if (timestamp < 1e10) {
                        date = new Date(timestamp * 1000);
                    } else {
                        date = new Date(timestamp);
                    }
                } else if (typeof timestamp === 'string') {
                    // 字符串 - 可能是 ISO 8601 格式或其他日期格式
                    date = new Date(timestamp);
                } else {
                    // 其他类型，尝试直接转换
                    date = new Date(timestamp);
                }
                
                // 检查日期是否有效
                if (isNaN(date.getTime())) {
                    console.warn('Invalid timestamp:', timestamp);
                    return new Date().toISOString().slice(0, -1);
                }
                
                // 格式化为与其他助手完全相同的格式：YYYY-MM-DDTHH:mm:ss.ffffff
                // 确保有 6 位小数
                return date.toISOString().slice(0, -1).replace(/\.(\d{1,6})Z?$/, (match, p1) => {
                    const padLength = 6 - p1.length;
                    return '.' + p1 + '0'.repeat(padLength);
                });
            } catch (e) {
                console.warn('Error parsing timestamp:', timestamp, e);
                return new Date().toISOString().slice(0, -1).replace(/\.(\d{1,6})Z?$/, (match, p1) => {
                    const padLength = 6 - p1.length;
                    return '.' + p1 + '0'.repeat(padLength);
                });
            }
        }
        
        function parseYourAIScrollContent(content, platform, messageTimestamp) {
            const parts = [];
            
            // 处理 content 类型
            if (content == null) {
                content = '';
            } else if (typeof content !== 'string') {
                try {
                    content = JSON.stringify(content);
                } catch (error) {
                    content = String(content);
                }
            }
            
            // 格式化时间戳用于 Reasoning
            const reasoningTimestamp = messageTimestamp ? formatTimestampForRikka(messageTimestamp) : new Date().toISOString().slice(0, -1);
            
            // 提取思维链（特定平台的格式）
            const reasoningContent = extractReasoningContent(content, platform);
            if (reasoningContent) {
                parts.push({
                    type: 'me.rerere.ai.ui.UIMessagePart.Reasoning',
                    reasoning: reasoningContent,
                    createdAt: reasoningTimestamp,
                    finishedAt: reasoningTimestamp,
                    metadata: null,
                    priority: -1
                });
            }
            
            // 提取工具调用
            const toolCalls = extractToolCalls(content);
            toolCalls.forEach(toolCall => {
                parts.push({
                    type: 'me.rerere.ai.ui.UIMessagePart.ToolCall',
                    toolCallId: toolCall.id,
                    toolName: toolCall.name,
                    arguments: toolCall.arguments,
                    metadata: null,
                    priority: 0
                });
            });
            
            // 提取图片
            const images = extractImages(content);
            images.forEach(img => {
                parts.push({
                    type: 'me.rerere.ai.ui.UIMessagePart.Image',
                    url: img.url,
                    metadata: null,
                    priority: 1
                });
            });
            
            // 提取文档引用（作为文本的一部分）
            const docReferences = extractDocumentReferences(content);
            docReferences.forEach(ref => {
                parts.push({
                    type: 'me.rerere.ai.ui.UIMessagePart.Text',
                    text: ref.text,
                    metadata: { type: 'document_reference', url: ref.url, title: ref.title },
                    priority: 0
                });
            });
            
            // 移除已处理的特殊内容，保留纯文本
            let cleanContent = content;
            cleanContent = removeReasoningContent(cleanContent, platform);
            cleanContent = removeToolCalls(cleanContent);
            cleanContent = removeImages(cleanContent);
            cleanContent = removeDocumentReferences(cleanContent);
            
            // 添加文本部分（即使内容为空也要添加）
            if (cleanContent.trim()) {
                parts.push({
                    type: 'me.rerere.ai.ui.UIMessagePart.Text',
                    text: cleanContent,
                    metadata: null,
                    priority: 0
                });
            } else if (parts.length === 0) {
                // 如果没有有效的部分且清理后内容为空，添加原始内容（可能是空字符串）
                parts.push({
                    type: 'me.rerere.ai.ui.UIMessagePart.Text',
                    text: content || '',
                    metadata: null,
                    priority: 0
                });
            }
            
            return parts;
        }
        
        function extractReasoningContent(content, platform) {
            // DeepSeek 思维链格式
            if (content.includes('Thinking Process:') || content.includes('思考过程:')) {
                const match = content.match(/(?:Thinking Process:|思考过程:)\s*([\s\S]*?)(?=\n\n|Answer:|回答:|$)/i);
                return match ? match[1].trim() : null;
            }
            
            // Grok 思维链格式
            if (content.includes('Reasoning:')) {
                const match = content.match(/Reasoning:\s*([\s\S]*?)(?=\n\n|Answer:|$)/i);
                return match ? match[1].trim() : null;
            }
            
            // Claude 思维链格式（可能包含在特殊标签中）
            if (content.includes('<thinking>')) {
                const match = content.match(/<thinking>([\s\S]*?)<\/thinking>/i);
                return match ? match[1].trim() : null;
            }
            
            return null;
        }
        
        function removeReasoningContent(content, platform) {
            // 移除各种格式的思维链
            content = content.replace(/(?:Thinking Process:|思考过程:)\s*([\s\S]*?)(?=\n\n|Answer:|回答:|$)/gi, '');
            content = content.replace(/Reasoning:\s*([\s\S]*?)(?=\n\n|Answer:|$)/gi, '');
            content = content.replace(/<thinking>([\s\S]*?)<\/thinking>/gi, '');
            return content;
        }
        
        function extractToolCalls(content) {
            const toolCalls = [];
            
            // 仅匹配显式 Function 语法，避免把中文常见【】文本误判为工具调用
            const toolCallPattern = /(?:^|\n)\s*Function:\s*([A-Za-z0-9_.-]+)\(([^)]*)\)/g;
            let match;
            while ((match = toolCallPattern.exec(content)) !== null) {
                toolCalls.push({
                    id: generateUUID(),
                    name: match[1],
                    arguments: match[2]
                });
            }
            
            return toolCalls;
        }
        
        function removeToolCalls(content) {
            content = content.replace(/(?:^|\n)\s*Function:\s*([A-Za-z0-9_.-]+)\(([^)]*)\)\s*/g, '\n');
            return content;
        }
        
        function extractImages(content) {
            const images = [];
            
            // 匹配 Markdown 图片格式
            const imagePattern = /!\[([^\]]*)\]\(([^)]+)\)/g;
            let match;
            while ((match = imagePattern.exec(content)) !== null) {
                const url = match[2];
                // 如果是外部 URL，保持原样；如果是相对路径，可能需要处理
                images.push({
                    url: url,
                    alt: match[1]
                });
            }
            
            return images;
        }
        
        function removeImages(content) {
            // 移除 Markdown 图片格式
            content = content.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '');
            return content;
        }
        
        function extractDocumentReferences(content) {
            const references = [];
            
            // 匹配文档链接格式 [文档名称](URL)
            const linkPattern = /\[([^\]]+)\]\(([^)]+)\)/g;
            let match;
            while ((match = linkPattern.exec(content)) !== null) {
                const text = match[1];
                const url = match[2];
                
                // 判断是否是文档引用（而不是普通链接）
                if (isDocumentUrl(url)) {
                    references.push({
                        text: `[${text}](${url})`,
                        url: url,
                        title: text
                    });
                }
            }
            
            return references;
        }
        
        function isDocumentUrl(url) {
            // 判断 URL 是否是文档引用
            const docExtensions = ['.pdf', '.doc', '.docx', '.txt', '.md', '.html', '.htm'];
            const lowerUrl = url.toLowerCase();
            return docExtensions.some(ext => lowerUrl.includes(ext)) || 
                   lowerUrl.includes('drive.google.com') ||
                   lowerUrl.includes('docs.google.com') ||
                   lowerUrl.includes('sharepoint.com') ||
                   lowerUrl.includes('onedrive.com');
        }
        
        function removeDocumentReferences(content) {
            // 移除文档引用（已经提取为单独的部分），避免重复渲染
            if (!content) return '';
            return content.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (fullMatch, text, url) => {
                return isDocumentUrl(url) ? '' : fullMatch;
            });
        }

        function extractPlatformFromUrl(url) {
            if (!url) return 'unknown';
            if (url.includes('chatgpt.com')) return 'chatgpt';
            if (url.includes('chat.openai.com')) return 'chatgpt';
            if (url.includes('claude.ai')) return 'claude';
            if (url.includes('deepseek.com')) return 'deepseek';
            if (url.includes('gemini.google.com')) return 'gemini';
            if (url.includes('aistudio.google.com')) return 'google-aistudio';
            if (url.includes('grok.com')) return 'grok';
            if (url.includes('kimi.com')) return 'kimi';
            if (url.includes('chat.mistral.ai')) return 'mistral';
            if (url.includes('copilot.microsoft.com')) return 'copilot';
            if (url.includes('github.com/copilot')) return 'github-copilot';
            if (url.includes('perplexity.ai')) return 'perplexity';
            if (url.includes('poe.com')) return 'poe';
            return 'unknown';
        }
        
        function getPlatformName(platform) {
            const platformNames = {
                'chatgpt': 'ChatGPT',
                'claude': 'Claude',
                'deepseek': 'DeepSeek',
                'gemini': 'Gemini',
                'google-aistudio': 'Google AI Studio',
                'grok': 'Grok',
                'kimi': 'Kimi',
                'mistral': 'Mistral',
                'copilot': 'Microsoft Copilot',
                'github-copilot': 'GitHub Copilot',
                'perplexity': 'Perplexity',
                'poe': 'Poe'
            };
                        return platformNames[platform] || platform;
                    }
            
                    // 粘贴功能相关变量
                    // 打开粘贴对话框
                    function openPasteModal() {
                        const modal = document.getElementById('pasteModal');
                        const title = document.getElementById('pasteModalTitle');
                        const hint = document.getElementById('pasteModalHint');
                        const textarea = document.getElementById('pasteTextArea');
            
                        // 清空文本框
                        textarea.value = '';
            
                        // 设置标题和提示
                        title.textContent = '📝 粘贴 Markdown 文本';
                        hint.textContent = '请粘贴 YourAIScroll 复制的 Markdown 内容（每次一个对话，确认后会追加到会话工作台）：';
            
                        // 显示对话框
                        modal.classList.add('active');
                        textarea.focus();
                    }
            
                    // 关闭粘贴对话框
                    function closePasteModal() {
                        const modal = document.getElementById('pasteModal');
                        modal.classList.remove('active');
                    }
            
                    // 处理粘贴
                    async function handlePaste() {
                        const textarea = document.getElementById('pasteTextArea');
                        const content = textarea.value.trim();

                        if (!content) {
                            showError('请输入内容');
                            return;
                        }

                        const uploadBox = document.getElementById('sourceUpload');
                        const fileInfo = document.getElementById('sourceFileInfo');

                        try {
                            // 显示加载状态
                            uploadBox.classList.add('loading', 'has-wave');
                            fileInfo.innerHTML = `<span class="circular-wavy-loading"><span class="wave"></span><span class="wave"></span><span class="wave"></span></span> 解析中...`;

                            let result = parsePastedMarkdown(content);

                            // 转换并追加到会话池（每次粘贴一个会话）
                            const convertedBatch = convertYourAIScrollToRikkaHub(result);
                            const convertedConversation = Array.isArray(convertedBatch) ? convertedBatch[0] : null;
                            if (!convertedConversation) {
                                throw new Error('转换结果为空，请检查粘贴内容格式');
                            }

                            convertedConversation.original_data = result;
                            convertedConversation.messages = Array.isArray(result.messages) ? result.messages : [];

                            if (!Array.isArray(sourceData)) {
                                sourceData = [];
                            }

                            // 使用来源 key / 会话 ID 去重，避免重复追加同一会话
                            const duplicateIndex = sourceData.findIndex(item => {
                                if (!item || typeof item !== 'object') return false;
                                const sourceKeyMatched = item._sourceKey && convertedConversation._sourceKey && item._sourceKey === convertedConversation._sourceKey;
                                const idMatched = item.id && convertedConversation.id && String(item.id) === String(convertedConversation.id);
                                return !!(sourceKeyMatched || idMatched);
                            });
                            if (duplicateIndex >= 0) {
                                sourceData[duplicateIndex] = convertedConversation;
                            } else {
                                sourceData.push(convertedConversation);
                            }

                            // 移除加载状态
                            uploadBox.classList.remove('loading', 'has-wave');
                            fileInfo.textContent = `已粘贴 Markdown 内容（累计 ${sourceData.length} 个会话）`;

                            const platform = result.platform || extractPlatformFromUrl(result.url) || 'Unknown';
                            const msgCount = result.messages ? result.messages.length : 0;
                            const dedupeHint = duplicateIndex >= 0 ? '（检测到重复，已覆盖旧会话）' : '';
                            showInfo(`已追加 ${platform} 对话，包含 ${msgCount} 条消息。当前会话池共 ${sourceData.length} 个${dedupeHint}`);
                            saveCurrentSourceBuffersToPool();
                            rebuildWorkspaceFromCurrentSource();

                            // 关闭粘贴对话框
                            closePasteModal();

                            // 自动打开预览编辑对话框
                            setTimeout(() => {
                                openPreviewEditModal(convertedConversation, { sourceType: 'youraiscroll' });
                            }, 500);

                            checkReady();

                            const mergeButton = document.getElementById('mergeButton');
                            if (rikkahubData) {
                                mergeButton.textContent = '合并聊天记录';
                            }

                        } catch (error) {
                            console.error('粘贴内容处理错误:', error);
                            // 移除加载状态
                            uploadBox.classList.remove('loading', 'has-wave');
                            fileInfo.textContent = '粘贴失败';
                            showError('解析粘贴内容失败: ' + error.message);
                            uploadBox.classList.add('error');
                        }
                    }
            
                    // 解析粘贴的 JSON
                    // 解析粘贴的 Markdown
                    function parsePastedMarkdown(markdown) {
                        if (typeof markdown !== 'string' || markdown.trim().length === 0) {
                            throw new Error('粘贴内容为空');
                        }

                        const normalizedMarkdown = markdown.replace(/\r\n/g, '\n');

                        // 提取 URL
                        const urlMatch = normalizedMarkdown.match(/^\s*Original URL:\s*(https?:\/\/[^\n]+)/im);
                        const url = urlMatch ? urlMatch[1] : '';
            
                        // 使用正则表达式匹配行首的消息标记
                        const messagePattern = /^(?:\*\*)?\[(USER|ASSISTANT|SYSTEM|TOOL)\](?:\*\*)?\s*\n*/gim;
                        const messages = [];
                        let lastMatchEnd = 0;
                        let match;
                        let previousMatchRole = null;
                        
                        while ((match = messagePattern.exec(normalizedMarkdown)) !== null) {
                            // 如果这不是第一个匹配，保存前一个消息
                            if (lastMatchEnd > 0) {
                                const previousContent = normalizedMarkdown.substring(lastMatchEnd, match.index).trim();
                                const previousRole = previousMatchRole || 'user';
                                
                                // 过滤掉只有空白字符的内容
                                if (previousContent && previousContent.replace(/\s/g, '').length > 0) {
                                    messages.push({
                                        role: previousRole,
                                        content: previousContent,
                                        timestamp: new Date().toISOString() // 添加时间戳字段，与 DeepSeek/ChatGPT 格式保持一致
                                    });
                                }
                            }
                            
                            // 记录当前匹配的角色和结束位置
                            previousMatchRole = match[1].toLowerCase();
                            lastMatchEnd = match.index + match[0].length;
                        }
                        
                        // 保存最后一个消息
                        if (lastMatchEnd > 0) {
                            const lastContent = normalizedMarkdown.substring(lastMatchEnd).trim();
                            const lastRole = previousMatchRole || 'user';
                            
                            if (lastContent && lastContent.replace(/\s/g, '').length > 0) {
                                messages.push({
                                    role: lastRole,
                                    content: lastContent,
                                    timestamp: new Date().toISOString() // 添加时间戳字段，与 DeepSeek/ChatGPT 格式保持一致
                                });
                            }
                        }
            
                        if (messages.length === 0) {
                            throw new Error('Markdown 中没有找到消息内容');
                        }
            
                        // 生成标题
                        const platform = extractPlatformFromUrl(url);
                        const displayPlatformName = platform && platform !== 'unknown' ? getPlatformName(platform) : 'Unknown';
                        const title = `${displayPlatformName} 对话`;
            
                        // 注意：YourAIScroll 的 Markdown 格式不包含原始时间戳
                        // 因此使用当前时间作为对话时间戳，消息时间戳将基于此时间戳递增生成
                        console.warn('YourAIScroll Markdown 格式不包含原始时间戳，使用当前时间作为默认值');
            
                        return {
                            title: title,
                            url: url,
                            platform: platform,
                            timestamp: new Date().toISOString(),
                            messages: messages
                        };
                                }
                        
                                // 预览编辑相关变量
                                let previewEditConversation = null;
                                let previewEditMessages = [];
                                let editingMessageIndex = null;
                                let previewEditContext = {
                                    mode: 'standalone',
                                    messageOnly: false,
                                    sourceType: 'chatgpt'
                                };

                                function normalizePreviewRole(role) {
                                    return normalizeMessageRole(role) || 'user';
                                }

                                function normalizePreviewMessage(message, fallbackMs) {
                                    const safeMessage = message && typeof message === 'object' ? message : {};
                                    let content = '';
                                    if (typeof safeMessage.content === 'string') {
                                        content = safeMessage.content;
                                    } else if (safeMessage.content != null) {
                                        content = String(safeMessage.content);
                                    } else if (Array.isArray(safeMessage.parts)) {
                                        content = extractTextFromRikkaParts(safeMessage.parts);
                                    }

                                    const normalizedTimestamp = normalizeIsoString(
                                        safeMessage.timestamp || safeMessage.createdAt || safeMessage.created_at,
                                        fallbackMs
                                    );

                                    return {
                                        role: normalizePreviewRole(safeMessage.role),
                                        content: content || '',
                                        timestamp: normalizedTimestamp,
                                        selected: safeMessage.selected !== false,
                                        _expanded: safeMessage._expanded === true
                                    };
                                }

                                function buildPreviewEditableMessages(conversation) {
                                    const sourceMessages = Array.isArray(conversation?._editedMessages) && conversation._editedMessages.length > 0
                                        ? conversation._editedMessages
                                        : (Array.isArray(conversation?.messages) && conversation.messages.length > 0
                                        ? conversation.messages
                                        : (Array.isArray(conversation?._rawMessages) ? conversation._rawMessages : []));
                                    const baseMs = normalizeTimestampToMs(conversation?.create_at) || Date.now();
                                    return sourceMessages.map((msg, index) => normalizePreviewMessage(msg, baseMs + (index * 1000)));
                                }

                                function formatPreviewMessageTime(timestamp) {
                                    const ms = normalizeTimestampToMs(timestamp);
                                    if (!ms || !Number.isFinite(ms)) return '未知时间';
                                    return new Date(ms).toLocaleString('zh-CN', {
                                        month: '2-digit',
                                        day: '2-digit',
                                        hour: '2-digit',
                                        minute: '2-digit'
                                    });
                                }

                                function isPreviewMessageLong(text) {
                                    const safeText = String(text || '');
                                    const lineCount = safeText.split(/\r?\n/).length;
                                    return safeText.length > 420 || lineCount > 12;
                                }

                                function isPreviewSafeLinkUrl(url) {
                                    const normalized = String(url || '').trim();
                                    return /^https?:\/\//i.test(normalized) || /^mailto:/i.test(normalized);
                                }

                                function isPreviewEmbeddableImageUrl(url) {
                                    const normalized = String(url || '').trim();
                                    if (!normalized) return false;

                                    const lower = normalized.toLowerCase();
                                    if (lower.startsWith('javascript:')) return false;
                                    if (lower.startsWith('file://') || lower.startsWith('content://')) return false;
                                    if (lower.startsWith('data:image/')) return true;
                                    if (lower.startsWith('blob:')) return true;
                                    if (lower.startsWith('http://') || lower.startsWith('https://')) return true;
                                    if (/^(?:\.{1,2}\/|\/)/.test(lower)) {
                                        return /\.(png|jpe?g|gif|webp|bmp|svg)(\?.*)?$/i.test(lower);
                                    }
                                    return /^[^:\s]+?\.(png|jpe?g|gif|webp|bmp|svg)(\?.*)?$/i.test(lower);
                                }

                                function buildPreviewImageReferenceCalloutHtml(label, reference) {
                                    const safeLabel = escapeHtml(String(label || '图片引用').trim() || '图片引用');
                                    const safeReference = escapeHtml(String(reference || '').trim() || '[空引用]');
                                    return `
                                        <div class="preview-rich-callout preview-rich-callout-image">
                                            <div class="preview-rich-callout-head">
                                                <span class="preview-rich-callout-icon" aria-hidden="true">◫</span>
                                                <span class="preview-rich-callout-title">${safeLabel}</span>
                                            </div>
                                            <div class="preview-rich-callout-body">
                                                <div class="preview-rich-ref-url">${safeReference}</div>
                                            </div>
                                        </div>
                                    `.trim();
                                }

                                function parsePreviewSpecialBlockHeader(lineText) {
                                    const normalized = String(lineText || '').trim();
                                    if (!normalized) return null;

                                    let match = normalized.match(/^\[\/(?:深度思考|思考|thinking|reasoning)\]\s*$/i);
                                    if (match) {
                                        return { kind: 'reasoning', label: '', closing: true };
                                    }

                                    match = normalized.match(/^\[\/(?:工具调用|tool\s*call)\]\s*$/i);
                                    if (match) {
                                        return { kind: 'tool-call', label: '', closing: true };
                                    }

                                    match = normalized.match(/^\[\/(?:工具结果|tool\s*result)\]\s*$/i);
                                    if (match) {
                                        return { kind: 'tool-result', label: '', closing: true };
                                    }

                                    match = normalized.match(/^\[\/(?:图片引用|image\s*reference)\]\s*$/i);
                                    if (match) {
                                        return { kind: 'image-ref', label: '', closing: true };
                                    }

                                    match = normalized.match(/^\[(?:深度思考|思考|thinking|reasoning)\]\s*(.*)$/i);
                                    if (match) {
                                        return { kind: 'reasoning', label: String(match[1] || '').trim(), closing: false };
                                    }

                                    match = normalized.match(/^\[(?:工具调用|tool\s*call)\]\s*(.*)$/i);
                                    if (match) {
                                        return { kind: 'tool-call', label: String(match[1] || '').trim(), closing: false };
                                    }

                                    match = normalized.match(/^\[(?:工具结果|tool\s*result)\]\s*(.*)$/i);
                                    if (match) {
                                        return { kind: 'tool-result', label: String(match[1] || '').trim(), closing: false };
                                    }

                                    match = normalized.match(/^\[(?:图片引用|image\s*reference)\]\s*(.*)$/i);
                                    if (match) {
                                        return { kind: 'image-ref', label: String(match[1] || '').trim(), closing: false };
                                    }

                                    return null;
                                }

                                function isPreviewSpecialBlockHeader(lineText) {
                                    return !!parsePreviewSpecialBlockHeader(lineText);
                                }

                                function appendPreviewAnswerBlock(blocks, text) {
                                    const safeText = String(text || '').trim();
                                    if (!safeText) return;
                                    const last = blocks[blocks.length - 1];
                                    if (last && last.type === 'answer') {
                                        last.text = `${last.text}\n\n${safeText}`;
                                        return;
                                    }
                                    blocks.push({ type: 'answer', text: safeText });
                                }

                                function appendPreviewProcessStep(blocks, step) {
                                    if (!step || typeof step !== 'object') return;
                                    const last = blocks[blocks.length - 1];
                                    if (last && last.type === 'process' && Array.isArray(last.steps)) {
                                        last.steps.push(step);
                                        return;
                                    }
                                    blocks.push({ type: 'process', steps: [step] });
                                }

                                function parsePreviewStructuredBlocks(rawText) {
                                    const lines = String(rawText || '').split('\n');
                                    const blocks = [];
                                    let index = 0;

                                    const hasMatchingClosingAhead = (fromIndex, kind) => {
                                        for (let cursor = fromIndex; cursor < lines.length; cursor++) {
                                            const marker = parsePreviewSpecialBlockHeader(lines[cursor]);
                                            if (!marker) continue;
                                            if (marker.closing && marker.kind === kind) return true;
                                            if (!marker.closing) return false;
                                        }
                                        return false;
                                    };

                                    while (index < lines.length) {
                                        const header = parsePreviewSpecialBlockHeader(lines[index]);
                                        if (!header) {
                                            const textLines = [];
                                            while (index < lines.length && !isPreviewSpecialBlockHeader(lines[index])) {
                                                textLines.push(lines[index]);
                                                index += 1;
                                            }
                                            appendPreviewAnswerBlock(blocks, textLines.join('\n'));
                                            continue;
                                        }
                                        if (header.closing) {
                                            index += 1;
                                            continue;
                                        }

                                        index += 1;
                                        const bodyLines = [];
                                        const hasExplicitClosing = hasMatchingClosingAhead(index, header.kind);
                                        while (index < lines.length) {
                                            const nextLine = lines[index];
                                            const nextTrimmed = String(nextLine || '').trim();
                                            const nextHeader = parsePreviewSpecialBlockHeader(nextTrimmed);
                                            if (nextHeader && nextHeader.closing && nextHeader.kind === header.kind) {
                                                index += 1;
                                                break;
                                            }
                                            if (nextHeader && !nextHeader.closing) {
                                                break;
                                            }

                                            if (nextTrimmed === '' && bodyLines.length > 0) {
                                                if (!hasExplicitClosing) {
                                                    let lookahead = index + 1;
                                                    while (lookahead < lines.length && String(lines[lookahead] || '').trim() === '') {
                                                        lookahead += 1;
                                                    }
                                                    index = lookahead;
                                                    break;
                                                }
                                                let lookahead = index + 1;
                                                while (lookahead < lines.length && String(lines[lookahead] || '').trim() === '') {
                                                    lookahead += 1;
                                                }
                                                const lookaheadHeader = lookahead < lines.length ? parsePreviewSpecialBlockHeader(lines[lookahead]) : null;
                                                if (lookahead >= lines.length || (lookaheadHeader && !lookaheadHeader.closing)) {
                                                    index = lookahead;
                                                    break;
                                                }
                                            }

                                            bodyLines.push(nextLine);
                                            index += 1;
                                        }

                                        const bodyText = bodyLines.join('\n').trim();

                                        if (header.kind === 'image-ref') {
                                            blocks.push({
                                                type: 'image-ref',
                                                label: header.label || '图片引用',
                                                reference: bodyText || header.label || '[空引用]'
                                            });
                                            continue;
                                        }

                                        appendPreviewProcessStep(blocks, {
                                            kind: header.kind,
                                            label: header.label,
                                            body: bodyText
                                        });
                                    }

                                    return blocks;
                                }

                                function renderPreviewMarkdownInline(rawText) {
                                    let safe = escapeHtml(String(rawText || ''));
                                    const inlineStore = [];

                                    safe = safe.replace(/`([^`\n]+)`/g, (_, code) => {
                                        const token = `__PREVIEW_INLINE_CODE_${inlineStore.length}__`;
                                        inlineStore.push(`<code>${code}</code>`);
                                        return token;
                                    });

                                    safe = safe.replace(/!\[([^\]]*)\]\(([^)\n]+)\)/gi, (match, alt, url) => {
                                        const imageAlt = String(alt || '').trim() || 'image';
                                        const imageUrl = String(url || '').trim();
                                        if (!imageUrl) return '';

                                        if (isPreviewEmbeddableImageUrl(imageUrl)) {
                                            const safeAlt = escapeHtml(imageAlt);
                                            const safeUrl = escapeHtml(imageUrl);
                                            return `
                                                <figure class="preview-rich-image-figure">
                                                    <img src="${safeUrl}" alt="${safeAlt}" loading="lazy">
                                                    <figcaption class="preview-rich-image-caption">${safeAlt}</figcaption>
                                                </figure>
                                            `.trim();
                                        }

                                        return buildPreviewImageReferenceCalloutHtml(imageAlt, imageUrl);
                                    });

                                    safe = safe.replace(/\[([^\]]+)\]\(([^)\n]+)\)/gi, (match, label, url) => {
                                        const linkLabel = String(label || '').trim() || String(url || '').trim();
                                        const linkUrl = String(url || '').trim();
                                        const safeLabel = escapeHtml(linkLabel);
                                        if (!linkUrl) return safeLabel;

                                        if (!isPreviewSafeLinkUrl(linkUrl)) {
                                            return `<span class="preview-rich-ref-url">${safeLabel} (${escapeHtml(linkUrl)})</span>`;
                                        }

                                        return `<a href="${escapeHtml(linkUrl)}" target="_blank" rel="noopener noreferrer">${safeLabel}</a>`;
                                    });

                                    safe = safe.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
                                    safe = safe.replace(/\*([^*\n]+)\*/g, '<em>$1</em>');
                                    safe = safe.replace(/~~([^~\n]+)~~/g, '<del>$1</del>');
                                    safe = safe.replace(/\n/g, '<br>');

                                    inlineStore.forEach((html, index) => {
                                        safe = safe.split(`__PREVIEW_INLINE_CODE_${index}__`).join(html);
                                    });

                                    return safe;
                                }

                                function getPreviewProcessStepMeta(stepKind, stepLabel) {
                                    const label = String(stepLabel || '').trim();
                                    if (stepKind === 'reasoning') {
                                        return {
                                            title: label || '思考内容',
                                            icon: '✦',
                                            className: 'kind-reasoning'
                                        };
                                    }
                                    if (stepKind === 'tool-call') {
                                        return {
                                            title: label ? `工具调用 · ${label}` : '工具调用',
                                            icon: '⚙',
                                            className: 'kind-tool-call'
                                        };
                                    }
                                    if (stepKind === 'tool-result') {
                                        return {
                                            title: label ? `工具结果 · ${label}` : '工具结果',
                                            icon: '✔',
                                            className: 'kind-tool-result'
                                        };
                                    }
                                    return {
                                        title: label || '过程',
                                        icon: '•',
                                        className: 'kind-generic'
                                    };
                                }

                                function buildPreviewProcessCardHtml(steps) {
                                    const normalizedSteps = Array.isArray(steps) ? steps.filter(Boolean) : [];
                                    if (normalizedSteps.length === 0) return '';

                                    const singleReasoningOnly = normalizedSteps.length === 1 && normalizedSteps[0]?.kind === 'reasoning';
                                    const stepsHtml = singleReasoningOnly
                                        ? (() => {
                                            const bodyHtml = renderPreviewMarkdownInline(normalizedSteps[0]?.body || '').trim()
                                                || '<span class="preview-rich-empty">(暂无内容)</span>';
                                            return `<div class="preview-rich-process-thinking-body">${bodyHtml}</div>`;
                                        })()
                                        : normalizedSteps.map(step => {
                                        const meta = getPreviewProcessStepMeta(step?.kind, step?.label);
                                        const bodyHtml = renderPreviewMarkdownInline(step?.body || '').trim();
                                        return `
                                            <div class="preview-rich-process-step ${meta.className}">
                                                <div class="preview-rich-process-step-head">
                                                    <span class="preview-rich-process-step-icon" aria-hidden="true">${meta.icon}</span>
                                                    <span class="preview-rich-process-step-title">${escapeHtml(meta.title)}</span>
                                                </div>
                                                ${bodyHtml ? `<div class="preview-rich-process-step-body">${bodyHtml}</div>` : ''}
                                            </div>
                                        `.trim();
                                    }).join('');

                                    return `
                                        <details class="preview-rich-process-card" open>
                                            <summary class="preview-rich-process-summary">
                                                <span class="preview-rich-process-summary-icon" aria-hidden="true">✦</span>
                                                <span class="preview-rich-process-summary-title">深度思考</span>
                                                <span class="preview-rich-process-summary-meta">${normalizedSteps.length} 步</span>
                                            </summary>
                                            <div class="preview-rich-process-body">${stepsHtml}</div>
                                        </details>
                                    `.trim();
                                }

                                function renderPreviewMessageHtml(text) {
                                    const rawText = String(text || '').replace(/\r\n/g, '\n');
                                    if (!rawText.trim()) {
                                        return '<span style="opacity:0.7;">[空消息]</span>';
                                    }

                                    const blockStore = [];
                                    const storeBlock = (html) => {
                                        const token = `__PREVIEW_BLOCK_${blockStore.length}__`;
                                        blockStore.push(html);
                                        return token;
                                    };

                                    let normalized = rawText.replace(/```([\w-]*)\n?([\s\S]*?)```/g, (_, lang, code) => {
                                        const safeLang = escapeHtml(String(lang || '').trim());
                                        const safeCode = escapeHtml(String(code || '').replace(/^\n+|\n+$/g, ''));
                                        return storeBlock(`<pre><code${safeLang ? ` data-lang="${safeLang}"` : ''}>${safeCode}</code></pre>`);
                                    });

                                    normalized = normalized.replace(/^\s*(?:Thinking Process|Reasoning|思考过程)\s*[:：]\s*([\s\S]*?)\n\s*(?:Answer|回答)\s*[:：]\s*([\s\S]+)$/i, (match, reasoning, answer) => {
                                        const reasoningText = String(reasoning || '').trim();
                                        const answerText = String(answer || '').trim();
                                        if (!reasoningText || !answerText) return match;
                                        return `[深度思考]\n${reasoningText}\n[/深度思考]\n\n${answerText}`;
                                    });

                                    normalized = normalized.replace(/<think>([\s\S]*?)<\/think>/gi, (_, reasoning) => {
                                        const safeReasoning = String(reasoning || '').trim();
                                        return safeReasoning
                                            ? `[深度思考]\n${safeReasoning}\n[/深度思考]`
                                            : '[深度思考]\n[/深度思考]';
                                    });

                                    const structuredBlocks = parsePreviewStructuredBlocks(normalized);
                                    const renderedSections = structuredBlocks.map(block => {
                                        if (block.type === 'process') {
                                            return storeBlock(buildPreviewProcessCardHtml(block.steps));
                                        }
                                        if (block.type === 'image-ref') {
                                            return storeBlock(buildPreviewImageReferenceCalloutHtml(block.label, block.reference));
                                        }
                                        if (block.type === 'answer') {
                                            return renderPreviewMarkdownInline(block.text || '');
                                        }
                                        return '';
                                    }).filter(Boolean);

                                    let safe = renderedSections.length > 0
                                        ? renderedSections.join('<div class="preview-rich-section-gap"></div>')
                                        : renderPreviewMarkdownInline(normalized);

                                    for (let index = blockStore.length - 1; index >= 0; index--) {
                                        safe = safe.split(`__PREVIEW_BLOCK_${index}__`).join(blockStore[index]);
                                    }

                                    return safe;
                                }

                                function updatePreviewMessageCount() {
                                    const countElement = document.getElementById('previewMessageCount');
                                    if (!countElement) return;
                                    const total = previewEditMessages.length;
                                    const selected = previewEditMessages.filter(msg => msg.selected !== false).length;
                                    countElement.textContent = `(已选 ${selected} / ${total} 条)`;
                                }

                                // 打开预览编辑对话框
                                function openPreviewEditModal(conversation, options = {}) {
                                    const compatSourceType = options?.sourceType || conversation?.__sourceType || currentDataSource;
                                    previewEditConversation = conversation;
                                    previewEditContext = {
                                        mode: options?.mode || 'standalone',
                                        messageOnly: options?.messageOnly === true,
                                        sourceType: compatSourceType
                                    };
                                    previewEditMessages = buildPreviewEditableMessages(conversation);

                                    const modal = document.getElementById('previewEditModal');
                                    const modalPanel = document.querySelector('#previewEditModal .preview-edit-modal');
                                    const intro = document.getElementById('previewEditIntro');
                                    const createMs = normalizeTimestampToMs(conversation?.create_at) || Date.now();
                                    const updateMs = normalizeTimestampToMs(conversation?.update_at) || createMs;

                                    if (modalPanel) {
                                        modalPanel.classList.toggle('message-only', previewEditContext.messageOnly);
                                    }
                                    if (intro) {
                                        intro.textContent = previewEditContext.messageOnly
                                            ? '仅编辑消息内容：逐条修改/删除，取消勾选即不参与合并。'
                                            : '你只需要做两件事：确认会话信息、勾选要保留的消息。';
                                    }

                                    document.getElementById('previewTitleInput').value = conversation?.title || '';
                                    document.getElementById('previewCreateTimeInput').value = formatDateTimeForInput(createMs);
                                    document.getElementById('previewUpdateTimeInput').value = formatDateTimeForInput(updateMs);

                                    renderPreviewMessagesList();
                                    modal.classList.add('active');
                                }

                                function openPreviewEditStandalonePreview() {
                                    if (!previewEditConversation) return;

                                    const titleInput = document.getElementById('previewTitleInput');
                                    const createInput = document.getElementById('previewCreateTimeInput');
                                    const fallbackCreateMs = normalizeTimestampToMs(previewEditConversation.create_at) || Date.now();
                                    const createMs = parseDateTimeInputToMs(createInput?.value, fallbackCreateMs);
                                    const sourceType = previewEditContext?.sourceType || previewEditConversation?.platform || currentDataSource;
                                    const sourceLabel = previewEditContext.messageOnly
                                        ? `会话工作台 · ${resolvePreviewSourceLabel(sourceType)}`
                                        : resolvePreviewSourceLabel(sourceType);

                                    const messages = previewEditMessages
                                        .filter(msg => msg.selected !== false)
                                        .map((msg, index) => normalizePreviewMessage(msg, createMs + (index * 1000)))
                                        .map((msg, index) => ({
                                            role: normalizeMessageRole(msg?.role) || 'assistant',
                                            content: String(msg?.content || '').trim(),
                                            timestamp: normalizeIsoString(msg?.timestamp, createMs + (index * 1000))
                                        }))
                                        .filter(msg => msg.content);

                                    if (messages.length === 0) {
                                        showError('暂无可预览消息，请至少保留 1 条已勾选消息。');
                                        return;
                                    }

                                    openWorkspacePreviewWithCustomConversation({
                                        title: (titleInput?.value || previewEditConversation?.title || 'Untitled').trim() || 'Untitled',
                                        sourceLabel: sourceLabel,
                                        messages: messages
                                    });
                                }
                        
                                // 关闭预览编辑对话框
                                function closePreviewEditModal() {
                                    const modal = document.getElementById('previewEditModal');
                                    const modalPanel = document.querySelector('#previewEditModal .preview-edit-modal');
                                    modal.classList.remove('active');
                                    if (modalPanel) {
                                        modalPanel.classList.remove('message-only');
                                    }
                                    previewEditConversation = null;
                                    previewEditMessages = [];
                                    previewEditContext = {
                                        mode: 'standalone',
                                        messageOnly: false,
                                        sourceType: 'chatgpt'
                                    };
                                }
                        
                                // 保存预览编辑
                                function savePreviewEdit() {
                                    if (!previewEditConversation) return;

                                    const titleInput = document.getElementById('previewTitleInput');
                                    const createInput = document.getElementById('previewCreateTimeInput');
                                    const updateInput = document.getElementById('previewUpdateTimeInput');

                                    const fallbackCreateMs = normalizeTimestampToMs(previewEditConversation.create_at) || Date.now();
                                    const fallbackUpdateMs = normalizeTimestampToMs(previewEditConversation.update_at) || fallbackCreateMs;
                                    const createMs = parseDateTimeInputToMs(createInput?.value, fallbackCreateMs);
                                    const updateCandidateMs = parseDateTimeInputToMs(updateInput?.value, fallbackUpdateMs);
                                    const updateMs = Math.max(createMs, updateCandidateMs);

                                    const selectedMessages = previewEditMessages
                                        .filter(msg => msg.selected !== false)
                                        .map((msg, index) => normalizePreviewMessage(msg, createMs + (index * 1000)))
                                        .filter(msg => String(msg.content || '').trim());

                                    if (selectedMessages.length === 0) {
                                        showError('至少保留 1 条消息后再保存。');
                                        return;
                                    }

                                    if (previewEditContext.mode === 'workspace' && previewEditConversation.__workspaceId) {
                                        const binding = getWorkspaceConversationBinding(previewEditConversation.__workspaceId);
                                        if (!binding) {
                                            showError('会话已失效，请关闭后重新打开编辑。');
                                            return;
                                        }

                                        const { item, conversation } = binding;
                                        const title = (titleInput?.value || '').trim() || 'Untitled';
                                        const sourceType = item?.dataSource || currentDataSource;

                                        const editedMessages = selectedMessages.map((msg, index) => ({
                                            role: normalizePreviewRole(msg.role),
                                            content: String(msg.content || ''),
                                            timestamp: normalizeIsoString(msg.timestamp, createMs + (index * 1000))
                                        }));

                                        conversation.title = title;
                                        conversation._editedMessages = editedMessages;

                                        if (sourceType === 'chatgpt') {
                                            conversation.create_time = Math.floor(createMs / 1000);
                                            conversation.update_time = Math.floor(updateMs / 1000);
                                        } else if (sourceType === 'deepseek') {
                                            if (item.bucket === 'sourceData') {
                                                conversation.inserted_at = new Date(createMs).toISOString();
                                                conversation.updated_at = new Date(updateMs).toISOString();
                                            } else {
                                                conversation.created_at = createMs;
                                                conversation.updated_at = updateMs;
                                            }
                                        } else if (sourceType === 'youraiscroll') {
                                            conversation.create_at = Math.floor(createMs / 1000);
                                            conversation.update_at = Math.floor(updateMs / 1000);
                                            conversation.messages = editedMessages.slice();

                                            const platform = conversation.platform || previewEditConversation.platform || 'unknown';
                                            const timestamp = conversation?.original_data?.timestamp || new Date(createMs).toISOString();
                                            const convertedMessages = editedMessages
                                                .map((msg, index) => convertYourAIScrollMessage(msg, timestamp, platform, index))
                                                .filter(Boolean);
                                            conversation._rawMessages = convertedMessages;

                                            let nodes = [];
                                            try {
                                                const parsedNodes = JSON.parse(conversation.nodes || '[]');
                                                if (Array.isArray(parsedNodes)) {
                                                    nodes = parsedNodes;
                                                }
                                            } catch (error) {
                                                nodes = [];
                                            }
                                            if (nodes.length === 0) {
                                                nodes = [{
                                                    id: generateUUID(),
                                                    conversation_id: conversation.id || null,
                                                    node_index: 0,
                                                    messages: [],
                                                    select_index: 0
                                                }];
                                            }
                                            nodes[0].messages = convertedMessages;
                                            conversation.nodes = JSON.stringify(nodes);
                                        }

                                        item.title = title;
                                        item.createdAtMs = createMs;
                                        item.updatedAtMs = updateMs;
                                        item.messageCount = editedMessages.length;
                                        item.previewMessages = editedMessages.map((msg, index) => ({
                                            role: normalizeMessageRole(msg.role) || 'assistant',
                                            content: String(msg.content || '').trim(),
                                            timestamp: normalizeIsoString(msg.timestamp, createMs + (index * 1000))
                                        })).filter(msg => msg.content);

                                        closePreviewEditModal();
                                        renderWorkspaceList();
                                        checkReady();
                                        showInfo('会话消息已保存');
                                        return;
                                    }

                                    previewEditConversation.title = (titleInput?.value || '').trim() || 'Untitled';
                                    previewEditConversation.create_at = Math.floor(createMs / 1000);
                                    previewEditConversation.update_at = Math.floor(updateMs / 1000);
                                    if (!previewEditConversation.platform) {
                                        previewEditConversation.platform = currentDataSource;
                                    }
                                    previewEditConversation.messages = selectedMessages;

                                    if (!previewEditConversation.original_data || typeof previewEditConversation.original_data !== 'object') {
                                        previewEditConversation.original_data = { timestamp: new Date(createMs).toISOString() };
                                    }

                                    const platform = previewEditConversation.platform || 'unknown';
                                    const timestamp = previewEditConversation.original_data?.timestamp || new Date(createMs).toISOString();
                                    const convertedMessages = selectedMessages
                                        .map((msg, index) => convertYourAIScrollMessage(msg, timestamp, platform, index))
                                        .filter(Boolean);
                                    previewEditConversation._rawMessages = convertedMessages;

                                    let nodes = [];
                                    try {
                                        const parsedNodes = JSON.parse(previewEditConversation.nodes || '[]');
                                        if (Array.isArray(parsedNodes)) {
                                            nodes = parsedNodes;
                                        }
                                    } catch (error) {
                                        nodes = [];
                                    }
                                    if (nodes.length === 0) {
                                        nodes = [{
                                            id: generateUUID(),
                                            conversation_id: previewEditConversation.id || null,
                                            node_index: 0,
                                            messages: [],
                                            select_index: 0
                                        }];
                                    }
                                    nodes[0].messages = convertedMessages;
                                    previewEditConversation.nodes = JSON.stringify(nodes);

                                    closePreviewEditModal();
                                    rebuildWorkspaceFromCurrentSource();
                                    showInfo('会话已保存');
                                }
                        
                                // 渲染消息列表
                                function renderPreviewMessagesList() {
                                    const listContainer = document.getElementById('previewMessagesList');
                                    if (!listContainer) return;
                                    updatePreviewMessageCount();
                        
                                    if (previewEditMessages.length === 0) {
                                        listContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--md-sys-color-on-surface-variant);">暂无消息</div>';
                                        return;
                                    }
                        
                                    let html = '';
                                    previewEditMessages.forEach((msg, index) => {
                                        const isChecked = msg.selected !== false;
                                        const role = normalizePreviewRole(msg.role);
                                        const timeStr = formatPreviewMessageTime(msg.timestamp || new Date().toISOString());
                                        const isLongMessage = isPreviewMessageLong(msg.content);
                                        const collapsedClass = !msg._expanded && isLongMessage ? 'collapsed' : '';
                                        const renderedHtml = renderPreviewMessageHtml(msg.content);
                                        const expandLabel = msg._expanded ? '收起' : '展开';
                        
                                        html += `
                                            <div class="preview-message-item role-${role} ${isChecked ? '' : 'is-unselected'}">
                                                <input type="checkbox" class="preview-message-checkbox"
                                                    data-index="${index}"
                                                    ${isChecked ? 'checked' : ''}
                                                    onchange="togglePreviewMessageSelection(${index})">
                                                <div class="preview-chat-main">
                                                    <div class="preview-chat-meta">
                                                        <span class="preview-message-role ${role}">${escapeHtml(role)}</span>
                                                        <span class="preview-message-time">${escapeHtml(timeStr)}</span>
                                                    </div>
                                                    <div class="preview-chat-bubble ${collapsedClass}">
                                                        <div class="preview-chat-text">${renderedHtml}</div>
                                                    </div>
                                                    <div class="preview-message-actions">
                                                        ${isLongMessage ? `<button class="preview-message-action-btn" onclick="togglePreviewMessageExpand(${index})">${expandLabel}</button>` : ''}
                                                        <button class="preview-message-action-btn" onclick="openMessageEditModal(${index})">编辑</button>
                                                        <button class="preview-message-action-btn" onclick="deletePreviewMessage(${index})">删除</button>
                                                    </div>
                                                </div>
                                            </div>
                                        `;
                                    });
                        
                                    listContainer.innerHTML = html;
                                }
                        
                                // 切换消息选中状态
                                function togglePreviewMessageSelection(index) {
                                    if (!previewEditMessages[index]) return;
                                    const checkbox = document.querySelector(`.preview-message-checkbox[data-index="${index}"]`);
                                    previewEditMessages[index].selected = !!checkbox?.checked;
                                    renderPreviewMessagesList();
                                }
                        
                                // 全选消息
                                function selectAllPreviewMessages() {
                                    previewEditMessages.forEach(msg => {
                                        msg.selected = true;
                                    });
                                    renderPreviewMessagesList();
                                }
                        
                                // 全不选消息
                                function deselectAllPreviewMessages() {
                                    previewEditMessages.forEach(msg => {
                                        msg.selected = false;
                                    });
                                    renderPreviewMessagesList();
                                }

                                // 反选消息
                                function invertPreviewMessageSelection() {
                                    previewEditMessages.forEach(msg => {
                                        msg.selected = msg.selected === false;
                                    });
                                    renderPreviewMessagesList();
                                }

                                function togglePreviewMessageExpand(index) {
                                    if (!previewEditMessages[index]) return;
                                    previewEditMessages[index]._expanded = previewEditMessages[index]._expanded !== true;
                                    renderPreviewMessagesList();
                                }
                        
                                // 打开消息编辑对话框
                                function openMessageEditModal(messageIndex) {
                                    if (!previewEditMessages[messageIndex]) return;
                                    editingMessageIndex = messageIndex;
                                    const msg = previewEditMessages[messageIndex];
                                    const messageOnly = previewEditContext.messageOnly === true;
                                    const roleGroup = document.getElementById('messageRoleGroup');
                                    const timeGroup = document.getElementById('messageTimeGroup');
                                    if (roleGroup) {
                                        roleGroup.style.display = messageOnly ? 'none' : '';
                                    }
                                    if (timeGroup) {
                                        timeGroup.style.display = messageOnly ? 'none' : '';
                                    }
                        
                                    document.getElementById('messageRoleInput').value = normalizePreviewRole(msg.role);
                                    document.getElementById('messageTimeInput').value = formatDateTimeForInput(msg.timestamp || new Date().toISOString());
                                    document.getElementById('messageContentInput').value = String(msg.content || '');
                        
                                    const modal = document.getElementById('messageEditModal');
                                    modal.classList.add('active');
                                }
                        
                                // 关闭消息编辑对话框
                                function closeMessageEditModal() {
                                    const modal = document.getElementById('messageEditModal');
                                    modal.classList.remove('active');
                                    editingMessageIndex = null;
                                }
                        
                                // 保存消息编辑
                                function saveMessageEdit() {
                                    if (editingMessageIndex === null || !previewEditMessages[editingMessageIndex]) return;
                                    const messageOnly = previewEditContext.messageOnly === true;
                                    if (!messageOnly) {
                                        const role = normalizePreviewRole(document.getElementById('messageRoleInput').value);
                                        const oldTimestampMs = normalizeTimestampToMs(previewEditMessages[editingMessageIndex].timestamp) || Date.now();
                                        const editedTimestampMs = parseDateTimeInputToMs(document.getElementById('messageTimeInput').value, oldTimestampMs);
                                        previewEditMessages[editingMessageIndex].role = role;
                                        previewEditMessages[editingMessageIndex].timestamp = new Date(editedTimestampMs).toISOString();
                                    }
                                    previewEditMessages[editingMessageIndex].content = document.getElementById('messageContentInput').value;
                        
                                    // 关闭对话框并刷新列表
                                    closeMessageEditModal();
                                    renderPreviewMessagesList();
                        
                                    showInfo('消息已更新');
                                }
                        
                                // 删除消息
                                function deletePreviewMessage(messageIndex) {
                                    if (!previewEditMessages[messageIndex]) return;
                                    if (confirm('确定要删除这条消息吗？')) {
                                        previewEditMessages.splice(messageIndex, 1);
                                        renderPreviewMessagesList();
                                    }
                                }
                        
                                // 辅助函数：格式化日期时间为 input[type="datetime-local"] 格式
                                function formatDateTimeForInput(timestamp) {
                                    let date;
                                    if (typeof timestamp === 'number') {
                                        // 兼容秒级和毫秒级时间戳
                                        date = timestamp < 1e12 ? new Date(timestamp * 1000) : new Date(timestamp);
                                    } else {
                                        date = new Date(timestamp);
                                    }

                                    if (!date || Number.isNaN(date.getTime())) {
                                        date = new Date();
                                    }

                                    const year = date.getFullYear();
                                    const month = String(date.getMonth() + 1).padStart(2, '0');
                                    const day = String(date.getDate()).padStart(2, '0');
                                    const hours = String(date.getHours()).padStart(2, '0');
                                    const minutes = String(date.getMinutes()).padStart(2, '0');
                        
                                    return `${year}-${month}-${day}T${hours}:${minutes}`;
                                }
                        
                                // 辅助函数：截断文本
                                function truncateText(text, maxLength) {
                                    const safeText = String(text || '');
                                    if (safeText.length <= maxLength) {
                                        return safeText;
                                    }
                                    return safeText.substring(0, maxLength) + '...';
                                }
                        
                                // 辅助函数：HTML 转义
                                function escapeHtml(text) {
                                    const div = document.createElement('div');
                                    div.textContent = String(text || '');
                                    return div.innerHTML;
                                }
                        
                        
                                async function handleDeepSeekNewFile(arrayBuffer, uploadBox, fileInfo, fileName) {            // 验证ZIP文件签名
            const data = new Uint8Array(arrayBuffer);
            if (data.length < 4) {
                uploadBox.classList.remove('loading', 'has-wave');
                fileInfo.textContent = fileName + ' (' + formatFileSize(arrayBuffer.byteLength) + ')';
                showError('文件太小，不是有效的 ZIP 文件');
                uploadBox.classList.add('error');
                return;
            }

            const signature = String.fromCharCode(data[0], data[1]);
            if (signature !== 'PK') {
                uploadBox.classList.remove('loading', 'has-wave');
                fileInfo.textContent = fileName + ' (' + formatFileSize(arrayBuffer.byteLength) + ')';
                showError('文件不是有效的 ZIP 文件');
                uploadBox.classList.add('error');
                return;
            }

            const zip = await JSZip.loadAsync(arrayBuffer);
            const files = Object.keys(zip.files);

            // 查找 conversations.json
            const convFile = files.find(f => f.includes('conversations.json'));
            if (!convFile) {
                uploadBox.classList.remove('loading', 'has-wave');
                fileInfo.textContent = fileName + ' (' + formatFileSize(arrayBuffer.byteLength) + ')';
                showError('压缩包中未找到 conversations.json 文件。请确保上传的是正确的 DeepSeek 导出文件。');
                uploadBox.classList.add('error');
                return;
            }

            const content = await zip.file(convFile).async('string');
            sourceData = JSON.parse(content);

            // 移除加载状态
            uploadBox.classList.remove('loading', 'has-wave');
            fileInfo.textContent = fileName + ' (' + formatFileSize(arrayBuffer.byteLength) + ')';
            
            showInfo(`已加载 ${sourceData.length} 个 DeepSeek 对话`);
            saveCurrentSourceBuffersToPool();
            rebuildWorkspaceFromCurrentSource();
            checkReady();
            const mergeButton = document.getElementById('mergeButton');
            if (rikkahubData) {
                mergeButton.textContent = '合并聊天记录';
            }
        }

        async function handleDeepSeekOldFile(arrayBuffer, uploadBox, fileInfo, fileName) {
            // 解析 CSV 文件
            const text = new TextDecoder().decode(arrayBuffer);
            const lines = text.split('\n').filter(line => line.trim());

            if (lines.length < 2) {
                uploadBox.classList.remove('loading', 'has-wave');
                fileInfo.textContent = fileName + ' (' + formatFileSize(arrayBuffer.byteLength) + ')';
                showError('CSV 文件为空或格式不正确');
                uploadBox.classList.add('error');
                return;
            }

            // 使用 parseCSVLine 解析表头，正确处理引号
            const header = parseCSVLine(lines[0]);
            const idIndex = header.findIndex(h => h.trim().toLowerCase() === 'id');
            const timeIndex = header.findIndex(h => h.trim().toLowerCase() === 'time');
            const roleIndex = header.findIndex(h => h.trim().toLowerCase() === 'role');
            const contentIndex = header.findIndex(h => h.trim().toLowerCase() === 'content');

            if (idIndex === -1 || timeIndex === -1 || roleIndex === -1 || contentIndex === -1) {
                uploadBox.classList.remove('loading', 'has-wave');
                fileInfo.textContent = fileName + ' (' + formatFileSize(arrayBuffer.byteLength) + ')';
                showError('CSV 文件格式不正确，缺少必要的列（id, time, role, content）');
                uploadBox.classList.add('error');
                return;
            }

            // 解析数据行
            const messages = [];
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                if (!line.trim()) continue;

                // 简单 CSV 解析（处理带引号的内容）
                const values = parseCSVLine(line);
                if (values.length >= 4) {
                    messages.push({
                        id: values[idIndex].trim(),
                        time: values[timeIndex].trim(),
                        role: values[roleIndex].trim(),
                        content: values[contentIndex].trim()
                    });
                }
            }

            // 将线性消息分组为对话
            sourceData = groupMessagesToConversations(messages, fileName);

            // 移除加载状态
            uploadBox.classList.remove('loading', 'has-wave');
            fileInfo.textContent = fileName + ' (' + formatFileSize(arrayBuffer.byteLength) + ')';
            
            showInfo(`已加载 ${sourceData.length} 个 DeepSeek 对话（从 ${messages.length} 条消息）`);
            saveCurrentSourceBuffersToPool();
            rebuildWorkspaceFromCurrentSource();
            checkReady();
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            return result;
        }

        function groupMessagesToConversations(messages, fileName) {
            const conversations = [];

            if (messages.length === 0) return conversations;

            // 简单策略：将所有消息作为一个对话
            // 更复杂的策略可以根据时间间隔或用户输入来分组
            const conversationId = generateUUID();
            const title = '[DeepSeek Old] ' + (fileName.replace('.csv', '') || 'Imported');

            // 解析第一条消息的时间作为对话创建时间
            const firstMessageTime = parseDateTime(messages[0].time);

            const conversation = {
                id: conversationId,
                title: title,
                created_at: firstMessageTime,
                updated_at: parseDateTime(messages[messages.length - 1].time) || firstMessageTime,
                messages: messages
            };

            conversations.push(conversation);

            return conversations;
        }

        function handleDeepSeekSecondFile(input) {
            const file = input.files[0];
            const uploadBox = document.getElementById('deepseekSecondUpload');
            const fileInfo = document.getElementById('deepseekSecondFileInfo');

            if (file) {
                // 清空之前的状态
                secondSourceData = null;
                saveCurrentSourceBuffersToPool();
                rebuildWorkspaceFromCurrentSource();
                uploadBox.classList.remove('has-file', 'error');
                checkReady();

                // 验证文件类型
                if (!file.name.endsWith('.zip')) {
                    showError('DeepSeek 旧版文件必须是 .zip 格式');
                    uploadBox.classList.add('error');
                    return;
                }

                fileInfo.textContent = file.name + ' (' + formatFileSize(file.size) + ')';
                
                // 添加加载动画
                uploadBox.classList.add('loading', 'has-wave');
                fileInfo.innerHTML = `<span class="circular-wavy-loading"><span class="wave"></span><span class="wave"></span><span class="wave"></span></span> 读取中...`;

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        // 验证ZIP文件签名
                        const data = new Uint8Array(e.target.result);
                        if (data.length < 4) {
                            uploadBox.classList.remove('loading', 'has-wave');
                            showError('文件太小，不是有效的 ZIP 文件');
                            uploadBox.classList.add('error');
                            return;
                        }

                        const signature = String.fromCharCode(data[0], data[1]);
                        if (signature !== 'PK') {
                            uploadBox.classList.remove('loading', 'has-wave');
                            showError('文件不是有效的 ZIP 文件');
                            uploadBox.classList.add('error');
                            return;
                        }

                        const zip = await JSZip.loadAsync(e.target.result);
                        const files = Object.keys(zip.files);

                        // 查找 chat.csv 或 coder.csv
                        const csvFile = files.find(f => f.includes('chat.csv') || f.includes('coder.csv'));
                        if (!csvFile) {
                            uploadBox.classList.remove('loading', 'has-wave');
                            showError('压缩包中未找到 chat.csv 或 coder.csv 文件。请确保上传的是正确的 DeepSeek 旧版导出文件。');
                            uploadBox.classList.add('error');
                            return;
                        }

                        const content = await zip.file(csvFile).async('string');
                        const fileName = csvFile.split('/').pop();

                        // 解析 CSV
                        const lines = content.split('\n').filter(line => line.trim());

                        if (lines.length < 2) {
                            uploadBox.classList.remove('loading', 'has-wave');
                            showError('CSV 文件为空或格式不正确');
                            uploadBox.classList.add('error');
                            return;
                        }

                        // 使用 parseCSVLine 解析表头，正确处理引号
                        const header = parseCSVLine(lines[0]);
                        const idIndex = header.findIndex(h => h.trim().toLowerCase() === 'id');
                        const timeIndex = header.findIndex(h => h.trim().toLowerCase() === 'time');
                        const roleIndex = header.findIndex(h => h.trim().toLowerCase() === 'role');
                        const contentIndex = header.findIndex(h => h.trim().toLowerCase() === 'content');

                        if (idIndex === -1 || timeIndex === -1 || roleIndex === -1 || contentIndex === -1) {
                            uploadBox.classList.remove('loading', 'has-wave');
                            fileInfo.textContent = file.name + ' (' + formatFileSize(file.size) + ')';
                            showError('CSV 文件格式不正确，缺少必要的列（id, time, role, content）');
                            uploadBox.classList.add('error');
                            return;
                        }

                        const messages = [];
                        for (let i = 1; i < lines.length; i++) {
                            const line = lines[i];
                            if (!line.trim()) continue;

                            const values = parseCSVLine(line);
                            if (values.length >= 4) {
                                messages.push({
                                    id: values[idIndex].trim(),
                                    time: values[timeIndex].trim(),
                                    role: values[roleIndex].trim(),
                                    content: values[contentIndex].trim()
                                });
                            }
                        }

                        // 将线性消息分组为对话
                        secondSourceData = groupMessagesToConversations(messages, fileName);

                        // 移除加载状态
                        uploadBox.classList.remove('loading', 'has-wave');
                        fileInfo.textContent = file.name + ' (' + formatFileSize(file.size) + ')';

                        showInfo(`已加载 DeepSeek 旧版数据，包含 ${secondSourceData.length} 个对话（从 ${messages.length} 条消息）`);
                        saveCurrentSourceBuffersToPool();
                        rebuildWorkspaceFromCurrentSource();
                        checkReady();
                    } catch (error) {
                        console.error('DeepSeek 旧版文件处理错误:', error);
                        let errorMsg = '读取 DeepSeek 旧版文件失败: ' + error.message;
                        if (error.message.includes('end of central directory')) {
                            errorMsg = '文件不是有效的 ZIP 文件或文件已损坏。';
                        } else if (error.message.includes('JSON')) {
                            errorMsg = '文件中的 JSON 格式错误。';
                        }
                        // 移除加载状态
                        uploadBox.classList.remove('loading', 'has-wave');
                        fileInfo.textContent = file.name + ' (' + formatFileSize(file.size) + ')';
                        showError(errorMsg);
                        uploadBox.classList.add('error');
                    }
                };

                reader.onerror = function() {
                    // 移除加载状态
                    uploadBox.classList.remove('loading', 'has-wave');
                    fileInfo.textContent = file.name + ' (' + formatFileSize(file.size) + ')';
                    showError('读取 DeepSeek 旧版文件时发生错误');
                    uploadBox.classList.add('error');
                };

                reader.readAsArrayBuffer(file);
            }
        }

        function parseDateTime(dateString) {
            // 尝试解析 ISO 格式时间
            if (dateString.includes('T')) {
                return new Date(dateString).getTime();
            }

            // 尝试解析 DeepSeek 旧版格式：2024-07-15 14:29:40.098246
            const match = dateString.match(/(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?/);
            if (match) {
                const [, year, month, day, hour, minute, second, microsecond] = match;
                const timestamp = new Date(
                    parseInt(year),
                    parseInt(month) - 1,
                    parseInt(day),
                    parseInt(hour),
                    parseInt(minute),
                    parseInt(second),
                    parseInt(microsecond || 0) / 1000
                ).getTime();
                return timestamp;
            }

            return Date.now();
        }

        function handleRikkaHubFile(input) {
            const file = input.files[0];
            const uploadBox = document.getElementById('rikkahubUpload');
            const fileInfo = document.getElementById('rikkahubFileInfo');
            const continueMerge = pendingMergeAfterRikkaUpload === true;

            if (file) {
                // 清空之前的状态
                rikkahubData = null;
                rikkahubSettings = null;
                rikkahubZip = null;
                uploadBox.classList.remove('has-file', 'error');
                checkReady();

                // 验证文件类型
                if (!file.name.endsWith('.zip')) {
                    pendingMergeAfterRikkaUpload = false;
                    showError('RikkaHub 文件必须是 .zip 格式');
                    uploadBox.classList.add('error');
                    return;
                }

                fileInfo.textContent = file.name + ' (' + formatFileSize(file.size) + ')';
                
                // 添加加载动画
                uploadBox.classList.add('loading', 'has-wave');
                fileInfo.innerHTML = `<span class="circular-wavy-loading"><span class="wave"></span><span class="wave"></span><span class="wave"></span></span> 读取中...`;

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        // 验证ZIP文件签名
                        const data = new Uint8Array(e.target.result);
                        if (data.length < 4) {
                            uploadBox.classList.remove('loading', 'has-wave');
                            fileInfo.textContent = file.name + ' (' + formatFileSize(file.size) + ')';
                            showError('RikkaHub 文件太小，不是有效的 ZIP 文件');
                            uploadBox.classList.add('error');
                            return;
                        }

                        // ZIP文件以PK开头
                        const signature = String.fromCharCode(data[0], data[1]);
                        if (signature !== 'PK') {
                            uploadBox.classList.remove('loading', 'has-wave');
                            fileInfo.textContent = file.name + ' (' + formatFileSize(file.size) + ')';
                            showError('RikkaHub 文件不是有效的 ZIP 文件。文件前4字节: ' +
                                Array.from(data.slice(0, 4)).map(b => b.toString(16).padStart(2, '0')).join(' '));
                            uploadBox.classList.add('error');
                            return;
                        }

                        const zip = await JSZip.loadAsync(e.target.result);
                        const files = Object.keys(zip.files);

                        // 保存原始 ZIP 对象
                        rikkahubZip = zip;

                        // 查找 rikka_hub.db（包括 -shm 和 -wal 文件）
                        const dbFile = files.find(f => f.includes('rikka_hub.db') && !f.includes('-shm') && !f.includes('-wal'));
                        if (!dbFile) {
                            uploadBox.classList.remove('loading', 'has-wave');
                            fileInfo.textContent = file.name + ' (' + formatFileSize(file.size) + ')';
                            console.log('ZIP文件中的文件列表:', files);
                            showError('RikkaHub 压缩包中未找到 rikka_hub.db 文件。ZIP 文件中包含: ' + files.join(', '));
                            uploadBox.classList.add('error');
                            return;
                        }

                        const content = await zip.file(dbFile).async('arraybuffer');
                        rikkahubData = new Uint8Array(content);

                        await initSQL();
                        const testDb = new db.Database(rikkahubData);

                        // 验证数据库 - 先检查表是否存在
                        let result;
                        let conversationCount = 0;
                        try {
                            // 检查 ConversationEntity 表是否存在
                            const tables = testDb.exec("SELECT name FROM sqlite_master WHERE type='table' AND name='ConversationEntity'");
                            if (tables.length > 0 && tables[0].values.length > 0) {
                                result = testDb.exec("SELECT COUNT(*) FROM ConversationEntity");
                                conversationCount = result[0].values[0][0];
                            } else {
                                // 检查是否有任何表
                                const allTables = testDb.exec("SELECT name FROM sqlite_master WHERE type='table' ORDER BY name");
                                const tableCount = allTables.length > 0 ? allTables[0].values.length : 0;
                                
                                if (tableCount === 0) {
                                    // 数据库为空，检查是否有 WAL 文件
                                    const hasWalFile = files.some(f => f.includes('rikka_hub-wal'));
                                    if (hasWalFile) {
                                        // 检测到 WAL 文件，这是一个正常的 RikkaHub 备份
                                        // sql.js 无法直接读取 WAL 文件，但数据库结构是正确的
                                        // 我们跳过表检查，允许加载
                                        console.log('检测到 WAL 文件，跳过表检查');
                                        conversationCount = 0; // 无法在浏览器中读取 WAL 文件获取准确数量
                                    } else {
                                        throw new Error('数据库文件为空，未找到任何表。请确保上传的是从 RikkaHub 导出的完整备份文件。');
                                    }
                                } else {
                                    const tableNames = allTables[0].values.map(row => row[0]).join(', ');
                                    throw new Error(`数据库中未找到 ConversationEntity 表。现有表: ${tableNames}`);
                                }
                            }
                        } catch (error) {
                            testDb.close();
                            uploadBox.classList.remove('loading', 'has-wave');
                            fileInfo.textContent = file.name + ' (' + formatFileSize(file.size) + ')';
                            showError('RikkaHub 数据库验证失败: ' + error.message + '\n请确保上传的是从 RikkaHub 导出的正确备份文件');
                            uploadBox.classList.add('error');
                            return;
                        }
                        
                        // 移除加载状态
                        uploadBox.classList.remove('loading', 'has-wave');
                        uploadBox.classList.add('has-file');
                        fileInfo.textContent = file.name + ' (' + formatFileSize(file.size) + ')';
                        
                        if (conversationCount > 0) {
                            showInfo(`已加载 RikkaHub 数据库，包含 ${conversationCount} 个对话`);
                        }

                        testDb.close();

                        // 读取 settings.json
                        const settingsFile = files.find(f => f.includes('settings.json'));
                        if (settingsFile) {
                            const settingsContent = await zip.file(settingsFile).async('string');
                            rikkahubSettings = JSON.parse(settingsContent);
                            showInfo(`已加载 RikkaHub 设置文件，包含 ${rikkahubSettings.assistants ? rikkahubSettings.assistants.length : 0} 个助手`);
                        } else {
                            console.warn('RikkaHub 压缩包中未找到 settings.json 文件，将创建新配置');
                            rikkahubSettings = { assistants: [] };
                        }

                        checkReady();
                        closeRikkaHubRequiredModal();
                        if (continueMerge) {
                            pendingMergeAfterRikkaUpload = false;
                            setTimeout(() => {
                                mergeData();
                            }, 0);
                        } else {
                            pendingMergeAfterRikkaUpload = false;
                        }
                    } catch (error) {
                        pendingMergeAfterRikkaUpload = false;
                        console.error('RikkaHub 文件处理错误:', error);
                        // 移除加载状态
                        uploadBox.classList.remove('loading', 'has-wave');
                        fileInfo.textContent = file.name + ' (' + formatFileSize(file.size) + ')';
                        if (error.message.includes('end of central directory')) {
                            showError('RikkaHub 文件不是有效的 ZIP 文件或文件已损坏。请确保：\n1. 文件名以 .zip 结尾\n2. 文件是从 RikkaHub 导出的完整备份\n3. 尝试重新导出 RikkaHub 备份');
                        } else if (error.message.includes('database')) {
                            showError('RikkaHub 数据库文件格式错误。请确保文件完整。');
                        } else {
                            showError('读取 RikkaHub 文件失败: ' + error.message + '\n提示：请上传从 RikkaHub 导出的 .zip 备份文件');
                        }
                        uploadBox.classList.add('error');
                    }
                };

                reader.onerror = function() {
                    pendingMergeAfterRikkaUpload = false;
                    // 移除加载状态
                    uploadBox.classList.remove('loading', 'has-wave');
                    fileInfo.textContent = file.name + ' (' + formatFileSize(file.size) + ')';
                    showError('读取 RikkaHub 文件时发生错误');
                    uploadBox.classList.add('error');
                };

                reader.readAsArrayBuffer(file);
            }
        }

        function checkReady() {
            const mergeButton = document.getElementById('mergeButton');
            const sourceReady = hasAnyImportedSourceData();
            const rikkahubReady = !!rikkahubData;
            const selectedConversationCount = sourceReady ? getSelectedConversationCountForCurrentSource() : 0;
            const ready = sourceReady && selectedConversationCount > 0;

            console.log(
                'checkReady: sourceReady=' + sourceReady +
                ', rikkahubReady=' + rikkahubReady +
                ', selected=' + selectedConversationCount +
                ', ready=' + ready
            );

            mergeButton.disabled = !ready;

            // 更新按钮文本和样式
            if (!ready) {
                mergeButton.textContent = '合并聊天记录（请先上传文件）';
                if (!sourceReady) {
                    mergeButton.title = '请先上传源数据文件';
                } else if (selectedConversationCount === 0) {
                    mergeButton.title = '请先在会话工作台中勾选至少一个会话';
                    mergeButton.textContent = '合并聊天记录（未选择会话）';
                } else {
                    mergeButton.title = '';
                }
            } else {
                if (rikkahubReady) {
                    mergeButton.textContent = '合并聊天记录';
                    mergeButton.title = '';
                } else {
                    mergeButton.textContent = '合并聊天记录（下一步选择 RikkaHub 备份）';
                    mergeButton.title = '点击后选择 RikkaHub 原始备份 ZIP';
                }
            }
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function showInfo(message) {
            const status = document.getElementById('status');
            status.className = 'status info';
            status.style.display = 'block';
            status.textContent = message;
        }

        function showSuccess(message) {
            showToast('操作成功', message, 'success', 8000);
        }

        function showError(message) {
            showToast('错误', message, 'error', 10000);
        }

        function showInfo(message) {
            showToast('提示', message, 'info', 6000);
        }

        function updateProgress(percent) {
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            const gridLoading = document.getElementById('gridLoading');
            
            progressBar.style.display = 'block';
            progressFill.style.width = percent + '%';
            
            // 显示网格加载动画
            gridLoading.style.display = 'flex';
            gridLoading.querySelector('.grid-loading').classList.add('animating');
        }

        function getMergeSourceLabel(sourceType) {
            if (sourceType === 'chatgpt') return 'ChatGPT';
            if (sourceType === 'deepseek') return 'DeepSeek';
            if (sourceType === 'youraiscroll') return 'YourAIScroll';
            return String(sourceType || 'Unknown');
        }

        function createMergeSourceStatsBucket() {
            return {
                selected: 0,
                added: 0,
                skipped: 0,
                warnings: 0,
                duplicateSkipped: 0,
                emptySkipped: 0,
                unknownBlocks: 0,
                messagesAdded: 0
            };
        }

        function ensureMergeSourceStatsBucket(stats, sourceType) {
            const key = sourceType || 'chatgpt';
            if (!stats[key] || typeof stats[key] !== 'object') {
                stats[key] = createMergeSourceStatsBucket();
            }
            return stats[key];
        }

        function countUnknownStructuredBlocksInText(text) {
            return extractUnknownStructuredBlockLinesFromText(text).length;
        }

        function extractUnknownStructuredBlockLinesFromText(text) {
            if (typeof text !== 'string' || !text.trim()) return [];
            const lines = text.split(/\r?\n/);
            const candidates = [];
            const openCount = Object.create(null);
            const closeCount = Object.create(null);

            for (const rawLine of lines) {
                const line = String(rawLine || '').trim();
                if (!line) continue;
                if (parsePreviewSpecialBlockHeader(line)) continue;

                // 排除脚注语法，例如 [^1]: xxx
                if (/^\[\^[^\]]+\]:/.test(line)) continue;

                const closeMatch = line.match(/^\[\/([^\[\]\r\n]{1,48})\](?!\()/);
                const openMatch = line.match(/^\[([^\[\]\/\r\n][^\[\]\r\n]{0,47})\](?!\()/);
                if (!closeMatch && !openMatch) continue;

                const rawTag = String((closeMatch?.[1] || openMatch?.[1] || '')).trim();
                const tagName = rawTag.toLowerCase();
                if (!tagName || tagName.length < 2) continue;
                if (tagName === 'user' || tagName === 'assistant' || tagName === 'system' || tagName === 'tool') {
                    continue;
                }
                if (tagName === 'object object') continue;

                const isClosing = !!closeMatch;
                candidates.push({ line, tagName, isClosing });
                if (isClosing) {
                    closeCount[tagName] = (closeCount[tagName] || 0) + 1;
                } else {
                    openCount[tagName] = (openCount[tagName] || 0) + 1;
                }
            }

            // 仅统计“成对标签”作为未知结构块，避免把普通方括号标题误判为异常
            return candidates
                .filter(item => {
                    if (item.isClosing) {
                        return (openCount[item.tagName] || 0) > 0;
                    }
                    return (closeCount[item.tagName] || 0) > 0;
                })
                .map(item => item.line);
        }

        function countUnknownStructuredBlocksInRikkaMessages(messages) {
            if (!Array.isArray(messages)) return 0;
            let count = 0;
            messages.forEach(msg => {
                const parts = Array.isArray(msg?.parts) ? msg.parts : [];
                parts.forEach(part => {
                    if (!part || typeof part !== 'object') return;
                    if (part.type !== 'me.rerere.ai.ui.UIMessagePart.Text') return;
                    count += countUnknownStructuredBlocksInText(String(part.text || ''));
                });
            });
            return count;
        }

        function collectUnknownStructuredBlockDetailsFromRikkaMessages(messages, sourceType, conversationTitle) {
            const details = [];
            if (!Array.isArray(messages)) {
                return { count: 0, lines: details };
            }

            const sourceLabel = getMergeSourceLabel(sourceType);
            const safeTitle = String(conversationTitle || 'Untitled').trim() || 'Untitled';
            messages.forEach(msg => {
                const role = normalizeMessageRole(msg?.role) || 'assistant';
                const parts = Array.isArray(msg?.parts) ? msg.parts : [];
                parts.forEach(part => {
                    if (!part || typeof part !== 'object') return;
                    if (part.type !== 'me.rerere.ai.ui.UIMessagePart.Text') return;
                    const unknownLines = extractUnknownStructuredBlockLinesFromText(String(part.text || ''));
                    unknownLines.forEach(line => {
                        details.push(`${sourceLabel} · ${safeTitle} · ${role}: ${line}`);
                    });
                });
            });

            return { count: details.length, lines: details };
        }

        function buildUnknownDetailPreviewLines(rawLines, limit = 24) {
            const uniqueLines = Array.from(new Set((Array.isArray(rawLines) ? rawLines : [])
                .map(line => String(line || '').trim())
                .filter(Boolean)));

            const clipped = uniqueLines.slice(0, limit).map(line => {
                if (line.length > 220) {
                    return `${line.slice(0, 217)}...`;
                }
                return line;
            });

            if (uniqueLines.length > limit) {
                clipped.push(`...其余 ${uniqueLines.length - limit} 条未展示`);
            }
            return clipped;
        }

        function buildMergeConversationPayload(binding, assistantInfoBySource, imageFiles) {
            const item = binding?.item;
            const conv = binding?.conversation;
            if (!item || !conv) return null;

            const sourceType = item.dataSource || currentDataSource;
            const assistantInfo = assistantInfoBySource[sourceType];
            if (!assistantInfo) return null;

            const assistantId = assistantInfo.assistantId;
            const modelId = assistantInfo.modelId;
            let baseConvId = null;
            let conflictSalt = sourceType;
            let title = 'Untitled';
            let createTime = Date.now();
            let updateTime = createTime;
            let messages = [];

            if (sourceType === 'chatgpt') {
                const sourceConversationId = conv.conversation_id || conv.id || '';
                const fallbackKey = `${conv.title || ''}|${conv.create_time || ''}|${conv.update_time || ''}`;
                baseConvId = normalizeConversationId(sourceConversationId, 'chatgpt', fallbackKey);
                conflictSalt = 'chatgpt';
                title = '[ChatGPT] ' + (conv.title || 'Untitled');
                createTime = conv.create_time ? Math.floor(conv.create_time * 1000) : Date.now();
                updateTime = conv.update_time ? Math.floor(conv.update_time * 1000) : createTime;
                const currentNode = conv.current_node;
                const mapping = conv.mapping || {};
                const editedMessages = Array.isArray(conv?._editedMessages) ? conv._editedMessages : [];
                messages = editedMessages.length > 0
                    ? convertEditableMessagesToRikkaMessages(editedMessages, modelId)
                    : ((currentNode && mapping) ? extractMessages(mapping, currentNode, modelId, imageFiles) : []);
            } else if (sourceType === 'deepseek') {
                const editedMessages = Array.isArray(conv?._editedMessages) ? conv._editedMessages : [];
                if (item.bucket === 'sourceData') {
                    const sourceConversationId = conv.id || '';
                    const fallbackKey = `${conv.title || ''}|${conv.inserted_at || ''}|${conv.updated_at || ''}`;
                    baseConvId = normalizeConversationId(sourceConversationId, 'deepseek', fallbackKey);
                    conflictSalt = 'deepseek-new';
                    title = '[DeepSeek] ' + (conv.title || 'Untitled');
                    createTime = parseDateTime(conv.inserted_at) || Date.now();
                    updateTime = parseDateTime(conv.updated_at) || createTime;
                    const mapping = conv.mapping || {};
                    messages = editedMessages.length > 0
                        ? convertEditableMessagesToRikkaMessages(editedMessages, modelId)
                        : (mapping ? extractDeepSeekMessages(mapping, modelId) : []);
                } else {
                    const sourceConversationId = conv.id || '';
                    const fallbackKey = `${conv.title || ''}|${conv.created_at || ''}|${conv.updated_at || ''}`;
                    baseConvId = normalizeConversationId(sourceConversationId, 'deepseek-old', fallbackKey);
                    conflictSalt = 'deepseek-old';
                    title = conv.title || '[DeepSeek Old] Imported';
                    createTime = conv.created_at || Date.now();
                    updateTime = conv.updated_at || createTime;
                    messages = editedMessages.length > 0
                        ? convertEditableMessagesToRikkaMessages(editedMessages, modelId)
                        : extractDeepSeekOldMessages(conv, modelId);
                }
            } else if (sourceType === 'youraiscroll') {
                const fallbackKey = conv._sourceKey || `${conv.title || ''}|${conv.create_at || ''}|${conv.update_at || ''}`;
                baseConvId = normalizeConversationId(conv.id, 'youraiscroll', fallbackKey);
                conflictSalt = 'youraiscroll';
                title = conv.title || 'YourAIScroll 对话';
                createTime = (conv.create_at || Date.now() / 1000) * 1000;
                updateTime = (conv.update_at || conv.create_at || Date.now() / 1000) * 1000;

                const editedMessages = Array.isArray(conv?._editedMessages) ? conv._editedMessages : [];
                if (editedMessages.length > 0) {
                    const platform = conv.platform || 'unknown';
                    const conversationTimestamp = conv?.original_data?.timestamp || new Date(createTime).toISOString();
                    messages = editedMessages
                        .map((msg, index) => convertYourAIScrollMessage(msg, conversationTimestamp, platform, index))
                        .filter(Boolean);
                } else {
                    messages = (conv._rawMessages || []).filter(msg =>
                        msg &&
                        Array.isArray(msg.parts) &&
                        msg.parts.length > 0 &&
                        normalizeMessageRole(msg.role)
                    );
                }
            }

            return {
                sourceType,
                assistantId,
                baseConvId,
                conflictSalt,
                title,
                createTime,
                updateTime,
                messages
            };
        }

        function buildMergeSourceDiffLines(sourceStats) {
            const order = ['chatgpt', 'deepseek', 'youraiscroll'];
            const lines = [];
            order.forEach(sourceType => {
                const bucket = ensureMergeSourceStatsBucket(sourceStats, sourceType);
                if (bucket.selected <= 0) return;
                lines.push(`${getMergeSourceLabel(sourceType)}：新增 ${bucket.added}，跳过 ${bucket.skipped}，警告 ${bucket.warnings}`);
            });
            return lines;
        }

        function buildMergeWarningLinesFromReport(report) {
            const lines = [];
            if ((report?.chatgptImageMissingCount || 0) > 0) {
                lines.push(`ChatGPT 有 ${report.chatgptImageMissingCount} 个图片引用未在导出包中找到：已保留文本消息并跳过缺失图片。`);
            }
            if ((report?.unknownBlockCount || 0) > 0) {
                lines.push(`检测到 ${report.unknownBlockCount} 个无法识别块标记：将按普通文本保留。`);
            }
            if ((report?.emptyConversationCount || 0) > 0) {
                lines.push(`有 ${report.emptyConversationCount} 个会话在转换后无有效消息：已自动跳过。`);
            }
            if ((report?.duplicateCount || 0) > 0 && report?.duplicateStrategy === 'skip') {
                lines.push(`检测到 ${report.duplicateCount} 个重复会话 ID：按策略“跳过已存在会话”。`);
            }
            if ((report?.keepBothCount || 0) > 0) {
                lines.push(`检测到 ${report.keepBothCount} 个会话 ID 冲突：已按策略“保留并另存”。`);
            }
            if (lines.length === 0) {
                lines.push('未发现结构风险。');
            }
            return lines;
        }

        async function mergeData() {
            console.log('mergeData called, sourceData:', sourceData ? 'loaded' : 'null', 'rikkahubData:', rikkahubData ? 'loaded' : 'null');
            saveCurrentSourceBuffersToPool();
            const mergeDataSelection = getMergeDataByWorkspaceSelection();
            const selectedBindings = Array.isArray(mergeDataSelection.selectedBindings) ? mergeDataSelection.selectedBindings : [];
            const selectedConversationCount = selectedBindings.length;

            if (!hasAnyImportedSourceData()) {
                showError('请先上传源数据文件');
                checkReady();
                return;
            }

            if (selectedConversationCount === 0) {
                showError('请先在会话工作台中勾选至少一个会话');
                checkReady();
                return;
            }

            if (!rikkahubData) {
                pendingMergeAfterRikkaUpload = true;
                openRikkaHubRequiredModal();
                showInfo('请先选择 RikkaHub 原始备份 ZIP，选择后会自动继续合并。');
                checkReady();
                return;
            }

            const duplicateStrategy = getDuplicateStrategy();

            const imageFiles = new Map();
            const mergeButton = document.getElementById('mergeButton');
            mergeButton.disabled = true;
            mergeButton.innerHTML = `<span class="circular-wavy-loading"><span class="wave"></span><span class="wave"></span><span class="wave"></span></span> 合并中...`;

            updateProgress(5);
            showInfo('正在初始化...');
            await new Promise(resolve => setTimeout(resolve, 50));

            let mergedDb = null;
            let dbClosed = false;
            let transactionStarted = false;

            try {
                updateProgress(10);
                showInfo('正在初始化数据库...');

                await initSQL();
                mergedDb = new db.Database(rikkahubData);

                const existingConversationIds = new Set();
                try {
                    const rows = mergedDb.exec('SELECT id FROM ConversationEntity');
                    if (Array.isArray(rows) && rows.length > 0 && Array.isArray(rows[0].values)) {
                        rows[0].values.forEach(row => {
                            const id = row && row[0] ? String(row[0]) : '';
                            if (id) {
                                existingConversationIds.add(id);
                            }
                        });
                    }
                } catch (e) {
                    // 如果是 WAL 模式，跳过表检查
                    if (e.message && e.message.includes('no such table')) {
                        console.log('('WAL 模式：跳过现有对话 ID 读取');
                    } else {
                        throw new Error('无法读取 ConversationEntity 表: ' + e.message);
                    }
                }
                const baselineConversationCount = existingConversationIds.size;

                updateProgress(15);
                showInfo('正在创建助手...');

                let settings = rikkahubSettings || { assistants: [] };
                const assistantMergeStrategy = getAssistantMergeStrategy();
                const unifiedAssistantCustomName = getUnifiedAssistantCustomName();
                const selectedSourceTypes = Array.from(new Set(
                    selectedBindings.map(binding => binding?.item?.dataSource || currentDataSource)
                ));
                const assistantInfoBySource = {};
                const sourceNameMap = {
                    chatgpt: 'ChatGPT',
                    deepseek: 'DeepSeek',
                    youraiscroll: 'YourAIScroll'
                };

                if (assistantMergeStrategy === 'single_assistant') {
                    const compatNameBySource = selectedSourceTypes
                        .map(sourceType => String(getPendingCompatSettingsForSource(sourceType)?.assistantName || '').trim())
                        .find(Boolean) || '';
                    const existingUnifiedName = String(getImportAssistantNameFromSettings('unified') || '').trim();
                    const finalUnifiedName = unifiedAssistantCustomName || compatNameBySource || existingUnifiedName || getDefaultImportAssistantName('unified');
                    const result = createUnifiedImportAssistant(settings, finalUnifiedName);

                    settings = result.updatedSettings;
                    rikkahubSettings = result.updatedSettings;
                    const assistantId = result.assistantId;
                    const assistant = result.updatedSettings.assistants.find(a => a.id === assistantId);
                    const modelId = assistant?.chatModelId || null;

                    const compatNickname = selectedSourceTypes
                        .map(sourceType => String(getPendingCompatSettingsForSource(sourceType)?.userNickname || '').trim())
                        .find(Boolean) || '';
                    if (compatNickname) {
                        if (!rikkahubSettings.displaySetting || typeof rikkahubSettings.displaySetting !== 'object') {
                            rikkahubSettings.displaySetting = {};
                        }
                        rikkahubSettings.displaySetting.userNickname = compatNickname;
                    }

                    if (finalUnifiedName && Array.isArray(rikkahubSettings.assistants)) {
                        const unifiedAssistant = rikkahubSettings.assistants.find(item => item?.id === assistantId);
                        if (unifiedAssistant) {
                            unifiedAssistant.name = finalUnifiedName;
                        }
                    }

                    selectedSourceTypes.forEach(sourceType => {
                        assistantInfoBySource[sourceType] = {
                            sourceName: sourceNameMap[sourceType] || sourceType,
                            assistantId: assistantId,
                            modelId: modelId
                        };
                    });
                } else {
                    selectedSourceTypes.forEach(sourceType => {
                        let result;
                        if (sourceType === 'chatgpt') {
                            result = createChatGPTAssistant(settings);
                        } else if (sourceType === 'deepseek') {
                            result = createDeepSeekAssistant(settings);
                        } else if (sourceType === 'youraiscroll') {
                            result = createYourAIScrollAssistant(settings);
                        } else {
                            return;
                        }

                        settings = result.updatedSettings;
                        rikkahubSettings = result.updatedSettings;
                        const assistantId = result.assistantId;
                        const assistant = result.updatedSettings.assistants.find(a => a.id === assistantId);
                        const modelId = assistant?.chatModelId || null;

                        const compatSettings = getPendingCompatSettingsForSource(sourceType);
                        if (compatSettings.userNickname || compatSettings.assistantName) {
                            if (!rikkahubSettings.displaySetting || typeof rikkahubSettings.displaySetting !== 'object') {
                                rikkahubSettings.displaySetting = {};
                            }
                            if (compatSettings.userNickname) {
                                rikkahubSettings.displaySetting.userNickname = compatSettings.userNickname;
                            }
                            if (compatSettings.assistantName && Array.isArray(rikkahubSettings.assistants)) {
                                const importAssistant = rikkahubSettings.assistants.find(item => item?.id === assistantId);
                                if (importAssistant) {
                                    importAssistant.name = compatSettings.assistantName;
                                }
                            }
                        }

                        assistantInfoBySource[sourceType] = {
                            sourceName: sourceNameMap[sourceType] || sourceType,
                            assistantId: assistantId,
                            modelId: modelId
                        };
                    });
                }

                updateProgress(18);
                showInfo('正在准备 ChatGPT 图片索引...');
                const chatgptImageIndexReport = await ensureChatGPTImageIndexForBindings(selectedBindings);

                updateProgress(20);
                showInfo('正在处理多来源数据...');

                const sourceStats = {
                    chatgpt: createMergeSourceStatsBucket(),
                    deepseek: createMergeSourceStatsBucket(),
                    youraiscroll: createMergeSourceStatsBucket()
                };
                selectedBindings.forEach(binding => {
                    const sourceType = binding?.item?.dataSource || currentDataSource;
                    const bucket = ensureMergeSourceStatsBucket(sourceStats, sourceType);
                    bucket.selected++;
                });

                const simulatedConversationIds = new Set(existingConversationIds);
                const preparedConversations = [];
                let duplicateCount = 0;
                let keepBothCount = 0;
                let insertedMessageCount = 0;
                let emptyConversationCount = 0;
                let unknownBlockCount = 0;
                const unknownBlockDetailLines = [];
                const dryRunTotal = Math.max(selectedBindings.length, 1);

                function resolveConversationIdForInsert(baseId, conflictSalt) {
                    if (!simulatedConversationIds.has(baseId)) {
                        return baseId;
                    }
                    if (duplicateStrategy !== 'keep_both') {
                        return null;
                    }

                    let attempt = 1;
                    while (attempt < 10000) {
                        const candidate = deterministicUuidFromString(`${baseId}|${conflictSalt}|${attempt}`);
                        if (!simulatedConversationIds.has(candidate)) {
                            keepBothCount++;
                            return candidate;
                        }
                        attempt++;
                    }
                    return null;
                }

                for (let idx = 0; idx < selectedBindings.length; idx++) {
                    const binding = selectedBindings[idx];
                    const payload = buildMergeConversationPayload(binding, assistantInfoBySource, imageFiles);
                    if (!payload) continue;

                    const sourceType = payload.sourceType;
                    const sourceBucket = ensureMergeSourceStatsBucket(sourceStats, sourceType);
                    const convId = resolveConversationIdForInsert(payload.baseConvId, payload.conflictSalt);
                    if (!convId) {
                        duplicateCount++;
                        sourceBucket.skipped++;
                        sourceBucket.duplicateSkipped++;
                        continue;
                    }

                    const messages = Array.isArray(payload.messages) ? payload.messages : [];
                    if (messages.length === 0) {
                        emptyConversationCount++;
                        sourceBucket.skipped++;
                        sourceBucket.emptySkipped++;
                        sourceBucket.warnings++;
                        continue;
                    }

                    const unknownBlocksForConversation = countUnknownStructuredBlocksInRikkaMessages(messages);
                    if (unknownBlocksForConversation > 0) {
                        unknownBlockCount += unknownBlocksForConversation;
                        sourceBucket.unknownBlocks += unknownBlocksForConversation;
                        sourceBucket.warnings += unknownBlocksForConversation;

                        const detailResult = collectUnknownStructuredBlockDetailsFromRikkaMessages(
                            messages,
                            sourceType,
                            payload.title
                        );
                        if (Array.isArray(detailResult?.lines) && detailResult.lines.length > 0) {
                            unknownBlockDetailLines.push(...detailResult.lines);
                        }
                    }

                    sourceBucket.added++;
                    sourceBucket.messagesAdded += messages.length;
                    insertedMessageCount += messages.length;
                    simulatedConversationIds.add(convId);

                    preparedConversations.push({
                        sourceType: sourceType,
                        convId: convId,
                        assistantId: payload.assistantId,
                        title: payload.title,
                        createTime: payload.createTime,
                        updateTime: payload.updateTime,
                        messages: messages
                    });

                    if (idx % 10 === 0) {
                        updateProgress(20 + ((idx + 1) / dryRunTotal) * 20);
                        if (idx % 50 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }
                    }
                }

                const chatgptImageMissingCount = chatgptImageIndexReport?.missing || 0;
                if (chatgptImageMissingCount > 0) {
                    const chatgptBucket = ensureMergeSourceStatsBucket(sourceStats, 'chatgpt');
                    chatgptBucket.warnings += chatgptImageMissingCount;
                }

                const warningCount = unknownBlockCount + emptyConversationCount + chatgptImageMissingCount;
                const dryRunReport = {
                    selectedConversationCount: selectedConversationCount,
                    estimatedAddedConversationCount: preparedConversations.length,
                    estimatedMessageCount: insertedMessageCount,
                    duplicateCount: duplicateCount,
                    keepBothCount: keepBothCount,
                    emptyConversationCount: emptyConversationCount,
                    unknownBlockCount: unknownBlockCount,
                    chatgptImageMissingCount: chatgptImageMissingCount,
                    warningCount: warningCount,
                    duplicateStrategy: duplicateStrategy
                };
                const dryRunDiffLines = buildMergeSourceDiffLines(sourceStats);
                const dryRunWarningLines = buildMergeWarningLinesFromReport(dryRunReport);
                const unknownDetailPreviewLines = buildUnknownDetailPreviewLines(unknownBlockDetailLines, 24);
                const dryRunSummary = `本次已选 ${selectedConversationCount} 个会话，预计写入 ${preparedConversations.length} 个会话 / ${insertedMessageCount} 条消息，跳过 ${duplicateCount + emptyConversationCount} 个会话。`;

                updateProgress(45);
                showInfo('预检完成，等待确认...');
                const dryRunConfirmed = await requestMergeDryRunConfirmation(
                    dryRunSummary,
                    dryRunDiffLines,
                    dryRunWarningLines,
                    {
                        unknownLines: unknownDetailPreviewLines,
                        unknownTotal: unknownBlockCount
                    }
                );
                if (!dryRunConfirmed) {
                    showInfo('已取消合并：未写入任何数据。');
                    return;
                }

                updateProgress(50);
                showInfo('正在写入数据库...');
                mergedDb.run('BEGIN TRANSACTION');
                transactionStarted = true;

                let convertedCount = 0;
                const insertTotal = Math.max(preparedConversations.length, 1);

                for (let idx = 0; idx < preparedConversations.length; idx++) {
                    const prepared = preparedConversations[idx];
                    const convId = prepared.convId;
                    const messages = prepared.messages;

                    mergedDb.run(`
                        INSERT OR REPLACE INTO ConversationEntity
                        (id, assistant_id, title, nodes, create_at, update_at, truncate_index, suggestions, is_pinned)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                    `, [convId, prepared.assistantId, prepared.title, '[]', prepared.createTime, prepared.updateTime, -1, '[]', 0]);

                    for (let i = 0; i < messages.length; i++) {
                        const nodeId = generateUUID();
                        const messageJson = JSON.stringify([messages[i]]);
                        mergedDb.run(`
                            INSERT INTO message_node
                            (id, conversation_id, node_index, messages, select_index)
                            VALUES (?, ?, ?, ?, ?)
                        `, [nodeId, convId, i, messageJson, 0]);
                    }

                    existingConversationIds.add(convId);
                    convertedCount++;

                    if (idx % 10 === 0) {
                        updateProgress(50 + ((idx + 1) / insertTotal) * 30);
                        if (idx % 50 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }
                    }
                }

                if (transactionStarted) {
                    mergedDb.run('COMMIT');
                    transactionStarted = false;
                }

                let finalConversationCount = baselineConversationCount;
                try {
                    const countRows = mergedDb.exec('SELECT COUNT(*) FROM ConversationEntity');
                    if (Array.isArray(countRows) && countRows.length > 0 && Array.isArray(countRows[0].values) && countRows[0].values.length > 0) {
                        finalConversationCount = Number(countRows[0].values[0][0]) || baselineConversationCount;
                    }
                } catch (countError) {
                    console.warn('failed to count merged conversations:', countError);
                }
                const actualAddedConversationCount = Math.max(0, finalConversationCount - baselineConversationCount);
                if (actualAddedConversationCount !== convertedCount) {
                    console.warn('merge count mismatch:', { convertedCount, actualAddedConversationCount });
                }

                updateProgress(85);
                showInfo('正在准备数据库...');

                mergedDb.run('PRAGMA journal_mode = DELETE');
                mergedDb.run('PRAGMA wal_checkpoint(TRUNCATE)');

                showInfo('正在生成压缩包...');

                const data = mergedDb.export();
                mergedDb.close();
                dbClosed = true;

                const zip = new JSZip();

                if (rikkahubZip) {
                    for (const fileName in rikkahubZip.files) {
                        const file = rikkahubZip.files[fileName];
                        if (!file.dir &&
                            fileName !== 'rikka_hub.db' &&
                            fileName !== 'rikka_hub-wal' &&
                            fileName !== 'rikka_hub-shm') {
                            const fileData = await file.async('arraybuffer');
                            zip.file(fileName, new Uint8Array(fileData));
                        }
                    }
                }

                const totalImageFiles = Math.max(imageFiles.size, 1);
                let imageWriteIndex = 0;
                for (const [imageUuid, imageData] of imageFiles) {
                    const imagePath = `upload/${imageUuid}`;
                    if (imageData && imageData.data instanceof Uint8Array && imageData.data.length > 0) {
                        zip.file(imagePath, imageData.data);
                    } else {
                        const zipPath = String(imageData?.zipPath || '').trim();
                        if (zipPath && chatgptZip && typeof chatgptZip.file === 'function') {
                            const sourceImageFile = chatgptZip.file(zipPath);
                            if (sourceImageFile) {
                                try {
                                    const sourceBytes = await sourceImageFile.async('uint8array');
                                    if (sourceBytes instanceof Uint8Array && sourceBytes.length > 0) {
                                        zip.file(imagePath, sourceBytes);
                                    } else {
                                        console.warn(`跳过空图片数据: ${zipPath}`);
                                    }
                                } catch (imageError) {
                                    console.warn(`无法写入图片文件: ${zipPath}`, imageError);
                                }
                            } else {
                                console.warn(`图片文件不存在于 ZIP: ${zipPath}`);
                            }
                        } else {
                            console.warn(`跳过缺失图片数据: ${imageUuid}`);
                        }
                    }

                    imageWriteIndex++;
                    if (imageWriteIndex % 20 === 0) {
                        const imageProgress = 85 + Math.min(8, (imageWriteIndex / totalImageFiles) * 8);
                        updateProgress(imageProgress);
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }

                zip.file('rikka_hub.db', data);
                zip.file('rikka_hub-wal', new Uint8Array(0));
                zip.file('rikka_hub-shm', new Uint8Array(0));

                if (rikkahubSettings) {
                    zip.file('settings.json', JSON.stringify(rikkahubSettings, null, 2));
                }

                updateProgress(95);
                showInfo('正在生成下载包...');

                const content = await zip.generateAsync({ type: 'blob' });

                updateProgress(100);
                const duplicateText = duplicateCount > 0 ? `\n跳过 ${duplicateCount} 个重复会话（已存在）` : '';
                const keepBothText = keepBothCount > 0 ? `\n发现 ${keepBothCount} 个 ID 冲突，已按“保留并另存”生成新会话 ID。` : '';
                const emptySkipText = emptyConversationCount > 0 ? `\n跳过 ${emptyConversationCount} 个空会话（转换后无有效消息）。` : '';
                const warningText = warningCount > 0 ? `\n预检警告 ${warningCount} 条，请在下载弹窗查看详情。` : '';
                const sourceTypeSet = new Set(selectedBindings.map(binding => binding?.item?.dataSource || currentDataSource));
                const sourceSummary = [];
                if (sourceStats.chatgpt.added > 0) sourceSummary.push(`ChatGPT ${sourceStats.chatgpt.added} 个`);
                if (sourceStats.deepseek.added > 0) sourceSummary.push(`DeepSeek ${sourceStats.deepseek.added} 个`);
                if (sourceStats.youraiscroll.added > 0) sourceSummary.push(`YourAIScroll ${sourceStats.youraiscroll.added} 个`);

                let titleHint = '会话标题保持导入来源的默认策略。';
                if (sourceTypeSet.size === 1 && sourceTypeSet.has('chatgpt')) {
                    titleHint = 'ChatGPT 会话标题会自动添加 [ChatGPT] 前缀，方便识别。';
                } else if (sourceTypeSet.size === 1 && sourceTypeSet.has('deepseek')) {
                    titleHint = 'DeepSeek 新版会话标题会自动添加 [DeepSeek] 前缀，旧版会话保留原标题。';
                } else if (sourceTypeSet.size === 1 && sourceTypeSet.has('youraiscroll')) {
                    titleHint = 'YourAIScroll 会话保留原标题。';
                } else if (sourceSummary.length > 0) {
                    titleHint = `多来源合并完成：${sourceSummary.join('，')}。`;
                }

                const assistantStrategyText = assistantMergeStrategy === 'single_assistant'
                    ? '助手策略：统一到单一助手。'
                    : '助手策略：按来源分配助手。';
                const mergeSummaryForModal = `本次已选 ${selectedConversationCount} 个会话，成功写入 ${actualAddedConversationCount} 个会话，写入 ${insertedMessageCount} 条消息，跳过 ${duplicateCount + emptyConversationCount} 个会话。`;
                prepareMergedZipDownload(content, 'rikka_hub_merged.zip', mergeSummaryForModal, {
                    diffLines: dryRunDiffLines,
                    warningLines: dryRunWarningLines,
                    unknownLines: unknownDetailPreviewLines,
                    unknownTotal: unknownBlockCount
                });
                showSuccess(`合并完成！已写入 ${actualAddedConversationCount} 个会话 / ${insertedMessageCount} 条消息。${duplicateText}${keepBothText}${emptySkipText}${warningText}\n${assistantStrategyText}\n${titleHint}\n已生成下载包，请在弹窗中确认下载。\n不会影响原有的 RikkaHub 对话。`);

            } catch (error) {
                if (mergedDb && transactionStarted) {
                    try {
                        mergedDb.run('ROLLBACK');
                    } catch (rollbackError) {
                        console.error('rollback failed:', rollbackError);
                    }
                }
                console.error('合并失败:', error);
                console.error('错误堆栈:', error.stack);
                showError('合并失败: ' + error.message + '\n\n详细信息: ' + error);
            } finally {
                if (mergedDb && !dbClosed) {
                    try {
                        mergedDb.close();
                    } catch (closeError) {
                        console.error('close db failed:', closeError);
                    }
                }

                const gridLoading = document.getElementById('gridLoading');
                gridLoading.style.display = 'none';
                gridLoading.querySelector('.grid-loading').classList.remove('animating');

                mergeButton.disabled = false;
                mergeButton.textContent = '合并聊天记录';
            }
        }

        function normalizeMessageRole(role) {
            if (!role) return null;
            const normalized = String(role).toLowerCase();
            if (normalized === 'user' || normalized === 'assistant' || normalized === 'system' || normalized === 'tool') {
                return normalized;
            }
            return null;
        }

        function convertEditableMessagesToRikkaMessages(editMessages, modelId) {
            if (!Array.isArray(editMessages)) return [];
            return editMessages.map(msg => {
                const role = normalizeMessageRole(msg?.role) || 'assistant';
                const text = String(msg?.content || '').trim();
                if (!text) return null;
                return {
                    id: generateUUID(),
                    role: role,
                    parts: [{
                        type: 'me.rerere.ai.ui.UIMessagePart.Text',
                        text: text,
                        metadata: null,
                        priority: 0
                    }],
                    annotations: [],
                    createdAt: formatTimestamp(msg?.timestamp),
                    finishedAt: null,
                    modelId: modelId,
                    usage: null,
                    translation: null
                };
            }).filter(Boolean);
        }

        function shouldSkipChatGPTMessage(msg, contentType) {
            const recipient = typeof msg?.recipient === 'string' ? msg.recipient : '';
            // ChatGPT 导出中这类消息通常是工具调用指令，不是可读聊天内容
            if (recipient.startsWith('api_tool.')) {
                return true;
            }
            if (contentType === 'code' && recipient.includes('call_tool')) {
                return true;
            }
            return false;
        }

        function extractMessages(mapping, currentNodeId, chatgptModelId, imageFiles = null) {
            const messages = [];

            function traceMessages(nodeId) {
                if (!nodeId || !mapping[nodeId]) return;

                const nodeData = mapping[nodeId];
                const msg = nodeData.message;

                if (msg) {
                    const role = msg.author?.role;
                    const content = msg.content || {};
                    const parts = content.parts || [];
                    const contentType = content.content_type || 'text';

                    if (role === 'user' || role === 'assistant' || role === 'system') {
                        if (shouldSkipChatGPTMessage(msg, contentType)) {
                            const parentId = nodeData.parent;
                            if (parentId) {
                                traceMessages(parentId);
                            }
                            return;
                        }

                        let text = '';
                        let messageParts = [];
                        const messageTime = formatTimestamp(msg.create_time);

                        // 处理不同类型的 content
                        if (contentType === 'text') {
                            if (parts.length > 0 && typeof parts[0] === 'string') {
                                text = parts[0];
                            }
                        } else if (contentType === 'code') {
                            // 对于 code 类型，检查 text 字段
                            if (content.text && typeof content.text === 'string') {
                                text = content.text;
                            } else if (parts.length > 0) {
                                if (typeof parts[0] === 'string') {
                                    text = parts[0];
                                } else if (typeof parts[0] === 'object') {
                                    text = parts[0].text || JSON.stringify(parts[0]);
                                }
                            }
                        } else if (contentType === 'multimodal_text') {
                            // 对于 multimodal_text 类型，处理文本和图片
                            if (content.text && typeof content.text === 'string') {
                                text = content.text;
                            }

                            // 遍历 parts 查找图片和文本
                            for (const part of parts) {
                                if (typeof part === 'object') {
                                    // 检查是否是图片引用
                                    if (part.content_type === 'image_asset_pointer' && part.asset_pointer) {
                                        const imageRecord = resolveChatGPTImageRecord(part.asset_pointer);
                                        if (imageRecord) {
                                            const imageUuid = generateUUID();
                                            let canAttachImage = !imageFiles;

                                            if (imageFiles) {
                                                if (typeof imageRecord.zipPath === 'string' && imageRecord.zipPath) {
                                                    imageFiles.set(imageUuid, {
                                                        zipPath: imageRecord.zipPath,
                                                        mimeType: imageRecord.mimeType || 'application/octet-stream'
                                                    });
                                                } else {
                                                    console.warn('skip image: unresolved zipPath for asset pointer');
                                                }
                                                canAttachImage = imageFiles.has(imageUuid);
                                            }

                                            if (canAttachImage) {
                                                messageParts.push({
                                                    type: 'me.rerere.ai.ui.UIMessagePart.Image',
                                                    url: `file:///data/user/0/me.rerere.rikkahub/files/upload/${imageUuid}`,
                                                    metadata: null,
                                                    priority: 1
                                                });
                                            }
                                        }
                                    } else if (part.text && typeof part.text === 'string') {
                                        // 处理文本部分
                                        if (!text) {
                                            text = part.text;
                                        }
                                    }
                                } else if (typeof part === 'string' && !text) {
                                    text = part;
                                }
                            }
                        } else if (contentType === 'execution_output') {
                            // 对于执行输出类型
                            if (content.text && typeof content.text === 'string') {
                                text = content.text;
                            } else if (parts.length > 0 && typeof parts[0] === 'string') {
                                text = parts[0];
                            }
                        }

                        // 构建消息部件数组
                        if (text && text.trim()) {
                            messageParts.push({
                                type: 'me.rerere.ai.ui.UIMessagePart.Text',
                                text: text,
                                metadata: null,
                                priority: 0
                            });
                        }

                        // 只添加有内容（文本或图片）的消息
                        if (messageParts.length > 0) {
                            messages.unshift({
                                id: msg.id || generateUUID(),
                                role: role,
                                parts: messageParts,
                                annotations: [],
                                createdAt: messageTime,
                                finishedAt: null,
                                modelId: chatgptModelId,  // 使用 assistant 的 chatModelId
                                usage: null,
                                translation: null
                            });
                        }
                    }

                    const parentId = nodeData.parent;
                    if (parentId) {
                        traceMessages(parentId);
                    }
                }
            }

            traceMessages(currentNodeId);
            return messages;
        }

        function isUuid(value) {
            return typeof value === 'string' &&
                /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(value);
        }

        function ensureAssistantTag(settings, source) {
            if (!Array.isArray(settings.assistantTags)) {
                settings.assistantTags = [];
            }

            const sourceTagName = `import:${source}`;
            const normalizedName = sourceTagName.toLowerCase();

            let tag = settings.assistantTags.find(item =>
                item &&
                isUuid(item.id) &&
                typeof item.name === 'string' &&
                item.name.trim().toLowerCase() === normalizedName
            );

            if (!tag) {
                const deterministicTagId = deterministicUuidFromString(`assistant-tag|${sourceTagName}`);
                tag = settings.assistantTags.find(item =>
                    item &&
                    item.id === deterministicTagId &&
                    isUuid(item.id)
                );
                if (tag && (!tag.name || typeof tag.name !== 'string')) {
                    tag.name = sourceTagName;
                }
            }

            if (!tag) {
                tag = {
                    id: deterministicUuidFromString(`assistant-tag|${sourceTagName}`),
                    name: sourceTagName
                };
                settings.assistantTags.push(tag);
            } else if (tag.name !== sourceTagName) {
                tag.name = sourceTagName;
            }

            return { tagId: tag.id, sourceTagName };
        }

        function normalizeAssistantTags(tagList) {
            if (!Array.isArray(tagList)) {
                return [];
            }
            return Array.from(new Set(tagList.filter(isUuid)));
        }

        function ensureImportAssistant(settings, sourceType, options = {}) {
            if (!settings || typeof settings !== 'object') {
                settings = {};
            }
            if (!Array.isArray(settings.assistants)) {
                settings.assistants = [];
            }

            const sourceConfigs = {
                chatgpt: { name: 'ChatGPT Import', emoji: '🤖' },
                deepseek: { name: 'DeepSeek Import', emoji: '🧠' },
                youraiscroll: { name: 'YourAIScroll Import', emoji: '📜' },
                unified: { name: 'Unified Import', emoji: '🧩' }
            };
            const source = sourceConfigs[sourceType] ? sourceType : 'deepseek';
            const requestedName = String(options?.preferredName || '').trim();
            const preferredName = requestedName || sourceConfigs[source].name;
            const avatarEmoji = sourceConfigs[source].emoji;
            const { tagId, sourceTagName } = ensureAssistantTag(settings, source);

            const existing = settings.assistants.find(assistant => {
                if (!assistant || !assistant.id) return false;
                const tags = Array.isArray(assistant.tags) ? assistant.tags : [];
                const hasUuidTag = tags.includes(tagId);
                const hasLegacyTag = tags.includes(sourceTagName);
                const sameName = typeof assistant.name === 'string' &&
                    assistant.name.trim().toLowerCase() === preferredName.toLowerCase();
                return hasUuidTag || hasLegacyTag || sameName;
            });

            if (existing) {
                const originalTags = Array.isArray(existing.tags) ? existing.tags : [];
                const normalizedTags = normalizeAssistantTags(originalTags);
                if (!normalizedTags.includes(tagId)) {
                    normalizedTags.push(tagId);
                }
                existing.tags = normalizedTags;

                if (requestedName) {
                    existing.name = requestedName;
                } else if (!existing.name || typeof existing.name !== 'string') {
                    existing.name = preferredName;
                }

                if (!Object.prototype.hasOwnProperty.call(existing, 'chatModelId')) {
                    existing.chatModelId = null;
                }
                return { assistantId: existing.id, updatedSettings: settings };
            }

            const assistantId = generateUUID();
            const assistant = {
                id: assistantId,
                name: preferredName,
                avatar: { type: "me.rerere.rikkahub.data.model.Avatar.Emoji", content: avatarEmoji },
                useAssistantAvatar: false,
                tags: [tagId],
                systemPrompt: "",
                temperature: null,
                topP: null,
                contextMessageSize: 64,
                streamOutput: true,
                enableMemory: false,
                enableRecentChatsReference: false,
                messageTemplate: "{{ message }}",
                presetMessages: [],
                quickMessages: [],
                regexes: [],
                thinkingBudget: 1024,
                maxTokens: null,
                customHeaders: [],
                customBodies: [],
                mcpServers: [],
                localTools: [],
                background: null,
                modeInjectionIds: [],
                lorebookIds: [],
                chatModelId: null
            };

            settings.assistants.push(assistant);
            return { assistantId, updatedSettings: settings };
        }

        function createChatGPTAssistant(settings) {
            return ensureImportAssistant(settings, 'chatgpt');
        }

        function createDeepSeekAssistant(settings) {
            return ensureImportAssistant(settings, 'deepseek');
        }

        function createYourAIScrollAssistant(settings) {
            return ensureImportAssistant(settings, 'youraiscroll');
        }

        function createUnifiedImportAssistant(settings, customName) {
            return ensureImportAssistant(settings, 'unified', { preferredName: customName });
        }

        function getDefaultImportAssistantName(sourceType) {
            const map = {
                chatgpt: 'ChatGPT Import',
                deepseek: 'DeepSeek Import',
                youraiscroll: 'YourAIScroll Import',
                unified: 'Unified Import'
            };
            return map[sourceType] || 'Import Assistant';
        }

        function getImportAssistantNameFromSettings(sourceType) {
            const settings = rikkahubSettings;
            if (!settings || !Array.isArray(settings.assistants)) {
                return '';
            }

            const sourceTagName = `import:${sourceType}`;
            const normalizedTagName = sourceTagName.toLowerCase();
            const assistantTags = Array.isArray(settings.assistantTags) ? settings.assistantTags : [];
            const tag = assistantTags.find(item =>
                item &&
                typeof item.id === 'string' &&
                typeof item.name === 'string' &&
                item.name.trim().toLowerCase() === normalizedTagName
            );
            const tagId = typeof tag?.id === 'string' ? tag.id : null;

            const matched = settings.assistants.find(assistant => {
                if (!assistant || typeof assistant !== 'object') return false;
                const nameMatched = typeof assistant.name === 'string' &&
                    assistant.name.trim().toLowerCase() === getDefaultImportAssistantName(sourceType).toLowerCase();
                const tags = Array.isArray(assistant.tags) ? assistant.tags.map(String) : [];
                const hasUuidTag = tagId ? tags.includes(tagId) : false;
                const hasLegacyTag = tags.includes(sourceTagName);
                return hasUuidTag || hasLegacyTag || nameMatched;
            });

            return typeof matched?.name === 'string' ? matched.name : '';
        }

        function extractDeepSeekMessages(mapping, deepseekModelId) {
            const messages = [];

            // 找到根节点
            const rootId = Object.keys(mapping).find(id => mapping[id].id === 'root');
            if (!rootId) return messages;

            // 从根节点开始遍历
            function traverse(nodeId) {
                if (!nodeId || !mapping[nodeId]) return;

                const nodeData = mapping[nodeId];
                const message = nodeData.message;

                if (message && message.fragments) {
                    // 提取 REQUEST、THINK、RESPONSE 并组装成消息对
                    let requestContent = null;
                    let thinkContent = null;
                    let responseContent = null;
                    let createdAt = formatLocalDateTime(message.inserted_at);

                    // 处理 fragments 数组
                    for (const fragment of message.fragments) {
                        if (fragment.type === 'REQUEST') {
                            requestContent = fragment.content;
                        } else if (fragment.type === 'THINK') {
                            thinkContent = fragment.content;
                        } else if (fragment.type === 'RESPONSE') {
                            responseContent = fragment.content;
                        }
                    }

                    // 如果有用户输入和 AI 回复，创建用户消息
                    if (requestContent && requestContent.trim()) {
                        messages.push({
                            id: generateUUID(),
                            role: 'user',
                            parts: [{
                                type: 'me.rerere.ai.ui.UIMessagePart.Text',
                                text: requestContent,
                                metadata: null,
                                priority: 0
                            }],
                            annotations: [],
                            createdAt: formatLocalDateTime(message.inserted_at),
                            finishedAt: null,
                            modelId: deepseekModelId,
                            usage: null,
                            translation: null
                        });
                    }

                    // 如果有 AI 回复（RESPONSE），创建助手消息（可能包含 THINK）
                    if (responseContent && responseContent.trim()) {
                        const parts = [];

                        // 添加思维链（如果有）
                        if (thinkContent && thinkContent.trim()) {
                            parts.push({
                                type: 'me.rerere.ai.ui.UIMessagePart.Reasoning',
                                reasoning: thinkContent,
                                createdAt: formatISO8601(message.inserted_at),
                                finishedAt: formatISO8601(message.inserted_at),  // 设置 finishedAt 避免思考时间跳动
                                metadata: null,
                                priority: -1
                            });
                        }

                        // 添加回复内容
                        parts.push({
                            type: 'me.rerere.ai.ui.UIMessagePart.Text',
                            text: responseContent,
                            metadata: null,
                            priority: 0
                        });

                        messages.push({
                            id: generateUUID(),
                            role: 'assistant',
                            parts: parts,
                            annotations: [],
                            createdAt: formatLocalDateTime(message.inserted_at),
                            finishedAt: null,
                            modelId: deepseekModelId,
                            usage: null,
                            translation: null
                        });
                    } else if (!requestContent && thinkContent && thinkContent.trim()) {
                        // 兼容 THINK-only 节点：没有 REQUEST/RESPONSE 也保留思维链
                        messages.push({
                            id: generateUUID(),
                            role: 'assistant',
                            parts: [{
                                type: 'me.rerere.ai.ui.UIMessagePart.Reasoning',
                                reasoning: thinkContent,
                                createdAt: formatISO8601(message.inserted_at),
                                finishedAt: formatISO8601(message.inserted_at),
                                metadata: null,
                                priority: -1
                            }],
                            annotations: [],
                            createdAt: formatLocalDateTime(message.inserted_at),
                            finishedAt: null,
                            modelId: deepseekModelId,
                            usage: null,
                            translation: null
                        });
                    }
                }

                // 递归遍历子节点
                const children = nodeData.children || [];
                for (const childId of children) {
                    traverse(childId);
                }
            }

            traverse(rootId);
            return messages;
        }

        function extractDeepSeekOldMessages(conversation, deepseekModelId) {
            const messages = [];

            for (const msg of conversation.messages) {
                const content = msg.content;
                if (!content || !content.trim()) continue;

                const role = msg.role === 'user' ? 'user' : (msg.role === 'assistant' ? 'assistant' : null);
                if (!role) continue;

                messages.push({
                            id: generateUUID(),
                            role: role,
                            parts: [{
                                type: 'me.rerere.ai.ui.UIMessagePart.Text',
                                text: content,
                                metadata: null,
                                priority: 0
                            }],
                            annotations: [],
                            createdAt: formatLocalDateTime(msg.time),  // 使用 formatLocalDateTime 而不是 formatISO8601
                            finishedAt: null,
                            modelId: deepseekModelId,
                            usage: null,
                            translation: null
                        });
            }

            return messages;
        }

        function formatLocalDateTime(dateString) {
            if (!dateString) return new Date().toISOString().slice(0, -1);

            // 如果已经是 ISO 格式,去掉 Z 后缀
            if (dateString.includes('T')) {
                const date = new Date(dateString);
                return date.toISOString().slice(0, -1);
            }

            // 尝试解析其他格式
            const date = new Date(dateString);
            if (!isNaN(date.getTime())) {
                return date.toISOString().slice(0, -1);
            }

            return new Date().toISOString().slice(0, -1);
        }

        function formatISO8601(dateString) {
            if (!dateString) return new Date().toISOString();

            // 如果已经是 ISO 格式
            if (dateString.includes('T')) {
                const date = new Date(dateString);
                return date.toISOString();
            }

            // 尝试解析其他格式
            const date = new Date(dateString);
            if (!isNaN(date.getTime())) {
                return date.toISOString();
            }

            return new Date().toISOString();
        }

        function formatTimestamp(timestamp) {
            if (!timestamp) return new Date().toISOString();

            // 处理多种时间戳格式
            let date;

            if (typeof timestamp === 'number') {
                // 数字时间戳 - 可能是秒级或毫秒级
                // 如果数字小于 1e10，认为是秒级（Unix 时间戳）
                // 如果数字大于 1e10，认为是毫秒级
                if (timestamp < 1e10) {
                    date = new Date(timestamp * 1000);
                } else {
                    date = new Date(timestamp);
                }
            } else if (typeof timestamp === 'string') {
                // 字符串 - 可能是 ISO 8601 格式或其他日期格式
                date = new Date(timestamp);
            } else {
                // 其他类型，尝试直接转换
                date = new Date(timestamp);
            }

            // 检查日期是否有效
            if (isNaN(date.getTime())) {
                console.warn('Invalid timestamp:', timestamp);
                return new Date().toISOString();
            }

            return date.toISOString().slice(0, -1);
        }

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

function isCanonicalUuid(value) {
            if (!value) return false;
            return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(String(value).trim());
        }

        function deterministicUuidFromString(input) {
            const text = String(input || '');
            let h1 = 0xdeadbeef ^ text.length;
            let h2 = 0x41c6ce57 ^ text.length;
            let h3 = 0xc0decafe ^ text.length;
            let h4 = 0x9e3779b9 ^ text.length;

            for (let i = 0; i < text.length; i++) {
                const ch = text.charCodeAt(i);
                h1 = Math.imul(h1 ^ ch, 2654435761);
                h2 = Math.imul(h2 ^ ch, 2246822507);
                h3 = Math.imul(h3 ^ ch, 3266489909);
                h4 = Math.imul(h4 ^ ch, 668265263);
            }

            h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);
            h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h3 ^ (h3 >>> 13), 3266489909);
            h3 = Math.imul(h3 ^ (h3 >>> 16), 2246822507) ^ Math.imul(h4 ^ (h4 >>> 13), 3266489909);
            h4 = Math.imul(h4 ^ (h4 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);

            const toHex8 = (n) => (n >>> 0).toString(16).padStart(8, '0');
            const hex = `${toHex8(h1)}${toHex8(h2)}${toHex8(h3)}${toHex8(h4)}`;
            const bytes = [];
            for (let i = 0; i < 32; i += 2) {
                bytes.push(parseInt(hex.slice(i, i + 2), 16));
            }

            // Force UUID v4 variant bits.
            bytes[6] = (bytes[6] & 0x0f) | 0x40;
            bytes[8] = (bytes[8] & 0x3f) | 0x80;

            const asHex = bytes.map(b => b.toString(16).padStart(2, '0')).join('');
            return `${asHex.slice(0, 8)}-${asHex.slice(8, 12)}-${asHex.slice(12, 16)}-${asHex.slice(16, 20)}-${asHex.slice(20)}`;
        }

        function normalizeConversationId(rawId, sourceTag, fallbackKey) {
            const source = String(sourceTag || 'unknown').toLowerCase();
            const idText = rawId == null ? '' : String(rawId).trim();
            if (isCanonicalUuid(idText)) {
                return idText.toLowerCase();
            }
            if (idText) {
                return deterministicUuidFromString(`${source}|raw|${idText}`);
            }
            return deterministicUuidFromString(`${source}|fallback|${String(fallbackKey || '')}`);
        }


        // 拖拽上传支持
        ['sourceUpload', 'rikkahubUpload'].forEach(id => {
            const element = document.getElementById(id);

            element.addEventListener('dragover', (e) => {
                e.preventDefault();
                element.style.borderColor = 'var(--md-sys-color-primary)';
                element.style.background = 'var(--md-sys-color-surface-container)';
            });

            element.addEventListener('dragleave', (e) => {
                e.preventDefault();
                element.style.borderColor = '';
                element.style.background = '';
            });

            element.addEventListener('drop', (e) => {
                e.preventDefault();
                element.style.borderColor = '';
                element.style.background = '';

                const file = e.dataTransfer.files[0];
                if (file) {
                    const inputId = id === 'sourceUpload' ? 'sourceFile' : 'rikkahubFile';
                    const input = document.getElementById(inputId);
                    const dataTransfer = new DataTransfer();
                    dataTransfer.items.add(file);
                    input.files = dataTransfer.files;

                    if (id === 'sourceUpload') {
                        handleSourceFile(input);
                    } else {
                        handleRikkaHubFile(input);
                    }
                }
            });
        });
    </script>
</body>
</html>
